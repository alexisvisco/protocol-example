// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: protoc-gen-openapiv2/options/openapiv2.proto

import type { ByteSource, MapMessage } from "twirpscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "twirpscript";

import { Value } from "../../google/protobuf/struct.pb";

//========================================//
//                 Types                  //
//========================================//

/**
 * Scheme describes the schemes supported by the OpenAPI Swagger
 * and Operation objects.
 */
export type Scheme = "UNKNOWN" | "HTTP" | "HTTPS" | "WS" | "WSS";

/**
 * `Swagger` is a representation of OpenAPI v2 specification's Swagger object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#swaggerObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      title: "Echo API";
 *      version: "1.0";
 *      description: ";
 *      contact: {
 *        name: "gRPC-Gateway project";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *        email: "none@example.com";
 *      };
 *      license: {
 *        name: "BSD 3-Clause License";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt";
 *      };
 *    };
 *    schemes: HTTPS;
 *    consumes: "application/json";
 *    produces: "application/json";
 *  };
 *
 */
export interface Swagger {
  /**
   * Specifies the OpenAPI Specification version being used. It can be
   * used by the OpenAPI UI and other clients to interpret the API listing. The
   * value MUST be "2.0".
   */
  swagger: string;
  /**
   * Provides metadata about the API. The metadata can be used by the
   * clients if needed.
   */
  info: Info;
  /**
   * The host (name or ip) serving the API. This MUST be the host only and does
   * not include the scheme nor sub-paths. It MAY include a port. If the host is
   * not included, the host serving the documentation is to be used (including
   * the port). The host does not support path templating.
   */
  host: string;
  /**
   * The base path on which the API is served, which is relative to the host. If
   * it is not included, the API is served directly under the host. The value
   * MUST start with a leading slash (/). The basePath does not support path
   * templating.
   * Note that using `base_path` does not change the endpoint paths that are
   * generated in the resulting OpenAPI file. If you wish to use `base_path`
   * with relatively generated OpenAPI paths, the `base_path` prefix must be
   * manually removed from your `google.api.http` paths and your code changed to
   * serve the API from the `base_path`.
   */
  basePath: string;
  /**
   * The transfer protocol of the API. Values MUST be from the list: "http",
   * "https", "ws", "wss". If the schemes is not included, the default scheme to
   * be used is the one used to access the OpenAPI definition itself.
   */
  schemes: Scheme[];
  /**
   * A list of MIME types the APIs can consume. This is global to all APIs but
   * can be overridden on specific API calls. Value MUST be as described under
   * Mime Types.
   */
  consumes: string[];
  /**
   * A list of MIME types the APIs can produce. This is global to all APIs but
   * can be overridden on specific API calls. Value MUST be as described under
   * Mime Types.
   */
  produces: string[];
  /**
   * An object to hold responses that can be used across operations. This
   * property does not define global responses for all operations.
   */
  responses: Swagger.Responses;
  /**
   * Security scheme definitions that can be used across the specification.
   */
  securityDefinitions: SecurityDefinitions;
  /**
   * A declaration of which security schemes are applied for the API as a whole.
   * The list of values describes alternative security schemes that can be used
   * (that is, there is a logical OR between the security requirements).
   * Individual operations can override this definition.
   */
  security: SecurityRequirement[];
  /**
   * Additional external documentation.
   */
  externalDocs: ExternalDocumentation;
  extensions: Swagger.Extensions;
}

declare namespace Swagger {
  export type Responses = Record<string, Response | undefined>;

  export type Extensions = Record<string, Value | undefined>;
}

/**
 * `Operation` is a representation of OpenAPI v2 specification's Operation object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#operationObject
 *
 * Example:
 *
 *  service EchoService {
 *    rpc Echo(SimpleMessage) returns (SimpleMessage) {
 *      option (google.api.http) = {
 *        get: "/v1/example/echo/{id}"
 *      };
 *
 *      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
 *        summary: "Get a message.";
 *        operation_id: "getMessage";
 *        tags: "echo";
 *        responses: {
 *          key: "200"
 *            value: {
 *            description: "OK";
 *          }
 *        }
 *      };
 *    }
 *  }
 */
export interface Operation {
  /**
   * A list of tags for API documentation control. Tags can be used for logical
   * grouping of operations by resources or any other qualifier.
   */
  tags: string[];
  /**
   * A short summary of what the operation does. For maximum readability in the
   * swagger-ui, this field SHOULD be less than 120 characters.
   */
  summary: string;
  /**
   * A verbose explanation of the operation behavior. GFM syntax can be used for
   * rich text representation.
   */
  description: string;
  /**
   * Additional external documentation for this operation.
   */
  externalDocs: ExternalDocumentation;
  /**
   * Unique string used to identify the operation. The id MUST be unique among
   * all operations described in the API. Tools and libraries MAY use the
   * operationId to uniquely identify an operation, therefore, it is recommended
   * to follow common programming naming conventions.
   */
  operationId: string;
  /**
   * A list of MIME types the operation can consume. This overrides the consumes
   * definition at the OpenAPI Object. An empty value MAY be used to clear the
   * global definition. Value MUST be as described under Mime Types.
   */
  consumes: string[];
  /**
   * A list of MIME types the operation can produce. This overrides the produces
   * definition at the OpenAPI Object. An empty value MAY be used to clear the
   * global definition. Value MUST be as described under Mime Types.
   */
  produces: string[];
  /**
   * The list of possible responses as they are returned from executing this
   * operation.
   */
  responses: Operation.Responses;
  /**
   * The transfer protocol for the operation. Values MUST be from the list:
   * "http", "https", "ws", "wss". The value overrides the OpenAPI Object
   * schemes definition.
   */
  schemes: Scheme[];
  /**
   * Declares this operation to be deprecated. Usage of the declared operation
   * should be refrained. Default value is false.
   */
  deprecated: boolean;
  /**
   * A declaration of which security schemes are applied for this operation. The
   * list of values describes alternative security schemes that can be used
   * (that is, there is a logical OR between the security requirements). This
   * definition overrides any declared top-level security. To remove a top-level
   * security declaration, an empty array can be used.
   */
  security: SecurityRequirement[];
  extensions: Operation.Extensions;
}

declare namespace Operation {
  export type Responses = Record<string, Response | undefined>;

  export type Extensions = Record<string, Value | undefined>;
}

/**
 * `Header` is a representation of OpenAPI v2 specification's Header object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#headerObject
 *
 */
export interface Header {
  /**
   * `Description` is a short description of the header.
   */
  description: string;
  /**
   * The type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
   */
  type: string;
  /**
   * `Format` The extending format for the previously mentioned type.
   */
  format: string;
  /**
   * `Default` Declares the value of the header that the server will use if none is provided.
   * See: https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
   * Unlike JSON Schema this value MUST conform to the defined type for the header.
   */
  default: string;
  /**
   * 'Pattern' See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
   */
  pattern: string;
}

/**
 * `Response` is a representation of OpenAPI v2 specification's Response object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#responseObject
 *
 */
export interface Response {
  /**
   * `Description` is a short description of the response.
   * GFM syntax can be used for rich text representation.
   */
  description: string;
  /**
   * `Schema` optionally defines the structure of the response.
   * If `Schema` is not provided, it means there is no content to the response.
   */
  schema: Schema;
  /**
   * `Headers` A list of headers that are sent with the response.
   * `Header` name is expected to be a string in the canonical format of the MIME header key
   * See: https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
   */
  headers: Response.Headers;
  /**
   * `Examples` gives per-mimetype response examples.
   * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#example-object
   */
  examples: Response.Examples;
  extensions: Response.Extensions;
}

declare namespace Response {
  export type Headers = Record<string, Header | undefined>;

  export type Examples = Record<string, string | undefined>;

  export type Extensions = Record<string, Value | undefined>;
}

/**
 * `Info` is a representation of OpenAPI v2 specification's Info object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#infoObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      title: "Echo API";
 *      version: "1.0";
 *      description: ";
 *      contact: {
 *        name: "gRPC-Gateway project";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *        email: "none@example.com";
 *      };
 *      license: {
 *        name: "BSD 3-Clause License";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt";
 *      };
 *    };
 *    ...
 *  };
 *
 */
export interface Info {
  /**
   * The title of the application.
   */
  title: string;
  /**
   * A short description of the application. GFM syntax can be used for rich
   * text representation.
   */
  description: string;
  /**
   * The Terms of Service for the API.
   */
  termsOfService: string;
  /**
   * The contact information for the exposed API.
   */
  contact: Contact;
  /**
   * The license information for the exposed API.
   */
  license: License;
  /**
   * Provides the version of the application API (not to be confused
   * with the specification version).
   */
  version: string;
  extensions: Info.Extensions;
}

declare namespace Info {
  export type Extensions = Record<string, Value | undefined>;
}

/**
 * `Contact` is a representation of OpenAPI v2 specification's Contact object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#contactObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      ...
 *      contact: {
 *        name: "gRPC-Gateway project";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *        email: "none@example.com";
 *      };
 *      ...
 *    };
 *    ...
 *  };
 *
 */
export interface Contact {
  /**
   * The identifying name of the contact person/organization.
   */
  name: string;
  /**
   * The URL pointing to the contact information. MUST be in the format of a
   * URL.
   */
  url: string;
  /**
   * The email address of the contact person/organization. MUST be in the format
   * of an email address.
   */
  email: string;
}

/**
 * `License` is a representation of OpenAPI v2 specification's License object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#licenseObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      ...
 *      license: {
 *        name: "BSD 3-Clause License";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt";
 *      };
 *      ...
 *    };
 *    ...
 *  };
 *
 */
export interface License {
  /**
   * The license name used for the API.
   */
  name: string;
  /**
   * A URL to the license used for the API. MUST be in the format of a URL.
   */
  url: string;
}

/**
 * `ExternalDocumentation` is a representation of OpenAPI v2 specification's
 * ExternalDocumentation object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#externalDocumentationObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    ...
 *    external_docs: {
 *      description: "More about gRPC-Gateway";
 *      url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *    }
 *    ...
 *  };
 *
 */
export interface ExternalDocumentation {
  /**
   * A short description of the target documentation. GFM syntax can be used for
   * rich text representation.
   */
  description: string;
  /**
   * The URL for the target documentation. Value MUST be in the format
   * of a URL.
   */
  url: string;
}

/**
 * `Schema` is a representation of OpenAPI v2 specification's Schema object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
 *
 */
export interface Schema {
  jsonSchema: JSONSchema;
  /**
   * Adds support for polymorphism. The discriminator is the schema property
   * name that is used to differentiate between other schema that inherit this
   * schema. The property name used MUST be defined at this schema and it MUST
   * be in the required property list. When used, the value MUST be the name of
   * this schema or any schema that inherits it.
   */
  discriminator: string;
  /**
   * Relevant only for Schema "properties" definitions. Declares the property as
   * "read only". This means that it MAY be sent as part of a response but MUST
   * NOT be sent as part of the request. Properties marked as readOnly being
   * true SHOULD NOT be in the required list of the defined schema. Default
   * value is false.
   */
  readOnly: boolean;
  /**
   * Additional external documentation for this schema.
   */
  externalDocs: ExternalDocumentation;
  /**
   * A free-form property to include an example of an instance for this schema in JSON.
   * This is copied verbatim to the output.
   */
  example: string;
}

/**
 * `JSONSchema` represents properties from JSON Schema taken, and as used, in
 * the OpenAPI v2 spec.
 *
 * This includes changes made by OpenAPI v2.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
 *
 * See also: https://cswr.github.io/JsonSchema/spec/basic_types/,
 * https://github.com/json-schema-org/json-schema-spec/blob/master/schema.json
 *
 * Example:
 *
 *  message SimpleMessage {
 *    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *      json_schema: {
 *        title: "SimpleMessage"
 *        description: "A simple message."
 *        required: ["id"]
 *      }
 *    };
 *
 *    // Id represents the message identifier.
 *    string id = 1; [
 *        (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
 *          {description: "The unique identifier of the simple message."
 *        }];
 *  }
 *
 */
export interface JSONSchema {
  /**
   * Ref is used to define an external reference to include in the message.
   * This could be a fully qualified proto message reference, and that type must
   * be imported into the protofile. If no message is identified, the Ref will
   * be used verbatim in the output.
   * For example:
   *  `ref: ".google.protobuf.Timestamp"`.
   */
  ref: string;
  /**
   * The title of the schema.
   */
  title: string;
  /**
   * A short description of the schema.
   */
  description: string;
  default: string;
  readOnly: boolean;
  /**
   * A free-form property to include a JSON example of this field. This is copied
   * verbatim to the output swagger.json. Quotes must be escaped.
   * This property is the same for 2.0 and 3.0.0 https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/3.0.0.md#schemaObject  https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
   */
  example: string;
  multipleOf: number;
  /**
   * Maximum represents an inclusive upper limit for a numeric instance. The
   * value of MUST be a number,
   */
  maximum: number;
  exclusiveMaximum: boolean;
  /**
   * minimum represents an inclusive lower limit for a numeric instance. The
   * value of MUST be a number,
   */
  minimum: number;
  exclusiveMinimum: boolean;
  maxLength: bigint;
  minLength: bigint;
  pattern: string;
  maxItems: bigint;
  minItems: bigint;
  uniqueItems: boolean;
  maxProperties: bigint;
  minProperties: bigint;
  required: string[];
  /**
   * Items in 'array' must be unique.
   */
  array: string[];
  type: JSONSchema.JSONSchemaSimpleTypes[];
  /**
   * `Format`
   */
  format: string;
  /**
   * Items in `enum` must be unique https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1
   */
  enum: string[];
}

declare namespace JSONSchema {
  export type JSONSchemaSimpleTypes =
    | "UNKNOWN"
    | "ARRAY"
    | "BOOLEAN"
    | "INTEGER"
    | "NULL"
    | "NUMBER"
    | "OBJECT"
    | "STRING";
}

/**
 * `Tag` is a representation of OpenAPI v2 specification's Tag object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#tagObject
 *
 */
export interface Tag {
  /**
   * A short description for the tag. GFM syntax can be used for rich text
   * representation.
   */
  description: string;
  /**
   * Additional external documentation for this tag.
   */
  externalDocs: ExternalDocumentation;
}

/**
 * `SecurityDefinitions` is a representation of OpenAPI v2 specification's
 * Security Definitions object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityDefinitionsObject
 *
 * A declaration of the security schemes available to be used in the
 * specification. This does not enforce the security schemes on the operations
 * and only serves to provide the relevant details for each scheme.
 */
export interface SecurityDefinitions {
  /**
   * A single security scheme definition, mapping a "name" to the scheme it
   * defines.
   */
  security: SecurityDefinitions.Security;
}

declare namespace SecurityDefinitions {
  export type Security = Record<string, SecurityScheme | undefined>;
}

/**
 * `SecurityScheme` is a representation of OpenAPI v2 specification's
 * Security Scheme object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securitySchemeObject
 *
 * Allows the definition of a security scheme that can be used by the
 * operations. Supported schemes are basic authentication, an API key (either as
 * a header or as a query parameter) and OAuth2's common flows (implicit,
 * password, application and access code).
 */
export interface SecurityScheme {
  /**
   * The type of the security scheme. Valid values are "basic",
   * "apiKey" or "oauth2".
   */
  type: SecurityScheme.Type;
  /**
   * A short description for security scheme.
   */
  description: string;
  /**
   * The name of the header or query parameter to be used.
   * Valid for apiKey.
   */
  name: string;
  /**
   * The location of the API key. Valid values are "query" or
   * "header".
   * Valid for apiKey.
   */
  in: SecurityScheme.In;
  /**
   * The flow used by the OAuth2 security scheme. Valid values are
   * "implicit", "password", "application" or "accessCode".
   * Valid for oauth2.
   */
  flow: SecurityScheme.Flow;
  /**
   * The authorization URL to be used for this flow. This SHOULD be in
   * the form of a URL.
   * Valid for oauth2/implicit and oauth2/accessCode.
   */
  authorizationUrl: string;
  /**
   * The token URL to be used for this flow. This SHOULD be in the
   * form of a URL.
   * Valid for oauth2/password, oauth2/application and oauth2/accessCode.
   */
  tokenUrl: string;
  /**
   * The available scopes for the OAuth2 security scheme.
   * Valid for oauth2.
   */
  scopes: Scopes;
  extensions: SecurityScheme.Extensions;
}

declare namespace SecurityScheme {
  /**
   * The type of the security scheme. Valid values are "basic",
   * "apiKey" or "oauth2".
   */
  export type Type =
    | "TYPE_INVALID"
    | "TYPE_BASIC"
    | "TYPE_API_KEY"
    | "TYPE_OAUTH2";

  /**
   * The location of the API key. Valid values are "query" or "header".
   */
  export type In = "IN_INVALID" | "IN_QUERY" | "IN_HEADER";

  /**
   * The flow used by the OAuth2 security scheme. Valid values are
   * "implicit", "password", "application" or "accessCode".
   */
  export type Flow =
    | "FLOW_INVALID"
    | "FLOW_IMPLICIT"
    | "FLOW_PASSWORD"
    | "FLOW_APPLICATION"
    | "FLOW_ACCESS_CODE";

  export type Extensions = Record<string, Value | undefined>;
}

/**
 * `SecurityRequirement` is a representation of OpenAPI v2 specification's
 * Security Requirement object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityRequirementObject
 *
 * Lists the required security schemes to execute this operation. The object can
 * have multiple security schemes declared in it which are all required (that
 * is, there is a logical AND between the schemes).
 *
 * The name used for each property MUST correspond to a security scheme
 * declared in the Security Definitions.
 */
export interface SecurityRequirement {
  /**
   * Each name must correspond to a security scheme which is declared in
   * the Security Definitions. If the security scheme is of type "oauth2",
   * then the value is a list of scope names required for the execution.
   * For other security scheme types, the array MUST be empty.
   */
  securityRequirement: SecurityRequirement.SecurityRequirement;
}

declare namespace SecurityRequirement {
  /**
   * If the security scheme is of type "oauth2", then the value is a list of
   * scope names required for the execution. For other security scheme types,
   * the array MUST be empty.
   */
  export interface SecurityRequirementValue {
    scope: string[];
  }

  export type SecurityRequirement = Record<
    string,
    SecurityRequirement.SecurityRequirementValue | undefined
  >;
}

/**
 * `Scopes` is a representation of OpenAPI v2 specification's Scopes object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#scopesObject
 *
 * Lists the available scopes for an OAuth2 security scheme.
 */
export interface Scopes {
  /**
   * Maps between a name of a scope to a short description of it (as the value
   * of the property).
   */
  scope: Scopes.Scope;
}

declare namespace Scopes {
  export type Scope = Record<string, string | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Scheme = {
  UNKNOWN: "UNKNOWN",
  HTTP: "HTTP",
  HTTPS: "HTTPS",
  WS: "WS",
  WSS: "WSS",
} as const;

const SchemeFromInt = function (i: number): Scheme {
  switch (i) {
    case 0: {
      return "UNKNOWN";
    }
    case 1: {
      return "HTTP";
    }
    case 2: {
      return "HTTPS";
    }
    case 3: {
      return "WS";
    }
    case 4: {
      return "WSS";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as Scheme;
    }
  }
};

const SchemeToInt = function (i: Scheme): number {
  switch (i) {
    case "UNKNOWN": {
      return 0;
    }
    case "HTTP": {
      return 1;
    }
    case "HTTPS": {
      return 2;
    }
    case "WS": {
      return 3;
    }
    case "WSS": {
      return 4;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const Swagger = {
  /**
   * Serializes a Swagger to protobuf.
   */
  encode: function (msg: Partial<Swagger>): Uint8Array {
    return Swagger._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Swagger from protobuf.
   */
  decode: function (bytes: ByteSource): Swagger {
    return Swagger._readMessage(Swagger.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Swagger to JSON.
   */
  encodeJSON: function (msg: Partial<Swagger>): string {
    return JSON.stringify(Swagger._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Swagger from JSON.
   */
  decodeJSON: function (json: string): Swagger {
    return Swagger._readMessageJSON(Swagger.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Swagger with all fields set to their default value.
   */
  initialize: function (): Swagger {
    return {
      swagger: "",
      info: Info.initialize(),
      host: "",
      basePath: "",
      schemes: [],
      consumes: [],
      produces: [],
      responses: {},
      securityDefinitions: SecurityDefinitions.initialize(),
      security: [],
      externalDocs: ExternalDocumentation.initialize(),
      extensions: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Swagger>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.swagger) {
      writer.writeString(1, msg.swagger);
    }
    if (msg.info) {
      writer.writeMessage(2, msg.info, Info._writeMessage);
    }
    if (msg.host) {
      writer.writeString(3, msg.host);
    }
    if (msg.basePath) {
      writer.writeString(4, msg.basePath);
    }
    if (msg.schemes?.length) {
      writer.writeRepeatedEnum(5, msg.schemes.map(SchemeToInt));
    }
    if (msg.consumes?.length) {
      writer.writeRepeatedString(6, msg.consumes);
    }
    if (msg.produces?.length) {
      writer.writeRepeatedString(7, msg.produces);
    }
    if (msg.responses) {
      writer.writeRepeatedMessage(
        10,
        Object.entries<any>(msg.responses).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        Swagger.Responses._writeMessage
      );
    }
    if (msg.securityDefinitions) {
      writer.writeMessage(
        11,
        msg.securityDefinitions,
        SecurityDefinitions._writeMessage
      );
    }
    if (msg.security?.length) {
      writer.writeRepeatedMessage(
        12,
        msg.security as any,
        SecurityRequirement._writeMessage
      );
    }
    if (msg.externalDocs) {
      writer.writeMessage(
        14,
        msg.externalDocs,
        ExternalDocumentation._writeMessage
      );
    }
    if (msg.extensions) {
      writer.writeRepeatedMessage(
        15,
        Object.entries<any>(msg.extensions).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        Swagger.Extensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Swagger>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.swagger) {
      json.swagger = msg.swagger;
    }
    if (msg.info) {
      const info = Info._writeMessageJSON(msg.info);
      if (Object.keys(info).length > 0) {
        json.info = info;
      }
    }
    if (msg.host) {
      json.host = msg.host;
    }
    if (msg.basePath) {
      json.basePath = msg.basePath;
    }
    if (msg.schemes?.length) {
      json.schemes = msg.schemes;
    }
    if (msg.consumes?.length) {
      json.consumes = msg.consumes;
    }
    if (msg.produces?.length) {
      json.produces = msg.produces;
    }
    if (msg.responses) {
      const responses = Object.fromEntries(
        Object.entries<any>(msg.responses)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Swagger.Responses._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(responses).length > 0) {
        json.responses = responses;
      }
    }
    if (msg.securityDefinitions) {
      const securityDefinitions = SecurityDefinitions._writeMessageJSON(
        msg.securityDefinitions
      );
      if (Object.keys(securityDefinitions).length > 0) {
        json.securityDefinitions = securityDefinitions;
      }
    }
    if (msg.security?.length) {
      json.security = msg.security.map(SecurityRequirement._writeMessageJSON);
    }
    if (msg.externalDocs) {
      const externalDocs = ExternalDocumentation._writeMessageJSON(
        msg.externalDocs
      );
      if (Object.keys(externalDocs).length > 0) {
        json.externalDocs = externalDocs;
      }
    }
    if (msg.extensions) {
      const extensions = Object.fromEntries(
        Object.entries<any>(msg.extensions)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Swagger.Extensions._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(extensions).length > 0) {
        json.extensions = extensions;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Swagger, reader: BinaryReader): Swagger {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.swagger = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.info, Info._readMessage);
          break;
        }
        case 3: {
          msg.host = reader.readString();
          break;
        }
        case 4: {
          msg.basePath = reader.readString();
          break;
        }
        case 5: {
          msg.schemes.push(SchemeFromInt(reader.readEnum()));
          break;
        }
        case 6: {
          msg.consumes.push(reader.readString());
          break;
        }
        case 7: {
          msg.produces.push(reader.readString());
          break;
        }
        case 10: {
          const responses = {} as MapMessage<Swagger.Responses>;
          reader.readMessage(responses, Swagger.Responses._readMessage);
          msg.responses[responses.key] = responses.value;
          break;
        }
        case 11: {
          reader.readMessage(
            msg.securityDefinitions,
            SecurityDefinitions._readMessage
          );
          break;
        }
        case 12: {
          const m = SecurityRequirement.initialize();
          reader.readMessage(m, SecurityRequirement._readMessage);
          msg.security.push(m);
          break;
        }
        case 14: {
          reader.readMessage(
            msg.externalDocs,
            ExternalDocumentation._readMessage
          );
          break;
        }
        case 15: {
          const extensions = {} as MapMessage<Swagger.Extensions>;
          reader.readMessage(extensions, Swagger.Extensions._readMessage);
          msg.extensions[extensions.key] = extensions.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Swagger, json: any): Swagger {
    const _swagger = json.swagger;
    if (_swagger) {
      msg.swagger = _swagger;
    }
    const _info = json.info;
    if (_info) {
      const m = Info.initialize();
      Info._readMessageJSON(m, _info);
      msg.info = m;
    }
    const _host = json.host;
    if (_host) {
      msg.host = _host;
    }
    const _basePath = json.basePath ?? json.base_path;
    if (_basePath) {
      msg.basePath = _basePath;
    }
    const _schemes = json.schemes;
    if (_schemes) {
      msg.schemes = _schemes;
    }
    const _consumes = json.consumes;
    if (_consumes) {
      msg.consumes = _consumes;
    }
    const _produces = json.produces;
    if (_produces) {
      msg.produces = _produces;
    }
    const _responses = json.responses;
    if (_responses) {
      msg.responses = Object.fromEntries(
        Object.entries<any>(_responses)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Swagger.Responses._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _securityDefinitions =
      json.securityDefinitions ?? json.security_definitions;
    if (_securityDefinitions) {
      const m = SecurityDefinitions.initialize();
      SecurityDefinitions._readMessageJSON(m, _securityDefinitions);
      msg.securityDefinitions = m;
    }
    const _security = json.security;
    if (_security) {
      for (const item of _security) {
        const m = SecurityRequirement.initialize();
        SecurityRequirement._readMessageJSON(m, item);
        msg.security.push(m);
      }
    }
    const _externalDocs = json.externalDocs ?? json.external_docs;
    if (_externalDocs) {
      const m = ExternalDocumentation.initialize();
      ExternalDocumentation._readMessageJSON(m, _externalDocs);
      msg.externalDocs = m;
    }
    const _extensions = json.extensions;
    if (_extensions) {
      msg.extensions = Object.fromEntries(
        Object.entries<any>(_extensions)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Swagger.Extensions._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Responses: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<Swagger.Responses>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Response._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<Swagger.Responses>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Response._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<Swagger.Responses>,
      reader: BinaryReader
    ): MapMessage<Swagger.Responses> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Response.initialize(), Response._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<Swagger.Responses>,
      json: any
    ): MapMessage<Swagger.Responses> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Response.initialize();
        Response._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Extensions: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<Swagger.Extensions>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<Swagger.Extensions>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<Swagger.Extensions>,
      reader: BinaryReader
    ): MapMessage<Swagger.Extensions> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Value.initialize(), Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<Swagger.Extensions>,
      json: any
    ): MapMessage<Swagger.Extensions> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Value.initialize();
        Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const Operation = {
  /**
   * Serializes a Operation to protobuf.
   */
  encode: function (msg: Partial<Operation>): Uint8Array {
    return Operation._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Operation from protobuf.
   */
  decode: function (bytes: ByteSource): Operation {
    return Operation._readMessage(
      Operation.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Operation to JSON.
   */
  encodeJSON: function (msg: Partial<Operation>): string {
    return JSON.stringify(Operation._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Operation from JSON.
   */
  decodeJSON: function (json: string): Operation {
    return Operation._readMessageJSON(Operation.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Operation with all fields set to their default value.
   */
  initialize: function (): Operation {
    return {
      tags: [],
      summary: "",
      description: "",
      externalDocs: ExternalDocumentation.initialize(),
      operationId: "",
      consumes: [],
      produces: [],
      responses: {},
      schemes: [],
      deprecated: false,
      security: [],
      extensions: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Operation>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.tags?.length) {
      writer.writeRepeatedString(1, msg.tags);
    }
    if (msg.summary) {
      writer.writeString(2, msg.summary);
    }
    if (msg.description) {
      writer.writeString(3, msg.description);
    }
    if (msg.externalDocs) {
      writer.writeMessage(
        4,
        msg.externalDocs,
        ExternalDocumentation._writeMessage
      );
    }
    if (msg.operationId) {
      writer.writeString(5, msg.operationId);
    }
    if (msg.consumes?.length) {
      writer.writeRepeatedString(6, msg.consumes);
    }
    if (msg.produces?.length) {
      writer.writeRepeatedString(7, msg.produces);
    }
    if (msg.responses) {
      writer.writeRepeatedMessage(
        9,
        Object.entries<any>(msg.responses).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        Operation.Responses._writeMessage
      );
    }
    if (msg.schemes?.length) {
      writer.writeRepeatedEnum(10, msg.schemes.map(SchemeToInt));
    }
    if (msg.deprecated) {
      writer.writeBool(11, msg.deprecated);
    }
    if (msg.security?.length) {
      writer.writeRepeatedMessage(
        12,
        msg.security as any,
        SecurityRequirement._writeMessage
      );
    }
    if (msg.extensions) {
      writer.writeRepeatedMessage(
        13,
        Object.entries<any>(msg.extensions).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        Operation.Extensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Operation>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.tags?.length) {
      json.tags = msg.tags;
    }
    if (msg.summary) {
      json.summary = msg.summary;
    }
    if (msg.description) {
      json.description = msg.description;
    }
    if (msg.externalDocs) {
      const externalDocs = ExternalDocumentation._writeMessageJSON(
        msg.externalDocs
      );
      if (Object.keys(externalDocs).length > 0) {
        json.externalDocs = externalDocs;
      }
    }
    if (msg.operationId) {
      json.operationId = msg.operationId;
    }
    if (msg.consumes?.length) {
      json.consumes = msg.consumes;
    }
    if (msg.produces?.length) {
      json.produces = msg.produces;
    }
    if (msg.responses) {
      const responses = Object.fromEntries(
        Object.entries<any>(msg.responses)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Operation.Responses._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(responses).length > 0) {
        json.responses = responses;
      }
    }
    if (msg.schemes?.length) {
      json.schemes = msg.schemes;
    }
    if (msg.deprecated) {
      json.deprecated = msg.deprecated;
    }
    if (msg.security?.length) {
      json.security = msg.security.map(SecurityRequirement._writeMessageJSON);
    }
    if (msg.extensions) {
      const extensions = Object.fromEntries(
        Object.entries<any>(msg.extensions)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Operation.Extensions._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(extensions).length > 0) {
        json.extensions = extensions;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Operation, reader: BinaryReader): Operation {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.tags.push(reader.readString());
          break;
        }
        case 2: {
          msg.summary = reader.readString();
          break;
        }
        case 3: {
          msg.description = reader.readString();
          break;
        }
        case 4: {
          reader.readMessage(
            msg.externalDocs,
            ExternalDocumentation._readMessage
          );
          break;
        }
        case 5: {
          msg.operationId = reader.readString();
          break;
        }
        case 6: {
          msg.consumes.push(reader.readString());
          break;
        }
        case 7: {
          msg.produces.push(reader.readString());
          break;
        }
        case 9: {
          const responses = {} as MapMessage<Operation.Responses>;
          reader.readMessage(responses, Operation.Responses._readMessage);
          msg.responses[responses.key] = responses.value;
          break;
        }
        case 10: {
          msg.schemes.push(SchemeFromInt(reader.readEnum()));
          break;
        }
        case 11: {
          msg.deprecated = reader.readBool();
          break;
        }
        case 12: {
          const m = SecurityRequirement.initialize();
          reader.readMessage(m, SecurityRequirement._readMessage);
          msg.security.push(m);
          break;
        }
        case 13: {
          const extensions = {} as MapMessage<Operation.Extensions>;
          reader.readMessage(extensions, Operation.Extensions._readMessage);
          msg.extensions[extensions.key] = extensions.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Operation, json: any): Operation {
    const _tags = json.tags;
    if (_tags) {
      msg.tags = _tags;
    }
    const _summary = json.summary;
    if (_summary) {
      msg.summary = _summary;
    }
    const _description = json.description;
    if (_description) {
      msg.description = _description;
    }
    const _externalDocs = json.externalDocs ?? json.external_docs;
    if (_externalDocs) {
      const m = ExternalDocumentation.initialize();
      ExternalDocumentation._readMessageJSON(m, _externalDocs);
      msg.externalDocs = m;
    }
    const _operationId = json.operationId ?? json.operation_id;
    if (_operationId) {
      msg.operationId = _operationId;
    }
    const _consumes = json.consumes;
    if (_consumes) {
      msg.consumes = _consumes;
    }
    const _produces = json.produces;
    if (_produces) {
      msg.produces = _produces;
    }
    const _responses = json.responses;
    if (_responses) {
      msg.responses = Object.fromEntries(
        Object.entries<any>(_responses)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Operation.Responses._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _schemes = json.schemes;
    if (_schemes) {
      msg.schemes = _schemes;
    }
    const _deprecated = json.deprecated;
    if (_deprecated) {
      msg.deprecated = _deprecated;
    }
    const _security = json.security;
    if (_security) {
      for (const item of _security) {
        const m = SecurityRequirement.initialize();
        SecurityRequirement._readMessageJSON(m, item);
        msg.security.push(m);
      }
    }
    const _extensions = json.extensions;
    if (_extensions) {
      msg.extensions = Object.fromEntries(
        Object.entries<any>(_extensions)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Operation.Extensions._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Responses: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<Operation.Responses>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Response._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<Operation.Responses>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Response._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<Operation.Responses>,
      reader: BinaryReader
    ): MapMessage<Operation.Responses> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Response.initialize(), Response._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<Operation.Responses>,
      json: any
    ): MapMessage<Operation.Responses> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Response.initialize();
        Response._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Extensions: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<Operation.Extensions>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<Operation.Extensions>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<Operation.Extensions>,
      reader: BinaryReader
    ): MapMessage<Operation.Extensions> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Value.initialize(), Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<Operation.Extensions>,
      json: any
    ): MapMessage<Operation.Extensions> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Value.initialize();
        Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const Header = {
  /**
   * Serializes a Header to protobuf.
   */
  encode: function (msg: Partial<Header>): Uint8Array {
    return Header._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Header from protobuf.
   */
  decode: function (bytes: ByteSource): Header {
    return Header._readMessage(Header.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Header to JSON.
   */
  encodeJSON: function (msg: Partial<Header>): string {
    return JSON.stringify(Header._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Header from JSON.
   */
  decodeJSON: function (json: string): Header {
    return Header._readMessageJSON(Header.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Header with all fields set to their default value.
   */
  initialize: function (): Header {
    return {
      description: "",
      type: "",
      format: "",
      default: "",
      pattern: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Header>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.description) {
      writer.writeString(1, msg.description);
    }
    if (msg.type) {
      writer.writeString(2, msg.type);
    }
    if (msg.format) {
      writer.writeString(3, msg.format);
    }
    if (msg.default) {
      writer.writeString(6, msg.default);
    }
    if (msg.pattern) {
      writer.writeString(13, msg.pattern);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Header>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.description) {
      json.description = msg.description;
    }
    if (msg.type) {
      json.type = msg.type;
    }
    if (msg.format) {
      json.format = msg.format;
    }
    if (msg.default) {
      json.default = msg.default;
    }
    if (msg.pattern) {
      json.pattern = msg.pattern;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Header, reader: BinaryReader): Header {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.description = reader.readString();
          break;
        }
        case 2: {
          msg.type = reader.readString();
          break;
        }
        case 3: {
          msg.format = reader.readString();
          break;
        }
        case 6: {
          msg.default = reader.readString();
          break;
        }
        case 13: {
          msg.pattern = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Header, json: any): Header {
    const _description = json.description;
    if (_description) {
      msg.description = _description;
    }
    const _type = json.type;
    if (_type) {
      msg.type = _type;
    }
    const _format = json.format;
    if (_format) {
      msg.format = _format;
    }
    const _default = json.default;
    if (_default) {
      msg.default = _default;
    }
    const _pattern = json.pattern;
    if (_pattern) {
      msg.pattern = _pattern;
    }
    return msg;
  },
};

export const Response = {
  /**
   * Serializes a Response to protobuf.
   */
  encode: function (msg: Partial<Response>): Uint8Array {
    return Response._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Response from protobuf.
   */
  decode: function (bytes: ByteSource): Response {
    return Response._readMessage(
      Response.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Response to JSON.
   */
  encodeJSON: function (msg: Partial<Response>): string {
    return JSON.stringify(Response._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Response from JSON.
   */
  decodeJSON: function (json: string): Response {
    return Response._readMessageJSON(Response.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Response with all fields set to their default value.
   */
  initialize: function (): Response {
    return {
      description: "",
      schema: Schema.initialize(),
      headers: {},
      examples: {},
      extensions: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Response>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.description) {
      writer.writeString(1, msg.description);
    }
    if (msg.schema) {
      writer.writeMessage(2, msg.schema, Schema._writeMessage);
    }
    if (msg.headers) {
      writer.writeRepeatedMessage(
        3,
        Object.entries<any>(msg.headers).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        Response.Headers._writeMessage
      );
    }
    if (msg.examples) {
      writer.writeRepeatedMessage(
        4,
        Object.entries<any>(msg.examples).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        Response.Examples._writeMessage
      );
    }
    if (msg.extensions) {
      writer.writeRepeatedMessage(
        5,
        Object.entries<any>(msg.extensions).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        Response.Extensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Response>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.description) {
      json.description = msg.description;
    }
    if (msg.schema) {
      const schema = Schema._writeMessageJSON(msg.schema);
      if (Object.keys(schema).length > 0) {
        json.schema = schema;
      }
    }
    if (msg.headers) {
      const headers = Object.fromEntries(
        Object.entries<any>(msg.headers)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Response.Headers._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(headers).length > 0) {
        json.headers = headers;
      }
    }
    if (msg.examples) {
      const examples = Object.fromEntries(
        Object.entries<any>(msg.examples)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Response.Examples._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(examples).length > 0) {
        json.examples = examples;
      }
    }
    if (msg.extensions) {
      const extensions = Object.fromEntries(
        Object.entries<any>(msg.extensions)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Response.Extensions._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(extensions).length > 0) {
        json.extensions = extensions;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Response, reader: BinaryReader): Response {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.description = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.schema, Schema._readMessage);
          break;
        }
        case 3: {
          const headers = {} as MapMessage<Response.Headers>;
          reader.readMessage(headers, Response.Headers._readMessage);
          msg.headers[headers.key] = headers.value;
          break;
        }
        case 4: {
          const examples = {} as MapMessage<Response.Examples>;
          reader.readMessage(examples, Response.Examples._readMessage);
          msg.examples[examples.key] = examples.value;
          break;
        }
        case 5: {
          const extensions = {} as MapMessage<Response.Extensions>;
          reader.readMessage(extensions, Response.Extensions._readMessage);
          msg.extensions[extensions.key] = extensions.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Response, json: any): Response {
    const _description = json.description;
    if (_description) {
      msg.description = _description;
    }
    const _schema = json.schema;
    if (_schema) {
      const m = Schema.initialize();
      Schema._readMessageJSON(m, _schema);
      msg.schema = m;
    }
    const _headers = json.headers;
    if (_headers) {
      msg.headers = Object.fromEntries(
        Object.entries<any>(_headers)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Response.Headers._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _examples = json.examples;
    if (_examples) {
      msg.examples = Object.fromEntries(
        Object.entries<any>(_examples)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Response.Examples._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _extensions = json.extensions;
    if (_extensions) {
      msg.extensions = Object.fromEntries(
        Object.entries<any>(_extensions)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Response.Extensions._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Headers: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<Response.Headers>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Header._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<Response.Headers>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Header._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<Response.Headers>,
      reader: BinaryReader
    ): MapMessage<Response.Headers> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Header.initialize(), Header._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<Response.Headers>,
      json: any
    ): MapMessage<Response.Headers> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Header.initialize();
        Header._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Examples: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<Response.Examples>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<Response.Examples>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<Response.Examples>,
      reader: BinaryReader
    ): MapMessage<Response.Examples> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<Response.Examples>,
      json: any
    ): MapMessage<Response.Examples> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  Extensions: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<Response.Extensions>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<Response.Extensions>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<Response.Extensions>,
      reader: BinaryReader
    ): MapMessage<Response.Extensions> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Value.initialize(), Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<Response.Extensions>,
      json: any
    ): MapMessage<Response.Extensions> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Value.initialize();
        Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const Info = {
  /**
   * Serializes a Info to protobuf.
   */
  encode: function (msg: Partial<Info>): Uint8Array {
    return Info._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Info from protobuf.
   */
  decode: function (bytes: ByteSource): Info {
    return Info._readMessage(Info.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Info to JSON.
   */
  encodeJSON: function (msg: Partial<Info>): string {
    return JSON.stringify(Info._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Info from JSON.
   */
  decodeJSON: function (json: string): Info {
    return Info._readMessageJSON(Info.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Info with all fields set to their default value.
   */
  initialize: function (): Info {
    return {
      title: "",
      description: "",
      termsOfService: "",
      contact: Contact.initialize(),
      license: License.initialize(),
      version: "",
      extensions: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Info>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.title) {
      writer.writeString(1, msg.title);
    }
    if (msg.description) {
      writer.writeString(2, msg.description);
    }
    if (msg.termsOfService) {
      writer.writeString(3, msg.termsOfService);
    }
    if (msg.contact) {
      writer.writeMessage(4, msg.contact, Contact._writeMessage);
    }
    if (msg.license) {
      writer.writeMessage(5, msg.license, License._writeMessage);
    }
    if (msg.version) {
      writer.writeString(6, msg.version);
    }
    if (msg.extensions) {
      writer.writeRepeatedMessage(
        7,
        Object.entries<any>(msg.extensions).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        Info.Extensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Info>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.title) {
      json.title = msg.title;
    }
    if (msg.description) {
      json.description = msg.description;
    }
    if (msg.termsOfService) {
      json.termsOfService = msg.termsOfService;
    }
    if (msg.contact) {
      const contact = Contact._writeMessageJSON(msg.contact);
      if (Object.keys(contact).length > 0) {
        json.contact = contact;
      }
    }
    if (msg.license) {
      const license = License._writeMessageJSON(msg.license);
      if (Object.keys(license).length > 0) {
        json.license = license;
      }
    }
    if (msg.version) {
      json.version = msg.version;
    }
    if (msg.extensions) {
      const extensions = Object.fromEntries(
        Object.entries<any>(msg.extensions)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Info.Extensions._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(extensions).length > 0) {
        json.extensions = extensions;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Info, reader: BinaryReader): Info {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.title = reader.readString();
          break;
        }
        case 2: {
          msg.description = reader.readString();
          break;
        }
        case 3: {
          msg.termsOfService = reader.readString();
          break;
        }
        case 4: {
          reader.readMessage(msg.contact, Contact._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(msg.license, License._readMessage);
          break;
        }
        case 6: {
          msg.version = reader.readString();
          break;
        }
        case 7: {
          const extensions = {} as MapMessage<Info.Extensions>;
          reader.readMessage(extensions, Info.Extensions._readMessage);
          msg.extensions[extensions.key] = extensions.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Info, json: any): Info {
    const _title = json.title;
    if (_title) {
      msg.title = _title;
    }
    const _description = json.description;
    if (_description) {
      msg.description = _description;
    }
    const _termsOfService = json.termsOfService ?? json.terms_of_service;
    if (_termsOfService) {
      msg.termsOfService = _termsOfService;
    }
    const _contact = json.contact;
    if (_contact) {
      const m = Contact.initialize();
      Contact._readMessageJSON(m, _contact);
      msg.contact = m;
    }
    const _license = json.license;
    if (_license) {
      const m = License.initialize();
      License._readMessageJSON(m, _license);
      msg.license = m;
    }
    const _version = json.version;
    if (_version) {
      msg.version = _version;
    }
    const _extensions = json.extensions;
    if (_extensions) {
      msg.extensions = Object.fromEntries(
        Object.entries<any>(_extensions)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Info.Extensions._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Extensions: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<Info.Extensions>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<Info.Extensions>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<Info.Extensions>,
      reader: BinaryReader
    ): MapMessage<Info.Extensions> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Value.initialize(), Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<Info.Extensions>,
      json: any
    ): MapMessage<Info.Extensions> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Value.initialize();
        Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const Contact = {
  /**
   * Serializes a Contact to protobuf.
   */
  encode: function (msg: Partial<Contact>): Uint8Array {
    return Contact._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Contact from protobuf.
   */
  decode: function (bytes: ByteSource): Contact {
    return Contact._readMessage(Contact.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Contact to JSON.
   */
  encodeJSON: function (msg: Partial<Contact>): string {
    return JSON.stringify(Contact._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Contact from JSON.
   */
  decodeJSON: function (json: string): Contact {
    return Contact._readMessageJSON(Contact.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Contact with all fields set to their default value.
   */
  initialize: function (): Contact {
    return {
      name: "",
      url: "",
      email: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Contact>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.url) {
      writer.writeString(2, msg.url);
    }
    if (msg.email) {
      writer.writeString(3, msg.email);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Contact>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.url) {
      json.url = msg.url;
    }
    if (msg.email) {
      json.email = msg.email;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Contact, reader: BinaryReader): Contact {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.url = reader.readString();
          break;
        }
        case 3: {
          msg.email = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Contact, json: any): Contact {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _url = json.url;
    if (_url) {
      msg.url = _url;
    }
    const _email = json.email;
    if (_email) {
      msg.email = _email;
    }
    return msg;
  },
};

export const License = {
  /**
   * Serializes a License to protobuf.
   */
  encode: function (msg: Partial<License>): Uint8Array {
    return License._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a License from protobuf.
   */
  decode: function (bytes: ByteSource): License {
    return License._readMessage(License.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a License to JSON.
   */
  encodeJSON: function (msg: Partial<License>): string {
    return JSON.stringify(License._writeMessageJSON(msg));
  },

  /**
   * Deserializes a License from JSON.
   */
  decodeJSON: function (json: string): License {
    return License._readMessageJSON(License.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a License with all fields set to their default value.
   */
  initialize: function (): License {
    return {
      name: "",
      url: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<License>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.url) {
      writer.writeString(2, msg.url);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<License>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.url) {
      json.url = msg.url;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: License, reader: BinaryReader): License {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.url = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: License, json: any): License {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _url = json.url;
    if (_url) {
      msg.url = _url;
    }
    return msg;
  },
};

export const ExternalDocumentation = {
  /**
   * Serializes a ExternalDocumentation to protobuf.
   */
  encode: function (msg: Partial<ExternalDocumentation>): Uint8Array {
    return ExternalDocumentation._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ExternalDocumentation from protobuf.
   */
  decode: function (bytes: ByteSource): ExternalDocumentation {
    return ExternalDocumentation._readMessage(
      ExternalDocumentation.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ExternalDocumentation to JSON.
   */
  encodeJSON: function (msg: Partial<ExternalDocumentation>): string {
    return JSON.stringify(ExternalDocumentation._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ExternalDocumentation from JSON.
   */
  decodeJSON: function (json: string): ExternalDocumentation {
    return ExternalDocumentation._readMessageJSON(
      ExternalDocumentation.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ExternalDocumentation with all fields set to their default value.
   */
  initialize: function (): ExternalDocumentation {
    return {
      description: "",
      url: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ExternalDocumentation>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.description) {
      writer.writeString(1, msg.description);
    }
    if (msg.url) {
      writer.writeString(2, msg.url);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ExternalDocumentation>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.description) {
      json.description = msg.description;
    }
    if (msg.url) {
      json.url = msg.url;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ExternalDocumentation,
    reader: BinaryReader
  ): ExternalDocumentation {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.description = reader.readString();
          break;
        }
        case 2: {
          msg.url = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: ExternalDocumentation,
    json: any
  ): ExternalDocumentation {
    const _description = json.description;
    if (_description) {
      msg.description = _description;
    }
    const _url = json.url;
    if (_url) {
      msg.url = _url;
    }
    return msg;
  },
};

export const Schema = {
  /**
   * Serializes a Schema to protobuf.
   */
  encode: function (msg: Partial<Schema>): Uint8Array {
    return Schema._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Schema from protobuf.
   */
  decode: function (bytes: ByteSource): Schema {
    return Schema._readMessage(Schema.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Schema to JSON.
   */
  encodeJSON: function (msg: Partial<Schema>): string {
    return JSON.stringify(Schema._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Schema from JSON.
   */
  decodeJSON: function (json: string): Schema {
    return Schema._readMessageJSON(Schema.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Schema with all fields set to their default value.
   */
  initialize: function (): Schema {
    return {
      jsonSchema: JSONSchema.initialize(),
      discriminator: "",
      readOnly: false,
      externalDocs: ExternalDocumentation.initialize(),
      example: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Schema>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.jsonSchema) {
      writer.writeMessage(1, msg.jsonSchema, JSONSchema._writeMessage);
    }
    if (msg.discriminator) {
      writer.writeString(2, msg.discriminator);
    }
    if (msg.readOnly) {
      writer.writeBool(3, msg.readOnly);
    }
    if (msg.externalDocs) {
      writer.writeMessage(
        5,
        msg.externalDocs,
        ExternalDocumentation._writeMessage
      );
    }
    if (msg.example) {
      writer.writeString(6, msg.example);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Schema>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.jsonSchema) {
      const jsonSchema = JSONSchema._writeMessageJSON(msg.jsonSchema);
      if (Object.keys(jsonSchema).length > 0) {
        json.jsonSchema = jsonSchema;
      }
    }
    if (msg.discriminator) {
      json.discriminator = msg.discriminator;
    }
    if (msg.readOnly) {
      json.readOnly = msg.readOnly;
    }
    if (msg.externalDocs) {
      const externalDocs = ExternalDocumentation._writeMessageJSON(
        msg.externalDocs
      );
      if (Object.keys(externalDocs).length > 0) {
        json.externalDocs = externalDocs;
      }
    }
    if (msg.example) {
      json.example = msg.example;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Schema, reader: BinaryReader): Schema {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.jsonSchema, JSONSchema._readMessage);
          break;
        }
        case 2: {
          msg.discriminator = reader.readString();
          break;
        }
        case 3: {
          msg.readOnly = reader.readBool();
          break;
        }
        case 5: {
          reader.readMessage(
            msg.externalDocs,
            ExternalDocumentation._readMessage
          );
          break;
        }
        case 6: {
          msg.example = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Schema, json: any): Schema {
    const _jsonSchema = json.jsonSchema ?? json.json_schema;
    if (_jsonSchema) {
      const m = JSONSchema.initialize();
      JSONSchema._readMessageJSON(m, _jsonSchema);
      msg.jsonSchema = m;
    }
    const _discriminator = json.discriminator;
    if (_discriminator) {
      msg.discriminator = _discriminator;
    }
    const _readOnly = json.readOnly ?? json.read_only;
    if (_readOnly) {
      msg.readOnly = _readOnly;
    }
    const _externalDocs = json.externalDocs ?? json.external_docs;
    if (_externalDocs) {
      const m = ExternalDocumentation.initialize();
      ExternalDocumentation._readMessageJSON(m, _externalDocs);
      msg.externalDocs = m;
    }
    const _example = json.example;
    if (_example) {
      msg.example = _example;
    }
    return msg;
  },
};

export const JSONSchema = {
  /**
   * Serializes a JSONSchema to protobuf.
   */
  encode: function (msg: Partial<JSONSchema>): Uint8Array {
    return JSONSchema._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a JSONSchema from protobuf.
   */
  decode: function (bytes: ByteSource): JSONSchema {
    return JSONSchema._readMessage(
      JSONSchema.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a JSONSchema to JSON.
   */
  encodeJSON: function (msg: Partial<JSONSchema>): string {
    return JSON.stringify(JSONSchema._writeMessageJSON(msg));
  },

  /**
   * Deserializes a JSONSchema from JSON.
   */
  decodeJSON: function (json: string): JSONSchema {
    return JSONSchema._readMessageJSON(
      JSONSchema.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a JSONSchema with all fields set to their default value.
   */
  initialize: function (): JSONSchema {
    return {
      ref: "",
      title: "",
      description: "",
      default: "",
      readOnly: false,
      example: "",
      multipleOf: 0,
      maximum: 0,
      exclusiveMaximum: false,
      minimum: 0,
      exclusiveMinimum: false,
      maxLength: 0n,
      minLength: 0n,
      pattern: "",
      maxItems: 0n,
      minItems: 0n,
      uniqueItems: false,
      maxProperties: 0n,
      minProperties: 0n,
      required: [],
      array: [],
      type: [],
      format: "",
      enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<JSONSchema>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.ref) {
      writer.writeString(3, msg.ref);
    }
    if (msg.title) {
      writer.writeString(5, msg.title);
    }
    if (msg.description) {
      writer.writeString(6, msg.description);
    }
    if (msg.default) {
      writer.writeString(7, msg.default);
    }
    if (msg.readOnly) {
      writer.writeBool(8, msg.readOnly);
    }
    if (msg.example) {
      writer.writeString(9, msg.example);
    }
    if (msg.multipleOf) {
      writer.writeDouble(10, msg.multipleOf);
    }
    if (msg.maximum) {
      writer.writeDouble(11, msg.maximum);
    }
    if (msg.exclusiveMaximum) {
      writer.writeBool(12, msg.exclusiveMaximum);
    }
    if (msg.minimum) {
      writer.writeDouble(13, msg.minimum);
    }
    if (msg.exclusiveMinimum) {
      writer.writeBool(14, msg.exclusiveMinimum);
    }
    if (msg.maxLength) {
      writer.writeUint64String(15, msg.maxLength.toString());
    }
    if (msg.minLength) {
      writer.writeUint64String(16, msg.minLength.toString());
    }
    if (msg.pattern) {
      writer.writeString(17, msg.pattern);
    }
    if (msg.maxItems) {
      writer.writeUint64String(20, msg.maxItems.toString());
    }
    if (msg.minItems) {
      writer.writeUint64String(21, msg.minItems.toString());
    }
    if (msg.uniqueItems) {
      writer.writeBool(22, msg.uniqueItems);
    }
    if (msg.maxProperties) {
      writer.writeUint64String(24, msg.maxProperties.toString());
    }
    if (msg.minProperties) {
      writer.writeUint64String(25, msg.minProperties.toString());
    }
    if (msg.required?.length) {
      writer.writeRepeatedString(26, msg.required);
    }
    if (msg.array?.length) {
      writer.writeRepeatedString(34, msg.array);
    }
    if (msg.type?.length) {
      writer.writeRepeatedEnum(
        35,
        msg.type.map(JSONSchema.JSONSchemaSimpleTypesToInt)
      );
    }
    if (msg.format) {
      writer.writeString(36, msg.format);
    }
    if (msg.enum?.length) {
      writer.writeRepeatedString(46, msg.enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<JSONSchema>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.ref) {
      json.ref = msg.ref;
    }
    if (msg.title) {
      json.title = msg.title;
    }
    if (msg.description) {
      json.description = msg.description;
    }
    if (msg.default) {
      json.default = msg.default;
    }
    if (msg.readOnly) {
      json.readOnly = msg.readOnly;
    }
    if (msg.example) {
      json.example = msg.example;
    }
    if (msg.multipleOf) {
      json.multipleOf = msg.multipleOf;
    }
    if (msg.maximum) {
      json.maximum = msg.maximum;
    }
    if (msg.exclusiveMaximum) {
      json.exclusiveMaximum = msg.exclusiveMaximum;
    }
    if (msg.minimum) {
      json.minimum = msg.minimum;
    }
    if (msg.exclusiveMinimum) {
      json.exclusiveMinimum = msg.exclusiveMinimum;
    }
    if (msg.maxLength) {
      json.maxLength = msg.maxLength.toString();
    }
    if (msg.minLength) {
      json.minLength = msg.minLength.toString();
    }
    if (msg.pattern) {
      json.pattern = msg.pattern;
    }
    if (msg.maxItems) {
      json.maxItems = msg.maxItems.toString();
    }
    if (msg.minItems) {
      json.minItems = msg.minItems.toString();
    }
    if (msg.uniqueItems) {
      json.uniqueItems = msg.uniqueItems;
    }
    if (msg.maxProperties) {
      json.maxProperties = msg.maxProperties.toString();
    }
    if (msg.minProperties) {
      json.minProperties = msg.minProperties.toString();
    }
    if (msg.required?.length) {
      json.required = msg.required;
    }
    if (msg.array?.length) {
      json.array = msg.array;
    }
    if (msg.type?.length) {
      json.type = msg.type;
    }
    if (msg.format) {
      json.format = msg.format;
    }
    if (msg.enum?.length) {
      json.enum = msg.enum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: JSONSchema, reader: BinaryReader): JSONSchema {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 3: {
          msg.ref = reader.readString();
          break;
        }
        case 5: {
          msg.title = reader.readString();
          break;
        }
        case 6: {
          msg.description = reader.readString();
          break;
        }
        case 7: {
          msg.default = reader.readString();
          break;
        }
        case 8: {
          msg.readOnly = reader.readBool();
          break;
        }
        case 9: {
          msg.example = reader.readString();
          break;
        }
        case 10: {
          msg.multipleOf = reader.readDouble();
          break;
        }
        case 11: {
          msg.maximum = reader.readDouble();
          break;
        }
        case 12: {
          msg.exclusiveMaximum = reader.readBool();
          break;
        }
        case 13: {
          msg.minimum = reader.readDouble();
          break;
        }
        case 14: {
          msg.exclusiveMinimum = reader.readBool();
          break;
        }
        case 15: {
          msg.maxLength = BigInt(reader.readUint64String());
          break;
        }
        case 16: {
          msg.minLength = BigInt(reader.readUint64String());
          break;
        }
        case 17: {
          msg.pattern = reader.readString();
          break;
        }
        case 20: {
          msg.maxItems = BigInt(reader.readUint64String());
          break;
        }
        case 21: {
          msg.minItems = BigInt(reader.readUint64String());
          break;
        }
        case 22: {
          msg.uniqueItems = reader.readBool();
          break;
        }
        case 24: {
          msg.maxProperties = BigInt(reader.readUint64String());
          break;
        }
        case 25: {
          msg.minProperties = BigInt(reader.readUint64String());
          break;
        }
        case 26: {
          msg.required.push(reader.readString());
          break;
        }
        case 34: {
          msg.array.push(reader.readString());
          break;
        }
        case 35: {
          msg.type.push(
            JSONSchema.JSONSchemaSimpleTypesFromInt(reader.readEnum())
          );
          break;
        }
        case 36: {
          msg.format = reader.readString();
          break;
        }
        case 46: {
          msg.enum.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: JSONSchema, json: any): JSONSchema {
    const _ref = json.ref;
    if (_ref) {
      msg.ref = _ref;
    }
    const _title = json.title;
    if (_title) {
      msg.title = _title;
    }
    const _description = json.description;
    if (_description) {
      msg.description = _description;
    }
    const _default = json.default;
    if (_default) {
      msg.default = _default;
    }
    const _readOnly = json.readOnly ?? json.read_only;
    if (_readOnly) {
      msg.readOnly = _readOnly;
    }
    const _example = json.example;
    if (_example) {
      msg.example = _example;
    }
    const _multipleOf = json.multipleOf ?? json.multiple_of;
    if (_multipleOf) {
      msg.multipleOf = _multipleOf;
    }
    const _maximum = json.maximum;
    if (_maximum) {
      msg.maximum = _maximum;
    }
    const _exclusiveMaximum = json.exclusiveMaximum ?? json.exclusive_maximum;
    if (_exclusiveMaximum) {
      msg.exclusiveMaximum = _exclusiveMaximum;
    }
    const _minimum = json.minimum;
    if (_minimum) {
      msg.minimum = _minimum;
    }
    const _exclusiveMinimum = json.exclusiveMinimum ?? json.exclusive_minimum;
    if (_exclusiveMinimum) {
      msg.exclusiveMinimum = _exclusiveMinimum;
    }
    const _maxLength = json.maxLength ?? json.max_length;
    if (_maxLength) {
      msg.maxLength = BigInt(_maxLength);
    }
    const _minLength = json.minLength ?? json.min_length;
    if (_minLength) {
      msg.minLength = BigInt(_minLength);
    }
    const _pattern = json.pattern;
    if (_pattern) {
      msg.pattern = _pattern;
    }
    const _maxItems = json.maxItems ?? json.max_items;
    if (_maxItems) {
      msg.maxItems = BigInt(_maxItems);
    }
    const _minItems = json.minItems ?? json.min_items;
    if (_minItems) {
      msg.minItems = BigInt(_minItems);
    }
    const _uniqueItems = json.uniqueItems ?? json.unique_items;
    if (_uniqueItems) {
      msg.uniqueItems = _uniqueItems;
    }
    const _maxProperties = json.maxProperties ?? json.max_properties;
    if (_maxProperties) {
      msg.maxProperties = BigInt(_maxProperties);
    }
    const _minProperties = json.minProperties ?? json.min_properties;
    if (_minProperties) {
      msg.minProperties = BigInt(_minProperties);
    }
    const _required = json.required;
    if (_required) {
      msg.required = _required;
    }
    const _array = json.array;
    if (_array) {
      msg.array = _array;
    }
    const _type = json.type;
    if (_type) {
      msg.type = _type;
    }
    const _format = json.format;
    if (_format) {
      msg.format = _format;
    }
    const _enum = json.enum;
    if (_enum) {
      msg.enum = _enum;
    }
    return msg;
  },

  JSONSchemaSimpleTypes: {
    UNKNOWN: "UNKNOWN",
    ARRAY: "ARRAY",
    BOOLEAN: "BOOLEAN",
    INTEGER: "INTEGER",
    NULL: "NULL",
    NUMBER: "NUMBER",
    OBJECT: "OBJECT",
    STRING: "STRING",
  } as const,

  JSONSchemaSimpleTypesFromInt: function (
    i: number
  ): JSONSchema.JSONSchemaSimpleTypes {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "ARRAY";
      }
      case 2: {
        return "BOOLEAN";
      }
      case 3: {
        return "INTEGER";
      }
      case 4: {
        return "NULL";
      }
      case 5: {
        return "NUMBER";
      }
      case 6: {
        return "OBJECT";
      }
      case 7: {
        return "STRING";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as JSONSchema.JSONSchemaSimpleTypes;
      }
    }
  },

  JSONSchemaSimpleTypesToInt: function (
    i: JSONSchema.JSONSchemaSimpleTypes
  ): number {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "ARRAY": {
        return 1;
      }
      case "BOOLEAN": {
        return 2;
      }
      case "INTEGER": {
        return 3;
      }
      case "NULL": {
        return 4;
      }
      case "NUMBER": {
        return 5;
      }
      case "OBJECT": {
        return 6;
      }
      case "STRING": {
        return 7;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
};

export const Tag = {
  /**
   * Serializes a Tag to protobuf.
   */
  encode: function (msg: Partial<Tag>): Uint8Array {
    return Tag._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Tag from protobuf.
   */
  decode: function (bytes: ByteSource): Tag {
    return Tag._readMessage(Tag.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Tag to JSON.
   */
  encodeJSON: function (msg: Partial<Tag>): string {
    return JSON.stringify(Tag._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Tag from JSON.
   */
  decodeJSON: function (json: string): Tag {
    return Tag._readMessageJSON(Tag.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Tag with all fields set to their default value.
   */
  initialize: function (): Tag {
    return {
      description: "",
      externalDocs: ExternalDocumentation.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Tag>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.description) {
      writer.writeString(2, msg.description);
    }
    if (msg.externalDocs) {
      writer.writeMessage(
        3,
        msg.externalDocs,
        ExternalDocumentation._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Tag>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.description) {
      json.description = msg.description;
    }
    if (msg.externalDocs) {
      const externalDocs = ExternalDocumentation._writeMessageJSON(
        msg.externalDocs
      );
      if (Object.keys(externalDocs).length > 0) {
        json.externalDocs = externalDocs;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Tag, reader: BinaryReader): Tag {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2: {
          msg.description = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.externalDocs,
            ExternalDocumentation._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Tag, json: any): Tag {
    const _description = json.description;
    if (_description) {
      msg.description = _description;
    }
    const _externalDocs = json.externalDocs ?? json.external_docs;
    if (_externalDocs) {
      const m = ExternalDocumentation.initialize();
      ExternalDocumentation._readMessageJSON(m, _externalDocs);
      msg.externalDocs = m;
    }
    return msg;
  },
};

export const SecurityDefinitions = {
  /**
   * Serializes a SecurityDefinitions to protobuf.
   */
  encode: function (msg: Partial<SecurityDefinitions>): Uint8Array {
    return SecurityDefinitions._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SecurityDefinitions from protobuf.
   */
  decode: function (bytes: ByteSource): SecurityDefinitions {
    return SecurityDefinitions._readMessage(
      SecurityDefinitions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SecurityDefinitions to JSON.
   */
  encodeJSON: function (msg: Partial<SecurityDefinitions>): string {
    return JSON.stringify(SecurityDefinitions._writeMessageJSON(msg));
  },

  /**
   * Deserializes a SecurityDefinitions from JSON.
   */
  decodeJSON: function (json: string): SecurityDefinitions {
    return SecurityDefinitions._readMessageJSON(
      SecurityDefinitions.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SecurityDefinitions with all fields set to their default value.
   */
  initialize: function (): SecurityDefinitions {
    return {
      security: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SecurityDefinitions>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.security) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.security).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        SecurityDefinitions.Security._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<SecurityDefinitions>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.security) {
      const security = Object.fromEntries(
        Object.entries<any>(msg.security)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(SecurityDefinitions.Security._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(security).length > 0) {
        json.security = security;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SecurityDefinitions,
    reader: BinaryReader
  ): SecurityDefinitions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const security = {} as MapMessage<SecurityDefinitions.Security>;
          reader.readMessage(
            security,
            SecurityDefinitions.Security._readMessage
          );
          msg.security[security.key] = security.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: SecurityDefinitions,
    json: any
  ): SecurityDefinitions {
    const _security = json.security;
    if (_security) {
      msg.security = Object.fromEntries(
        Object.entries<any>(_security)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(SecurityDefinitions.Security._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Security: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<SecurityDefinitions.Security>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, SecurityScheme._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<SecurityDefinitions.Security>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = SecurityScheme._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<SecurityDefinitions.Security>,
      reader: BinaryReader
    ): MapMessage<SecurityDefinitions.Security> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              SecurityScheme.initialize(),
              SecurityScheme._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<SecurityDefinitions.Security>,
      json: any
    ): MapMessage<SecurityDefinitions.Security> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = SecurityScheme.initialize();
        SecurityScheme._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const SecurityScheme = {
  /**
   * Serializes a SecurityScheme to protobuf.
   */
  encode: function (msg: Partial<SecurityScheme>): Uint8Array {
    return SecurityScheme._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SecurityScheme from protobuf.
   */
  decode: function (bytes: ByteSource): SecurityScheme {
    return SecurityScheme._readMessage(
      SecurityScheme.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SecurityScheme to JSON.
   */
  encodeJSON: function (msg: Partial<SecurityScheme>): string {
    return JSON.stringify(SecurityScheme._writeMessageJSON(msg));
  },

  /**
   * Deserializes a SecurityScheme from JSON.
   */
  decodeJSON: function (json: string): SecurityScheme {
    return SecurityScheme._readMessageJSON(
      SecurityScheme.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SecurityScheme with all fields set to their default value.
   */
  initialize: function (): SecurityScheme {
    return {
      type: SecurityScheme.TypeFromInt(0),
      description: "",
      name: "",
      in: SecurityScheme.InFromInt(0),
      flow: SecurityScheme.FlowFromInt(0),
      authorizationUrl: "",
      tokenUrl: "",
      scopes: Scopes.initialize(),
      extensions: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SecurityScheme>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.type && SecurityScheme.TypeToInt(msg.type)) {
      writer.writeEnum(1, SecurityScheme.TypeToInt(msg.type));
    }
    if (msg.description) {
      writer.writeString(2, msg.description);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    if (msg.in && SecurityScheme.InToInt(msg.in)) {
      writer.writeEnum(4, SecurityScheme.InToInt(msg.in));
    }
    if (msg.flow && SecurityScheme.FlowToInt(msg.flow)) {
      writer.writeEnum(5, SecurityScheme.FlowToInt(msg.flow));
    }
    if (msg.authorizationUrl) {
      writer.writeString(6, msg.authorizationUrl);
    }
    if (msg.tokenUrl) {
      writer.writeString(7, msg.tokenUrl);
    }
    if (msg.scopes) {
      writer.writeMessage(8, msg.scopes, Scopes._writeMessage);
    }
    if (msg.extensions) {
      writer.writeRepeatedMessage(
        9,
        Object.entries<any>(msg.extensions).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        SecurityScheme.Extensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<SecurityScheme>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.type && SecurityScheme.TypeToInt(msg.type)) {
      json.type = msg.type;
    }
    if (msg.description) {
      json.description = msg.description;
    }
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.in && SecurityScheme.InToInt(msg.in)) {
      json.in = msg.in;
    }
    if (msg.flow && SecurityScheme.FlowToInt(msg.flow)) {
      json.flow = msg.flow;
    }
    if (msg.authorizationUrl) {
      json.authorizationUrl = msg.authorizationUrl;
    }
    if (msg.tokenUrl) {
      json.tokenUrl = msg.tokenUrl;
    }
    if (msg.scopes) {
      const scopes = Scopes._writeMessageJSON(msg.scopes);
      if (Object.keys(scopes).length > 0) {
        json.scopes = scopes;
      }
    }
    if (msg.extensions) {
      const extensions = Object.fromEntries(
        Object.entries<any>(msg.extensions)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(SecurityScheme.Extensions._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(extensions).length > 0) {
        json.extensions = extensions;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SecurityScheme,
    reader: BinaryReader
  ): SecurityScheme {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.type = SecurityScheme.TypeFromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.description = reader.readString();
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        case 4: {
          msg.in = SecurityScheme.InFromInt(reader.readEnum());
          break;
        }
        case 5: {
          msg.flow = SecurityScheme.FlowFromInt(reader.readEnum());
          break;
        }
        case 6: {
          msg.authorizationUrl = reader.readString();
          break;
        }
        case 7: {
          msg.tokenUrl = reader.readString();
          break;
        }
        case 8: {
          reader.readMessage(msg.scopes, Scopes._readMessage);
          break;
        }
        case 9: {
          const extensions = {} as MapMessage<SecurityScheme.Extensions>;
          reader.readMessage(
            extensions,
            SecurityScheme.Extensions._readMessage
          );
          msg.extensions[extensions.key] = extensions.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: SecurityScheme, json: any): SecurityScheme {
    const _type = json.type;
    if (_type) {
      msg.type = _type;
    }
    const _description = json.description;
    if (_description) {
      msg.description = _description;
    }
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _in = json.in;
    if (_in) {
      msg.in = _in;
    }
    const _flow = json.flow;
    if (_flow) {
      msg.flow = _flow;
    }
    const _authorizationUrl = json.authorizationUrl ?? json.authorization_url;
    if (_authorizationUrl) {
      msg.authorizationUrl = _authorizationUrl;
    }
    const _tokenUrl = json.tokenUrl ?? json.token_url;
    if (_tokenUrl) {
      msg.tokenUrl = _tokenUrl;
    }
    const _scopes = json.scopes;
    if (_scopes) {
      const m = Scopes.initialize();
      Scopes._readMessageJSON(m, _scopes);
      msg.scopes = m;
    }
    const _extensions = json.extensions;
    if (_extensions) {
      msg.extensions = Object.fromEntries(
        Object.entries<any>(_extensions)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(SecurityScheme.Extensions._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Type: {
    TYPE_INVALID: "TYPE_INVALID",
    TYPE_BASIC: "TYPE_BASIC",
    TYPE_API_KEY: "TYPE_API_KEY",
    TYPE_OAUTH2: "TYPE_OAUTH2",
  } as const,

  TypeFromInt: function (i: number): SecurityScheme.Type {
    switch (i) {
      case 0: {
        return "TYPE_INVALID";
      }
      case 1: {
        return "TYPE_BASIC";
      }
      case 2: {
        return "TYPE_API_KEY";
      }
      case 3: {
        return "TYPE_OAUTH2";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as SecurityScheme.Type;
      }
    }
  },

  TypeToInt: function (i: SecurityScheme.Type): number {
    switch (i) {
      case "TYPE_INVALID": {
        return 0;
      }
      case "TYPE_BASIC": {
        return 1;
      }
      case "TYPE_API_KEY": {
        return 2;
      }
      case "TYPE_OAUTH2": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  In: {
    IN_INVALID: "IN_INVALID",
    IN_QUERY: "IN_QUERY",
    IN_HEADER: "IN_HEADER",
  } as const,

  InFromInt: function (i: number): SecurityScheme.In {
    switch (i) {
      case 0: {
        return "IN_INVALID";
      }
      case 1: {
        return "IN_QUERY";
      }
      case 2: {
        return "IN_HEADER";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as SecurityScheme.In;
      }
    }
  },

  InToInt: function (i: SecurityScheme.In): number {
    switch (i) {
      case "IN_INVALID": {
        return 0;
      }
      case "IN_QUERY": {
        return 1;
      }
      case "IN_HEADER": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  Flow: {
    FLOW_INVALID: "FLOW_INVALID",
    FLOW_IMPLICIT: "FLOW_IMPLICIT",
    FLOW_PASSWORD: "FLOW_PASSWORD",
    FLOW_APPLICATION: "FLOW_APPLICATION",
    FLOW_ACCESS_CODE: "FLOW_ACCESS_CODE",
  } as const,

  FlowFromInt: function (i: number): SecurityScheme.Flow {
    switch (i) {
      case 0: {
        return "FLOW_INVALID";
      }
      case 1: {
        return "FLOW_IMPLICIT";
      }
      case 2: {
        return "FLOW_PASSWORD";
      }
      case 3: {
        return "FLOW_APPLICATION";
      }
      case 4: {
        return "FLOW_ACCESS_CODE";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as SecurityScheme.Flow;
      }
    }
  },

  FlowToInt: function (i: SecurityScheme.Flow): number {
    switch (i) {
      case "FLOW_INVALID": {
        return 0;
      }
      case "FLOW_IMPLICIT": {
        return 1;
      }
      case "FLOW_PASSWORD": {
        return 2;
      }
      case "FLOW_APPLICATION": {
        return 3;
      }
      case "FLOW_ACCESS_CODE": {
        return 4;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  Extensions: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<SecurityScheme.Extensions>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<SecurityScheme.Extensions>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<SecurityScheme.Extensions>,
      reader: BinaryReader
    ): MapMessage<SecurityScheme.Extensions> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Value.initialize(), Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<SecurityScheme.Extensions>,
      json: any
    ): MapMessage<SecurityScheme.Extensions> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Value.initialize();
        Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const SecurityRequirement = {
  /**
   * Serializes a SecurityRequirement to protobuf.
   */
  encode: function (msg: Partial<SecurityRequirement>): Uint8Array {
    return SecurityRequirement._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SecurityRequirement from protobuf.
   */
  decode: function (bytes: ByteSource): SecurityRequirement {
    return SecurityRequirement._readMessage(
      SecurityRequirement.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SecurityRequirement to JSON.
   */
  encodeJSON: function (msg: Partial<SecurityRequirement>): string {
    return JSON.stringify(SecurityRequirement._writeMessageJSON(msg));
  },

  /**
   * Deserializes a SecurityRequirement from JSON.
   */
  decodeJSON: function (json: string): SecurityRequirement {
    return SecurityRequirement._readMessageJSON(
      SecurityRequirement.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SecurityRequirement with all fields set to their default value.
   */
  initialize: function (): SecurityRequirement {
    return {
      securityRequirement: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SecurityRequirement>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.securityRequirement) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.securityRequirement).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        SecurityRequirement.SecurityRequirement._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<SecurityRequirement>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.securityRequirement) {
      const securityRequirement = Object.fromEntries(
        Object.entries<any>(msg.securityRequirement)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(SecurityRequirement.SecurityRequirement._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(securityRequirement).length > 0) {
        json.securityRequirement = securityRequirement;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SecurityRequirement,
    reader: BinaryReader
  ): SecurityRequirement {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const securityRequirement =
            {} as MapMessage<SecurityRequirement.SecurityRequirement>;
          reader.readMessage(
            securityRequirement,
            SecurityRequirement.SecurityRequirement._readMessage
          );
          msg.securityRequirement[securityRequirement.key] =
            securityRequirement.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: SecurityRequirement,
    json: any
  ): SecurityRequirement {
    const _securityRequirement =
      json.securityRequirement ?? json.security_requirement;
    if (_securityRequirement) {
      msg.securityRequirement = Object.fromEntries(
        Object.entries<any>(_securityRequirement)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(SecurityRequirement.SecurityRequirement._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  SecurityRequirementValue: {
    /**
     * Serializes a SecurityRequirement.SecurityRequirementValue to protobuf.
     */
    encode: function (
      msg: Partial<SecurityRequirement.SecurityRequirementValue>
    ): Uint8Array {
      return SecurityRequirement.SecurityRequirementValue._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a SecurityRequirement.SecurityRequirementValue from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): SecurityRequirement.SecurityRequirementValue {
      return SecurityRequirement.SecurityRequirementValue._readMessage(
        SecurityRequirement.SecurityRequirementValue.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a SecurityRequirement.SecurityRequirementValue to JSON.
     */
    encodeJSON: function (
      msg: Partial<SecurityRequirement.SecurityRequirementValue>
    ): string {
      return JSON.stringify(
        SecurityRequirement.SecurityRequirementValue._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a SecurityRequirement.SecurityRequirementValue from JSON.
     */
    decodeJSON: function (
      json: string
    ): SecurityRequirement.SecurityRequirementValue {
      return SecurityRequirement.SecurityRequirementValue._readMessageJSON(
        SecurityRequirement.SecurityRequirementValue.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a SecurityRequirement.SecurityRequirementValue with all fields set to their default value.
     */
    initialize: function (): SecurityRequirement.SecurityRequirementValue {
      return {
        scope: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<SecurityRequirement.SecurityRequirementValue>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.scope?.length) {
        writer.writeRepeatedString(1, msg.scope);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<SecurityRequirement.SecurityRequirementValue>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.scope?.length) {
        json.scope = msg.scope;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: SecurityRequirement.SecurityRequirementValue,
      reader: BinaryReader
    ): SecurityRequirement.SecurityRequirementValue {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.scope.push(reader.readString());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: SecurityRequirement.SecurityRequirementValue,
      json: any
    ): SecurityRequirement.SecurityRequirementValue {
      const _scope = json.scope;
      if (_scope) {
        msg.scope = _scope;
      }
      return msg;
    },
  },

  SecurityRequirement: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<SecurityRequirement.SecurityRequirement>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          SecurityRequirement.SecurityRequirementValue._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<SecurityRequirement.SecurityRequirement>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value =
          SecurityRequirement.SecurityRequirementValue._writeMessageJSON(
            msg.value
          );
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<SecurityRequirement.SecurityRequirement>,
      reader: BinaryReader
    ): MapMessage<SecurityRequirement.SecurityRequirement> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              SecurityRequirement.SecurityRequirementValue.initialize(),
              SecurityRequirement.SecurityRequirementValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<SecurityRequirement.SecurityRequirement>,
      json: any
    ): MapMessage<SecurityRequirement.SecurityRequirement> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = SecurityRequirement.SecurityRequirementValue.initialize();
        SecurityRequirement.SecurityRequirementValue._readMessageJSON(
          m,
          _value
        );
        msg.value = m;
      }
      return msg;
    },
  },
};

export const Scopes = {
  /**
   * Serializes a Scopes to protobuf.
   */
  encode: function (msg: Partial<Scopes>): Uint8Array {
    return Scopes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Scopes from protobuf.
   */
  decode: function (bytes: ByteSource): Scopes {
    return Scopes._readMessage(Scopes.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Scopes to JSON.
   */
  encodeJSON: function (msg: Partial<Scopes>): string {
    return JSON.stringify(Scopes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Scopes from JSON.
   */
  decodeJSON: function (json: string): Scopes {
    return Scopes._readMessageJSON(Scopes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Scopes with all fields set to their default value.
   */
  initialize: function (): Scopes {
    return {
      scope: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Scopes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.scope) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.scope).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        Scopes.Scope._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Scopes>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.scope) {
      const scope = Object.fromEntries(
        Object.entries<any>(msg.scope)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Scopes.Scope._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(scope).length > 0) {
        json.scope = scope;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Scopes, reader: BinaryReader): Scopes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const scope = {} as MapMessage<Scopes.Scope>;
          reader.readMessage(scope, Scopes.Scope._readMessage);
          msg.scope[scope.key] = scope.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Scopes, json: any): Scopes {
    const _scope = json.scope;
    if (_scope) {
      msg.scope = Object.fromEntries(
        Object.entries<any>(_scope)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Scopes.Scope._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Scope: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<Scopes.Scope>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<Scopes.Scope>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<Scopes.Scope>,
      reader: BinaryReader
    ): MapMessage<Scopes.Scope> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<Scopes.Scope>,
      json: any
    ): MapMessage<Scopes.Scope> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};
