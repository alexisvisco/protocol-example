// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: protoc-gen-openapiv2/options/openapiv2.proto


import type {
    ByteSource,

    } from 'twirpscript';
import {
  BinaryReader,
BinaryWriter,

  } from 'twirpscript';
  

import { Value } from '../../google/protobuf/struct.pb';





  //========================================//
  //                 Types                  //
  //========================================//
  
  
    /**
     * Scheme describes the schemes supported by the OpenAPI Swagger
 * and Operation objects.
     */
      export type Scheme = typeof Scheme[keyof typeof Scheme];

    /**
     * `Swagger` is a representation of OpenAPI v2 specification's Swagger object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#swaggerObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      title: "Echo API";
 *      version: "1.0";
 *      description: ";
 *      contact: {
 *        name: "gRPC-Gateway project";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *        email: "none@example.com";
 *      };
 *      license: {
 *        name: "BSD 3-Clause License";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt";
 *      };
 *    };
 *    schemes: HTTPS;
 *    consumes: "application/json";
 *    produces: "application/json";
 *  };
 *
     */
      export interface Swagger {
    /**
     * Specifies the OpenAPI Specification version being used. It can be
 * used by the OpenAPI UI and other clients to interpret the API listing. The 
 * value MUST be "2.0".
     */
      swagger: string;
    /**
     * Provides metadata about the API. The metadata can be used by the 
 * clients if needed.
     */
      info: Info;
    /**
     * The host (name or ip) serving the API. This MUST be the host only and does 
 * not include the scheme nor sub-paths. It MAY include a port. If the host is
 * not included, the host serving the documentation is to be used (including
 * the port). The host does not support path templating.
     */
      host: string;
    /**
     * The base path on which the API is served, which is relative to the host. If
 * it is not included, the API is served directly under the host. The value 
 * MUST start with a leading slash (/). The basePath does not support path
 * templating.
 * Note that using `base_path` does not change the endpoint paths that are 
 * generated in the resulting OpenAPI file. If you wish to use `base_path`
 * with relatively generated OpenAPI paths, the `base_path` prefix must be 
 * manually removed from your `google.api.http` paths and your code changed to 
 * serve the API from the `base_path`.
     */
      basePath: string;
    /**
     * The transfer protocol of the API. Values MUST be from the list: "http",
 * "https", "ws", "wss". If the schemes is not included, the default scheme to
 * be used is the one used to access the OpenAPI definition itself.
     */
      schemes: Scheme[];
    /**
     * A list of MIME types the APIs can consume. This is global to all APIs but 
 * can be overridden on specific API calls. Value MUST be as described under
 * Mime Types.
     */
      consumes: string[];
    /**
     * A list of MIME types the APIs can produce. This is global to all APIs but
 * can be overridden on specific API calls. Value MUST be as described under
 * Mime Types.
     */
      produces: string[];
    /**
     * An object to hold responses that can be used across operations. This
 * property does not define global responses for all operations.
     */
      responses: Record<
              string,
              Response | undefined>;
    /**
     * Security scheme definitions that can be used across the specification.
     */
      securityDefinitions: SecurityDefinitions;
    /**
     * A declaration of which security schemes are applied for the API as a whole.
 * The list of values describes alternative security schemes that can be used 
 * (that is, there is a logical OR between the security requirements). 
 * Individual operations can override this definition.
     */
      security: SecurityRequirement[];
    /**
     * Additional external documentation.
     */
      externalDocs: ExternalDocumentation;
extensions: Record<
              string,
              Value | undefined>;
}

    /**
     * `Operation` is a representation of OpenAPI v2 specification's Operation object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#operationObject
 *
 * Example:
 *
 *  service EchoService {
 *    rpc Echo(SimpleMessage) returns (SimpleMessage) {
 *      option (google.api.http) = {
 *        get: "/v1/example/echo/{id}"
 *      };
 *
 *      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
 *        summary: "Get a message.";
 *        operation_id: "getMessage";
 *        tags: "echo";
 *        responses: {
 *          key: "200"
 *            value: {
 *            description: "OK";
 *          }
 *        }
 *      };
 *    }
 *  }
     */
      export interface Operation {
    /**
     * A list of tags for API documentation control. Tags can be used for logical
 * grouping of operations by resources or any other qualifier.
     */
      tags: string[];
    /**
     * A short summary of what the operation does. For maximum readability in the
 * swagger-ui, this field SHOULD be less than 120 characters.
     */
      summary: string;
    /**
     * A verbose explanation of the operation behavior. GFM syntax can be used for
 * rich text representation.
     */
      description: string;
    /**
     * Additional external documentation for this operation.
     */
      externalDocs: ExternalDocumentation;
    /**
     * Unique string used to identify the operation. The id MUST be unique among
 * all operations described in the API. Tools and libraries MAY use the
 * operationId to uniquely identify an operation, therefore, it is recommended
 * to follow common programming naming conventions.
     */
      operationId: string;
    /**
     * A list of MIME types the operation can consume. This overrides the consumes
 * definition at the OpenAPI Object. An empty value MAY be used to clear the
 * global definition. Value MUST be as described under Mime Types.
     */
      consumes: string[];
    /**
     * A list of MIME types the operation can produce. This overrides the produces
 * definition at the OpenAPI Object. An empty value MAY be used to clear the
 * global definition. Value MUST be as described under Mime Types.
     */
      produces: string[];
    /**
     * The list of possible responses as they are returned from executing this
 * operation.
     */
      responses: Record<
              string,
              Response | undefined>;
    /**
     * The transfer protocol for the operation. Values MUST be from the list:
 * "http", "https", "ws", "wss". The value overrides the OpenAPI Object
 * schemes definition.
     */
      schemes: Scheme[];
    /**
     * Declares this operation to be deprecated. Usage of the declared operation
 * should be refrained. Default value is false.
     */
      deprecated: boolean;
    /**
     * A declaration of which security schemes are applied for this operation. The
 * list of values describes alternative security schemes that can be used
 * (that is, there is a logical OR between the security requirements). This
 * definition overrides any declared top-level security. To remove a top-level
 * security declaration, an empty array can be used.
     */
      security: SecurityRequirement[];
extensions: Record<
              string,
              Value | undefined>;
}

    /**
     * `Header` is a representation of OpenAPI v2 specification's Header object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#headerObject
 *
     */
      export interface Header {
    /**
     * `Description` is a short description of the header.
     */
      description: string;
    /**
     * The type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
     */
      type: string;
    /**
     * `Format` The extending format for the previously mentioned type.
     */
      format: string;
    /**
     * `Default` Declares the value of the header that the server will use if none is provided.
 * See: https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
 * Unlike JSON Schema this value MUST conform to the defined type for the header.
     */
      default: string;
    /**
     * 'Pattern' See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
     */
      pattern: string;
}

    /**
     * `Response` is a representation of OpenAPI v2 specification's Response object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#responseObject
 *
     */
      export interface Response {
    /**
     * `Description` is a short description of the response.
 * GFM syntax can be used for rich text representation.
     */
      description: string;
    /**
     * `Schema` optionally defines the structure of the response.
 * If `Schema` is not provided, it means there is no content to the response.
     */
      schema: Schema;
    /**
     * `Headers` A list of headers that are sent with the response.
 * `Header` name is expected to be a string in the canonical format of the MIME header key
 * See: https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
     */
      headers: Record<
              string,
              Header | undefined>;
    /**
     * `Examples` gives per-mimetype response examples.
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#example-object
     */
      examples: Record<
              string,
              string | undefined>;
extensions: Record<
              string,
              Value | undefined>;
}

    /**
     * `Info` is a representation of OpenAPI v2 specification's Info object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#infoObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      title: "Echo API";
 *      version: "1.0";
 *      description: ";
 *      contact: {
 *        name: "gRPC-Gateway project";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *        email: "none@example.com";
 *      };
 *      license: {
 *        name: "BSD 3-Clause License";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt";
 *      };
 *    };
 *    ...
 *  };
 *
     */
      export interface Info {
    /**
     * The title of the application.
     */
      title: string;
    /**
     * A short description of the application. GFM syntax can be used for rich
 * text representation.
     */
      description: string;
    /**
     * The Terms of Service for the API.
     */
      termsOfService: string;
    /**
     * The contact information for the exposed API.
     */
      contact: Contact;
    /**
     * The license information for the exposed API.
     */
      license: License;
    /**
     * Provides the version of the application API (not to be confused
 * with the specification version).
     */
      version: string;
extensions: Record<
              string,
              Value | undefined>;
}

    /**
     * `Contact` is a representation of OpenAPI v2 specification's Contact object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#contactObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      ...
 *      contact: {
 *        name: "gRPC-Gateway project";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *        email: "none@example.com";
 *      };
 *      ...
 *    };
 *    ...
 *  };
 *
     */
      export interface Contact {
    /**
     * The identifying name of the contact person/organization.
     */
      name: string;
    /**
     * The URL pointing to the contact information. MUST be in the format of a
 * URL.
     */
      url: string;
    /**
     * The email address of the contact person/organization. MUST be in the format
 * of an email address.
     */
      email: string;
}

    /**
     * `License` is a representation of OpenAPI v2 specification's License object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#licenseObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    info: {
 *      ...
 *      license: {
 *        name: "BSD 3-Clause License";
 *        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt";
 *      };
 *      ...
 *    };
 *    ...
 *  };
 *
     */
      export interface License {
    /**
     * The license name used for the API.
     */
      name: string;
    /**
     * A URL to the license used for the API. MUST be in the format of a URL.
     */
      url: string;
}

    /**
     * `ExternalDocumentation` is a representation of OpenAPI v2 specification's
 * ExternalDocumentation object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#externalDocumentationObject
 *
 * Example:
 *
 *  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
 *    ...
 *    external_docs: {
 *      description: "More about gRPC-Gateway";
 *      url: "https://github.com/grpc-ecosystem/grpc-gateway";
 *    }
 *    ...
 *  };
 *
     */
      export interface ExternalDocumentation {
    /**
     * A short description of the target documentation. GFM syntax can be used for
 * rich text representation.
     */
      description: string;
    /**
     * The URL for the target documentation. Value MUST be in the format
 * of a URL.
     */
      url: string;
}

    /**
     * `Schema` is a representation of OpenAPI v2 specification's Schema object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
 *
     */
      export interface Schema {
jsonSchema: JSONSchema;
    /**
     * Adds support for polymorphism. The discriminator is the schema property
 * name that is used to differentiate between other schema that inherit this
 * schema. The property name used MUST be defined at this schema and it MUST
 * be in the required property list. When used, the value MUST be the name of
 * this schema or any schema that inherits it.
     */
      discriminator: string;
    /**
     * Relevant only for Schema "properties" definitions. Declares the property as
 * "read only". This means that it MAY be sent as part of a response but MUST
 * NOT be sent as part of the request. Properties marked as readOnly being
 * true SHOULD NOT be in the required list of the defined schema. Default
 * value is false.
     */
      readOnly: boolean;
    /**
     * Additional external documentation for this schema.
     */
      externalDocs: ExternalDocumentation;
    /**
     * A free-form property to include an example of an instance for this schema in JSON.
 * This is copied verbatim to the output.
     */
      example: string;
}

    /**
     * `JSONSchema` represents properties from JSON Schema taken, and as used, in
 * the OpenAPI v2 spec.
 *
 * This includes changes made by OpenAPI v2.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
 *
 * See also: https://cswr.github.io/JsonSchema/spec/basic_types/,
 * https://github.com/json-schema-org/json-schema-spec/blob/master/schema.json
 *
 * Example:
 *
 *  message SimpleMessage {
 *    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *      json_schema: {
 *        title: "SimpleMessage"
 *        description: "A simple message."
 *        required: ["id"]
 *      }
 *    };
 *
 *    // Id represents the message identifier.
 *    string id = 1; [
 *        (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
 *          {description: "The unique identifier of the simple message."
 *        }];
 *  }
 *
     */
      export interface JSONSchema {
    /**
     * Ref is used to define an external reference to include in the message.
 * This could be a fully qualified proto message reference, and that type must
 * be imported into the protofile. If no message is identified, the Ref will
 * be used verbatim in the output.
 * For example:
 *  `ref: ".google.protobuf.Timestamp"`.
     */
      ref: string;
    /**
     * The title of the schema.
     */
      title: string;
    /**
     * A short description of the schema.
     */
      description: string;
default: string;
readOnly: boolean;
    /**
     * A free-form property to include a JSON example of this field. This is copied
 * verbatim to the output swagger.json. Quotes must be escaped.
 * This property is the same for 2.0 and 3.0.0 https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/3.0.0.md#schemaObject  https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
     */
      example: string;
multipleOf: number;
    /**
     * Maximum represents an inclusive upper limit for a numeric instance. The 
 * value of MUST be a number, 
     */
      maximum: number;
exclusiveMaximum: boolean;
    /**
     * minimum represents an inclusive lower limit for a numeric instance. The 
 * value of MUST be a number, 
     */
      minimum: number;
exclusiveMinimum: boolean;
maxLength: bigint;
minLength: bigint;
pattern: string;
maxItems: bigint;
minItems: bigint;
uniqueItems: boolean;
maxProperties: bigint;
minProperties: bigint;
required: string[];
    /**
     * Items in 'array' must be unique.
     */
      array: string[];
type: JSONSchema.JSONSchemaSimpleTypes[];
    /**
     * `Format`
     */
      format: string;
    /**
     * Items in `enum` must be unique https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1
     */
      enum: string[];
}

export namespace JSONSchema { 
export type JSONSchemaSimpleTypes = typeof JSONSchema.JSONSchemaSimpleTypes[keyof typeof JSONSchema.JSONSchemaSimpleTypes];



}

    /**
     * `Tag` is a representation of OpenAPI v2 specification's Tag object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#tagObject
 *
     */
      export interface Tag {
    /**
     * A short description for the tag. GFM syntax can be used for rich text 
 * representation.
     */
      description: string;
    /**
     * Additional external documentation for this tag.
     */
      externalDocs: ExternalDocumentation;
}

    /**
     * `SecurityDefinitions` is a representation of OpenAPI v2 specification's
 * Security Definitions object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityDefinitionsObject
 *
 * A declaration of the security schemes available to be used in the
 * specification. This does not enforce the security schemes on the operations
 * and only serves to provide the relevant details for each scheme.
     */
      export interface SecurityDefinitions {
    /**
     * A single security scheme definition, mapping a "name" to the scheme it
 * defines.
     */
      security: Record<
              string,
              SecurityScheme | undefined>;
}

    /**
     * `SecurityScheme` is a representation of OpenAPI v2 specification's
 * Security Scheme object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securitySchemeObject
 *
 * Allows the definition of a security scheme that can be used by the
 * operations. Supported schemes are basic authentication, an API key (either as
 * a header or as a query parameter) and OAuth2's common flows (implicit,
 * password, application and access code).
     */
      export interface SecurityScheme {
    /**
     * The type of the security scheme. Valid values are "basic",
 * "apiKey" or "oauth2".
     */
      type: SecurityScheme.Type;
    /**
     * A short description for security scheme.
     */
      description: string;
    /**
     * The name of the header or query parameter to be used.
 * Valid for apiKey.
     */
      name: string;
    /**
     * The location of the API key. Valid values are "query" or
 * "header".
 * Valid for apiKey.
     */
      in: SecurityScheme.In;
    /**
     * The flow used by the OAuth2 security scheme. Valid values are
 * "implicit", "password", "application" or "accessCode".
 * Valid for oauth2.
     */
      flow: SecurityScheme.Flow;
    /**
     * The authorization URL to be used for this flow. This SHOULD be in
 * the form of a URL.
 * Valid for oauth2/implicit and oauth2/accessCode.
     */
      authorizationUrl: string;
    /**
     * The token URL to be used for this flow. This SHOULD be in the
 * form of a URL.
 * Valid for oauth2/password, oauth2/application and oauth2/accessCode.
     */
      tokenUrl: string;
    /**
     * The available scopes for the OAuth2 security scheme.
 * Valid for oauth2.
     */
      scopes: Scopes;
extensions: Record<
              string,
              Value | undefined>;
}

export namespace SecurityScheme { 
    /**
     * The type of the security scheme. Valid values are "basic",
 * "apiKey" or "oauth2".
     */
      export type Type = typeof SecurityScheme.Type[keyof typeof SecurityScheme.Type];

    /**
     * The location of the API key. Valid values are "query" or "header".
     */
      export type In = typeof SecurityScheme.In[keyof typeof SecurityScheme.In];

    /**
     * The flow used by the OAuth2 security scheme. Valid values are
 * "implicit", "password", "application" or "accessCode".
     */
      export type Flow = typeof SecurityScheme.Flow[keyof typeof SecurityScheme.Flow];



}

    /**
     * `SecurityRequirement` is a representation of OpenAPI v2 specification's
 * Security Requirement object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityRequirementObject
 *
 * Lists the required security schemes to execute this operation. The object can
 * have multiple security schemes declared in it which are all required (that
 * is, there is a logical AND between the schemes).
 *
 * The name used for each property MUST correspond to a security scheme
 * declared in the Security Definitions.
     */
      export interface SecurityRequirement {
    /**
     * Each name must correspond to a security scheme which is declared in
 * the Security Definitions. If the security scheme is of type "oauth2",
 * then the value is a list of scope names required for the execution.
 * For other security scheme types, the array MUST be empty.
     */
      securityRequirement: Record<
              string,
              SecurityRequirement.SecurityRequirementValue | undefined>;
}

export namespace SecurityRequirement { 
    /**
     * If the security scheme is of type "oauth2", then the value is a list of
 * scope names required for the execution. For other security scheme types,
 * the array MUST be empty.
     */
      export interface SecurityRequirementValue {
scope: string[];
}



}

    /**
     * `Scopes` is a representation of OpenAPI v2 specification's Scopes object.
 *
 * See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#scopesObject
 *
 * Lists the available scopes for an OAuth2 security scheme.
     */
      export interface Scopes {
    /**
     * Maps between a name of a scope to a short description of it (as the value
 * of the property).
     */
      scope: Record<
              string,
              string | undefined>;
}


  //========================================//
  //        Protobuf Encode / Decode        //
  //========================================//
  
  
export const Scheme = {UNKNOWN: 0,
HTTP: 1,
HTTPS: 2,
WS: 3,
WSS: 4,
} as const;

export const Swagger = {        /**
         * Serializes a Swagger to protobuf.
         */
        encode: function(swagger: Partial<Swagger>): Uint8Array {
          return Swagger._writeMessage(swagger, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Swagger from protobuf.
         */
        decode: function(bytes: ByteSource): Swagger {
          return Swagger._readMessage(Swagger.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Swagger to JSON.
         */
        encodeJSON: function(swagger: Partial<Swagger>): string {
          return JSON.stringify(Swagger._writeMessageJSON(swagger));
        },
        

        /**
         * Deserializes a Swagger from JSON.
         */
        decodeJSON: function(json: string): Swagger {
          return Swagger._readMessageJSON(Swagger.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Swagger with all fields set to their default value.
         */
        initialize: function(): Swagger {
          return {
            swagger: '',info: Info.initialize(),host: '',basePath: '',schemes: [],consumes: [],produces: [],responses: {},securityDefinitions: SecurityDefinitions.initialize(),security: [],externalDocs: ExternalDocumentation.initialize(),extensions: {},
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Swagger>, writer: BinaryWriter): BinaryWriter {
          if (msg.swagger) {writer.writeString(1, msg.swagger);}
if (msg.info) {writer.writeMessage(2, msg.info , Info._writeMessage);}
if (msg.host) {writer.writeString(3, msg.host);}
if (msg.basePath) {writer.writeString(4, msg.basePath);}
if (msg.schemes?.length) {writer.writeRepeatedEnum(5, msg.schemes);}
if (msg.consumes?.length) {writer.writeRepeatedString(6, msg.consumes);}
if (msg.produces?.length) {writer.writeRepeatedString(7, msg.produces);}
if (msg.responses) {for (const [key, value] of Object.entries(msg.responses)) {
                  if (value) {
                    writer.writeMessage(10, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeMessage(2, value, Response._writeMessage);})
}}}
if (msg.securityDefinitions) {writer.writeMessage(11, msg.securityDefinitions , SecurityDefinitions._writeMessage);}
if (msg.security?.length) {writer.writeRepeatedMessage(12, msg.security as any, SecurityRequirement._writeMessage);}
if (msg.externalDocs) {writer.writeMessage(14, msg.externalDocs , ExternalDocumentation._writeMessage);}
if (msg.extensions) {for (const [key, value] of Object.entries(msg.extensions)) {
                  if (value) {
                    writer.writeMessage(15, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeMessage(2, value, Value._writeMessage);})
}}}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Swagger>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.swagger) {json.swagger = msg.swagger;}
if (msg.info) {const info = Info._writeMessageJSON(msg.info);if (Object.keys(info).length > 0) {json.info = info;}}
if (msg.host) {json.host = msg.host;}
if (msg.basePath) {json.basePath = msg.basePath;}
if (msg.schemes?.length) {json.schemes = msg.schemes;}
if (msg.consumes?.length) {json.consumes = msg.consumes;}
if (msg.produces?.length) {json.produces = msg.produces;}
if (msg.responses) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.responses)) {
                  if (value) {map[key] =Response._writeMessageJSON(value);json.responses = map}
}}
if (msg.securityDefinitions) {const securityDefinitions = SecurityDefinitions._writeMessageJSON(msg.securityDefinitions);if (Object.keys(securityDefinitions).length > 0) {json.securityDefinitions = securityDefinitions;}}
if (msg.security?.length) {json.security = msg.security.map(SecurityRequirement._writeMessageJSON)}
if (msg.externalDocs) {const externalDocs = ExternalDocumentation._writeMessageJSON(msg.externalDocs);if (Object.keys(externalDocs).length > 0) {json.externalDocs = externalDocs;}}
if (msg.extensions) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.extensions)) {
                  if (value) {map[key] =Value._writeMessageJSON(value);json.extensions = map}
}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Swagger, reader: BinaryReader): Swagger {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.swagger = reader.readString();break;
}
case 2: {
                      reader.readMessage(msg.info, Info._readMessage);
                    break;
}
case 3: {msg.host = reader.readString();break;
}
case 4: {msg.basePath = reader.readString();break;
}
case 5: {msg.schemes.push(reader.readEnum() as Scheme);break;
}
case 6: {msg.consumes.push(reader.readString());break;
}
case 7: {msg.produces.push(reader.readString());break;
}
case 10: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = undefined;
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        reader.readMessage(Response.initialize(), Response._readMessage);break;
                          }
                        }
                      }
                      if (key) {
                        msg.responses[key] = value;
                      }
                    });break;
}
case 11: {
                      reader.readMessage(msg.securityDefinitions, SecurityDefinitions._readMessage);
                    break;
}
case 12: {const m = SecurityRequirement.initialize();reader.readMessage(m, SecurityRequirement._readMessage);msg.security.push(m);break;
}
case 14: {
                      reader.readMessage(msg.externalDocs, ExternalDocumentation._readMessage);
                    break;
}
case 15: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = undefined;
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        reader.readMessage(Value.initialize(), Value._readMessage);break;
                          }
                        }
                      }
                      if (key) {
                        msg.extensions[key] = value;
                      }
                    });break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Swagger, json: any): Swagger {
          const swagger = json.swagger ?? json.swagger;if (swagger) {msg.swagger = swagger;}
const info = json.info ?? json.info;if (info) {const m = Info.initialize();Info._readMessageJSON(m, info);msg.info = m;}
const host = json.host ?? json.host;if (host) {msg.host = host;}
const basePath = json.basePath ?? json.base_path;if (basePath) {msg.basePath = basePath;}
const schemes = json.schemes ?? json.schemes;if (schemes) {msg.schemes = schemes;}
const consumes = json.consumes ?? json.consumes;if (consumes) {msg.consumes = consumes;}
const produces = json.produces ?? json.produces;if (produces) {msg.produces = produces;}
const responses = json.responses ?? json.responses;if (responses) {for (const [key, value] of Object.entries<Response>(responses)) {msg.responses[key] =Response._readMessageJSON(Response.initialize(), value);}}
const securityDefinitions = json.securityDefinitions ?? json.security_definitions;if (securityDefinitions) {const m = SecurityDefinitions.initialize();SecurityDefinitions._readMessageJSON(m, securityDefinitions);msg.securityDefinitions = m;}
const security = json.security ?? json.security;if (security) {for (const item of security) {const m = SecurityRequirement.initialize();SecurityRequirement._readMessageJSON(m, item);msg.security.push(m);}}
const externalDocs = json.externalDocs ?? json.external_docs;if (externalDocs) {const m = ExternalDocumentation.initialize();ExternalDocumentation._readMessageJSON(m, externalDocs);msg.externalDocs = m;}
const extensions = json.extensions ?? json.extensions;if (extensions) {for (const [key, value] of Object.entries<Value>(extensions)) {msg.extensions[key] =Value._readMessageJSON(Value.initialize(), value);}}
          return msg;
        },

      };

export const Operation = {        /**
         * Serializes a Operation to protobuf.
         */
        encode: function(operation: Partial<Operation>): Uint8Array {
          return Operation._writeMessage(operation, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Operation from protobuf.
         */
        decode: function(bytes: ByteSource): Operation {
          return Operation._readMessage(Operation.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Operation to JSON.
         */
        encodeJSON: function(operation: Partial<Operation>): string {
          return JSON.stringify(Operation._writeMessageJSON(operation));
        },
        

        /**
         * Deserializes a Operation from JSON.
         */
        decodeJSON: function(json: string): Operation {
          return Operation._readMessageJSON(Operation.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Operation with all fields set to their default value.
         */
        initialize: function(): Operation {
          return {
            tags: [],summary: '',description: '',externalDocs: ExternalDocumentation.initialize(),operationId: '',consumes: [],produces: [],responses: {},schemes: [],deprecated: false,security: [],extensions: {},
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Operation>, writer: BinaryWriter): BinaryWriter {
          if (msg.tags?.length) {writer.writeRepeatedString(1, msg.tags);}
if (msg.summary) {writer.writeString(2, msg.summary);}
if (msg.description) {writer.writeString(3, msg.description);}
if (msg.externalDocs) {writer.writeMessage(4, msg.externalDocs , ExternalDocumentation._writeMessage);}
if (msg.operationId) {writer.writeString(5, msg.operationId);}
if (msg.consumes?.length) {writer.writeRepeatedString(6, msg.consumes);}
if (msg.produces?.length) {writer.writeRepeatedString(7, msg.produces);}
if (msg.responses) {for (const [key, value] of Object.entries(msg.responses)) {
                  if (value) {
                    writer.writeMessage(9, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeMessage(2, value, Response._writeMessage);})
}}}
if (msg.schemes?.length) {writer.writeRepeatedEnum(10, msg.schemes);}
if (msg.deprecated) {writer.writeBool(11, msg.deprecated);}
if (msg.security?.length) {writer.writeRepeatedMessage(12, msg.security as any, SecurityRequirement._writeMessage);}
if (msg.extensions) {for (const [key, value] of Object.entries(msg.extensions)) {
                  if (value) {
                    writer.writeMessage(13, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeMessage(2, value, Value._writeMessage);})
}}}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Operation>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.tags?.length) {json.tags = msg.tags;}
if (msg.summary) {json.summary = msg.summary;}
if (msg.description) {json.description = msg.description;}
if (msg.externalDocs) {const externalDocs = ExternalDocumentation._writeMessageJSON(msg.externalDocs);if (Object.keys(externalDocs).length > 0) {json.externalDocs = externalDocs;}}
if (msg.operationId) {json.operationId = msg.operationId;}
if (msg.consumes?.length) {json.consumes = msg.consumes;}
if (msg.produces?.length) {json.produces = msg.produces;}
if (msg.responses) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.responses)) {
                  if (value) {map[key] =Response._writeMessageJSON(value);json.responses = map}
}}
if (msg.schemes?.length) {json.schemes = msg.schemes;}
if (msg.deprecated) {json.deprecated = msg.deprecated;}
if (msg.security?.length) {json.security = msg.security.map(SecurityRequirement._writeMessageJSON)}
if (msg.extensions) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.extensions)) {
                  if (value) {map[key] =Value._writeMessageJSON(value);json.extensions = map}
}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Operation, reader: BinaryReader): Operation {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.tags.push(reader.readString());break;
}
case 2: {msg.summary = reader.readString();break;
}
case 3: {msg.description = reader.readString();break;
}
case 4: {
                      reader.readMessage(msg.externalDocs, ExternalDocumentation._readMessage);
                    break;
}
case 5: {msg.operationId = reader.readString();break;
}
case 6: {msg.consumes.push(reader.readString());break;
}
case 7: {msg.produces.push(reader.readString());break;
}
case 9: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = undefined;
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        reader.readMessage(Response.initialize(), Response._readMessage);break;
                          }
                        }
                      }
                      if (key) {
                        msg.responses[key] = value;
                      }
                    });break;
}
case 10: {msg.schemes.push(reader.readEnum() as Scheme);break;
}
case 11: {msg.deprecated = reader.readBool();break;
}
case 12: {const m = SecurityRequirement.initialize();reader.readMessage(m, SecurityRequirement._readMessage);msg.security.push(m);break;
}
case 13: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = undefined;
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        reader.readMessage(Value.initialize(), Value._readMessage);break;
                          }
                        }
                      }
                      if (key) {
                        msg.extensions[key] = value;
                      }
                    });break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Operation, json: any): Operation {
          const tags = json.tags ?? json.tags;if (tags) {msg.tags = tags;}
const summary = json.summary ?? json.summary;if (summary) {msg.summary = summary;}
const description = json.description ?? json.description;if (description) {msg.description = description;}
const externalDocs = json.externalDocs ?? json.external_docs;if (externalDocs) {const m = ExternalDocumentation.initialize();ExternalDocumentation._readMessageJSON(m, externalDocs);msg.externalDocs = m;}
const operationId = json.operationId ?? json.operation_id;if (operationId) {msg.operationId = operationId;}
const consumes = json.consumes ?? json.consumes;if (consumes) {msg.consumes = consumes;}
const produces = json.produces ?? json.produces;if (produces) {msg.produces = produces;}
const responses = json.responses ?? json.responses;if (responses) {for (const [key, value] of Object.entries<Response>(responses)) {msg.responses[key] =Response._readMessageJSON(Response.initialize(), value);}}
const schemes = json.schemes ?? json.schemes;if (schemes) {msg.schemes = schemes;}
const deprecated = json.deprecated ?? json.deprecated;if (deprecated) {msg.deprecated = deprecated;}
const security = json.security ?? json.security;if (security) {for (const item of security) {const m = SecurityRequirement.initialize();SecurityRequirement._readMessageJSON(m, item);msg.security.push(m);}}
const extensions = json.extensions ?? json.extensions;if (extensions) {for (const [key, value] of Object.entries<Value>(extensions)) {msg.extensions[key] =Value._readMessageJSON(Value.initialize(), value);}}
          return msg;
        },

      };

export const Header = {        /**
         * Serializes a Header to protobuf.
         */
        encode: function(header: Partial<Header>): Uint8Array {
          return Header._writeMessage(header, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Header from protobuf.
         */
        decode: function(bytes: ByteSource): Header {
          return Header._readMessage(Header.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Header to JSON.
         */
        encodeJSON: function(header: Partial<Header>): string {
          return JSON.stringify(Header._writeMessageJSON(header));
        },
        

        /**
         * Deserializes a Header from JSON.
         */
        decodeJSON: function(json: string): Header {
          return Header._readMessageJSON(Header.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Header with all fields set to their default value.
         */
        initialize: function(): Header {
          return {
            description: '',type: '',format: '',default: '',pattern: '',
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Header>, writer: BinaryWriter): BinaryWriter {
          if (msg.description) {writer.writeString(1, msg.description);}
if (msg.type) {writer.writeString(2, msg.type);}
if (msg.format) {writer.writeString(3, msg.format);}
if (msg.default) {writer.writeString(6, msg.default);}
if (msg.pattern) {writer.writeString(13, msg.pattern);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Header>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.description) {json.description = msg.description;}
if (msg.type) {json.type = msg.type;}
if (msg.format) {json.format = msg.format;}
if (msg.default) {json.default = msg.default;}
if (msg.pattern) {json.pattern = msg.pattern;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Header, reader: BinaryReader): Header {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.description = reader.readString();break;
}
case 2: {msg.type = reader.readString();break;
}
case 3: {msg.format = reader.readString();break;
}
case 6: {msg.default = reader.readString();break;
}
case 13: {msg.pattern = reader.readString();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Header, json: any): Header {
          const description = json.description ?? json.description;if (description) {msg.description = description;}
const type = json.type ?? json.type;if (type) {msg.type = type;}
const format = json.format ?? json.format;if (format) {msg.format = format;}
const default = json.default ?? json.default;if (default) {msg.default = default;}
const pattern = json.pattern ?? json.pattern;if (pattern) {msg.pattern = pattern;}
          return msg;
        },

      };

export const Response = {        /**
         * Serializes a Response to protobuf.
         */
        encode: function(response: Partial<Response>): Uint8Array {
          return Response._writeMessage(response, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Response from protobuf.
         */
        decode: function(bytes: ByteSource): Response {
          return Response._readMessage(Response.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Response to JSON.
         */
        encodeJSON: function(response: Partial<Response>): string {
          return JSON.stringify(Response._writeMessageJSON(response));
        },
        

        /**
         * Deserializes a Response from JSON.
         */
        decodeJSON: function(json: string): Response {
          return Response._readMessageJSON(Response.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Response with all fields set to their default value.
         */
        initialize: function(): Response {
          return {
            description: '',schema: Schema.initialize(),headers: {},examples: {},extensions: {},
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Response>, writer: BinaryWriter): BinaryWriter {
          if (msg.description) {writer.writeString(1, msg.description);}
if (msg.schema) {writer.writeMessage(2, msg.schema , Schema._writeMessage);}
if (msg.headers) {for (const [key, value] of Object.entries(msg.headers)) {
                  if (value) {
                    writer.writeMessage(3, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeMessage(2, value, Header._writeMessage);})
}}}
if (msg.examples) {for (const [key, value] of Object.entries(msg.examples)) {
                  if (value) {
                    writer.writeMessage(4, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeString(2, value);})
}}}
if (msg.extensions) {for (const [key, value] of Object.entries(msg.extensions)) {
                  if (value) {
                    writer.writeMessage(5, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeMessage(2, value, Value._writeMessage);})
}}}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Response>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.description) {json.description = msg.description;}
if (msg.schema) {const schema = Schema._writeMessageJSON(msg.schema);if (Object.keys(schema).length > 0) {json.schema = schema;}}
if (msg.headers) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.headers)) {
                  if (value) {map[key] =Header._writeMessageJSON(value);json.headers = map}
}}
if (msg.examples) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.examples)) {
                  if (value) {map[key] =value;json.examples = map}
}}
if (msg.extensions) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.extensions)) {
                  if (value) {map[key] =Value._writeMessageJSON(value);json.extensions = map}
}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Response, reader: BinaryReader): Response {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.description = reader.readString();break;
}
case 2: {
                      reader.readMessage(msg.schema, Schema._readMessage);
                    break;
}
case 3: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = undefined;
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        reader.readMessage(Header.initialize(), Header._readMessage);break;
                          }
                        }
                      }
                      if (key) {
                        msg.headers[key] = value;
                      }
                    });break;
}
case 4: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = '';
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        value = reader.readString();break;
                          }
                        }
                      }
                      if (key) {
                        msg.examples[key] = value;
                      }
                    });break;
}
case 5: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = undefined;
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        reader.readMessage(Value.initialize(), Value._readMessage);break;
                          }
                        }
                      }
                      if (key) {
                        msg.extensions[key] = value;
                      }
                    });break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Response, json: any): Response {
          const description = json.description ?? json.description;if (description) {msg.description = description;}
const schema = json.schema ?? json.schema;if (schema) {const m = Schema.initialize();Schema._readMessageJSON(m, schema);msg.schema = m;}
const headers = json.headers ?? json.headers;if (headers) {for (const [key, value] of Object.entries<Header>(headers)) {msg.headers[key] =Header._readMessageJSON(Header.initialize(), value);}}
const examples = json.examples ?? json.examples;if (examples) {for (const [key, value] of Object.entries<string>(examples)) {msg.examples[key] =value;}}
const extensions = json.extensions ?? json.extensions;if (extensions) {for (const [key, value] of Object.entries<Value>(extensions)) {msg.extensions[key] =Value._readMessageJSON(Value.initialize(), value);}}
          return msg;
        },

      };

export const Info = {        /**
         * Serializes a Info to protobuf.
         */
        encode: function(info: Partial<Info>): Uint8Array {
          return Info._writeMessage(info, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Info from protobuf.
         */
        decode: function(bytes: ByteSource): Info {
          return Info._readMessage(Info.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Info to JSON.
         */
        encodeJSON: function(info: Partial<Info>): string {
          return JSON.stringify(Info._writeMessageJSON(info));
        },
        

        /**
         * Deserializes a Info from JSON.
         */
        decodeJSON: function(json: string): Info {
          return Info._readMessageJSON(Info.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Info with all fields set to their default value.
         */
        initialize: function(): Info {
          return {
            title: '',description: '',termsOfService: '',contact: Contact.initialize(),license: License.initialize(),version: '',extensions: {},
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Info>, writer: BinaryWriter): BinaryWriter {
          if (msg.title) {writer.writeString(1, msg.title);}
if (msg.description) {writer.writeString(2, msg.description);}
if (msg.termsOfService) {writer.writeString(3, msg.termsOfService);}
if (msg.contact) {writer.writeMessage(4, msg.contact , Contact._writeMessage);}
if (msg.license) {writer.writeMessage(5, msg.license , License._writeMessage);}
if (msg.version) {writer.writeString(6, msg.version);}
if (msg.extensions) {for (const [key, value] of Object.entries(msg.extensions)) {
                  if (value) {
                    writer.writeMessage(7, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeMessage(2, value, Value._writeMessage);})
}}}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Info>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.title) {json.title = msg.title;}
if (msg.description) {json.description = msg.description;}
if (msg.termsOfService) {json.termsOfService = msg.termsOfService;}
if (msg.contact) {const contact = Contact._writeMessageJSON(msg.contact);if (Object.keys(contact).length > 0) {json.contact = contact;}}
if (msg.license) {const license = License._writeMessageJSON(msg.license);if (Object.keys(license).length > 0) {json.license = license;}}
if (msg.version) {json.version = msg.version;}
if (msg.extensions) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.extensions)) {
                  if (value) {map[key] =Value._writeMessageJSON(value);json.extensions = map}
}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Info, reader: BinaryReader): Info {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.title = reader.readString();break;
}
case 2: {msg.description = reader.readString();break;
}
case 3: {msg.termsOfService = reader.readString();break;
}
case 4: {
                      reader.readMessage(msg.contact, Contact._readMessage);
                    break;
}
case 5: {
                      reader.readMessage(msg.license, License._readMessage);
                    break;
}
case 6: {msg.version = reader.readString();break;
}
case 7: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = undefined;
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        reader.readMessage(Value.initialize(), Value._readMessage);break;
                          }
                        }
                      }
                      if (key) {
                        msg.extensions[key] = value;
                      }
                    });break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Info, json: any): Info {
          const title = json.title ?? json.title;if (title) {msg.title = title;}
const description = json.description ?? json.description;if (description) {msg.description = description;}
const termsOfService = json.termsOfService ?? json.terms_of_service;if (termsOfService) {msg.termsOfService = termsOfService;}
const contact = json.contact ?? json.contact;if (contact) {const m = Contact.initialize();Contact._readMessageJSON(m, contact);msg.contact = m;}
const license = json.license ?? json.license;if (license) {const m = License.initialize();License._readMessageJSON(m, license);msg.license = m;}
const version = json.version ?? json.version;if (version) {msg.version = version;}
const extensions = json.extensions ?? json.extensions;if (extensions) {for (const [key, value] of Object.entries<Value>(extensions)) {msg.extensions[key] =Value._readMessageJSON(Value.initialize(), value);}}
          return msg;
        },

      };

export const Contact = {        /**
         * Serializes a Contact to protobuf.
         */
        encode: function(contact: Partial<Contact>): Uint8Array {
          return Contact._writeMessage(contact, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Contact from protobuf.
         */
        decode: function(bytes: ByteSource): Contact {
          return Contact._readMessage(Contact.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Contact to JSON.
         */
        encodeJSON: function(contact: Partial<Contact>): string {
          return JSON.stringify(Contact._writeMessageJSON(contact));
        },
        

        /**
         * Deserializes a Contact from JSON.
         */
        decodeJSON: function(json: string): Contact {
          return Contact._readMessageJSON(Contact.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Contact with all fields set to their default value.
         */
        initialize: function(): Contact {
          return {
            name: '',url: '',email: '',
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Contact>, writer: BinaryWriter): BinaryWriter {
          if (msg.name) {writer.writeString(1, msg.name);}
if (msg.url) {writer.writeString(2, msg.url);}
if (msg.email) {writer.writeString(3, msg.email);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Contact>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name) {json.name = msg.name;}
if (msg.url) {json.url = msg.url;}
if (msg.email) {json.email = msg.email;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Contact, reader: BinaryReader): Contact {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.name = reader.readString();break;
}
case 2: {msg.url = reader.readString();break;
}
case 3: {msg.email = reader.readString();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Contact, json: any): Contact {
          const name = json.name ?? json.name;if (name) {msg.name = name;}
const url = json.url ?? json.url;if (url) {msg.url = url;}
const email = json.email ?? json.email;if (email) {msg.email = email;}
          return msg;
        },

      };

export const License = {        /**
         * Serializes a License to protobuf.
         */
        encode: function(license: Partial<License>): Uint8Array {
          return License._writeMessage(license, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a License from protobuf.
         */
        decode: function(bytes: ByteSource): License {
          return License._readMessage(License.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a License to JSON.
         */
        encodeJSON: function(license: Partial<License>): string {
          return JSON.stringify(License._writeMessageJSON(license));
        },
        

        /**
         * Deserializes a License from JSON.
         */
        decodeJSON: function(json: string): License {
          return License._readMessageJSON(License.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a License with all fields set to their default value.
         */
        initialize: function(): License {
          return {
            name: '',url: '',
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<License>, writer: BinaryWriter): BinaryWriter {
          if (msg.name) {writer.writeString(1, msg.name);}
if (msg.url) {writer.writeString(2, msg.url);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<License>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name) {json.name = msg.name;}
if (msg.url) {json.url = msg.url;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: License, reader: BinaryReader): License {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.name = reader.readString();break;
}
case 2: {msg.url = reader.readString();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: License, json: any): License {
          const name = json.name ?? json.name;if (name) {msg.name = name;}
const url = json.url ?? json.url;if (url) {msg.url = url;}
          return msg;
        },

      };

export const ExternalDocumentation = {        /**
         * Serializes a ExternalDocumentation to protobuf.
         */
        encode: function(externalDocumentation: Partial<ExternalDocumentation>): Uint8Array {
          return ExternalDocumentation._writeMessage(externalDocumentation, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a ExternalDocumentation from protobuf.
         */
        decode: function(bytes: ByteSource): ExternalDocumentation {
          return ExternalDocumentation._readMessage(ExternalDocumentation.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a ExternalDocumentation to JSON.
         */
        encodeJSON: function(externalDocumentation: Partial<ExternalDocumentation>): string {
          return JSON.stringify(ExternalDocumentation._writeMessageJSON(externalDocumentation));
        },
        

        /**
         * Deserializes a ExternalDocumentation from JSON.
         */
        decodeJSON: function(json: string): ExternalDocumentation {
          return ExternalDocumentation._readMessageJSON(ExternalDocumentation.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a ExternalDocumentation with all fields set to their default value.
         */
        initialize: function(): ExternalDocumentation {
          return {
            description: '',url: '',
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<ExternalDocumentation>, writer: BinaryWriter): BinaryWriter {
          if (msg.description) {writer.writeString(1, msg.description);}
if (msg.url) {writer.writeString(2, msg.url);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<ExternalDocumentation>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.description) {json.description = msg.description;}
if (msg.url) {json.url = msg.url;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: ExternalDocumentation, reader: BinaryReader): ExternalDocumentation {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.description = reader.readString();break;
}
case 2: {msg.url = reader.readString();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: ExternalDocumentation, json: any): ExternalDocumentation {
          const description = json.description ?? json.description;if (description) {msg.description = description;}
const url = json.url ?? json.url;if (url) {msg.url = url;}
          return msg;
        },

      };

export const Schema = {        /**
         * Serializes a Schema to protobuf.
         */
        encode: function(schema: Partial<Schema>): Uint8Array {
          return Schema._writeMessage(schema, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Schema from protobuf.
         */
        decode: function(bytes: ByteSource): Schema {
          return Schema._readMessage(Schema.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Schema to JSON.
         */
        encodeJSON: function(schema: Partial<Schema>): string {
          return JSON.stringify(Schema._writeMessageJSON(schema));
        },
        

        /**
         * Deserializes a Schema from JSON.
         */
        decodeJSON: function(json: string): Schema {
          return Schema._readMessageJSON(Schema.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Schema with all fields set to their default value.
         */
        initialize: function(): Schema {
          return {
            jsonSchema: JSONSchema.initialize(),discriminator: '',readOnly: false,externalDocs: ExternalDocumentation.initialize(),example: '',
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Schema>, writer: BinaryWriter): BinaryWriter {
          if (msg.jsonSchema) {writer.writeMessage(1, msg.jsonSchema , JSONSchema._writeMessage);}
if (msg.discriminator) {writer.writeString(2, msg.discriminator);}
if (msg.readOnly) {writer.writeBool(3, msg.readOnly);}
if (msg.externalDocs) {writer.writeMessage(5, msg.externalDocs , ExternalDocumentation._writeMessage);}
if (msg.example) {writer.writeString(6, msg.example);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Schema>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.jsonSchema) {const jsonSchema = JSONSchema._writeMessageJSON(msg.jsonSchema);if (Object.keys(jsonSchema).length > 0) {json.jsonSchema = jsonSchema;}}
if (msg.discriminator) {json.discriminator = msg.discriminator;}
if (msg.readOnly) {json.readOnly = msg.readOnly;}
if (msg.externalDocs) {const externalDocs = ExternalDocumentation._writeMessageJSON(msg.externalDocs);if (Object.keys(externalDocs).length > 0) {json.externalDocs = externalDocs;}}
if (msg.example) {json.example = msg.example;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Schema, reader: BinaryReader): Schema {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {
                      reader.readMessage(msg.jsonSchema, JSONSchema._readMessage);
                    break;
}
case 2: {msg.discriminator = reader.readString();break;
}
case 3: {msg.readOnly = reader.readBool();break;
}
case 5: {
                      reader.readMessage(msg.externalDocs, ExternalDocumentation._readMessage);
                    break;
}
case 6: {msg.example = reader.readString();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Schema, json: any): Schema {
          const jsonSchema = json.jsonSchema ?? json.json_schema;if (jsonSchema) {const m = JSONSchema.initialize();JSONSchema._readMessageJSON(m, jsonSchema);msg.jsonSchema = m;}
const discriminator = json.discriminator ?? json.discriminator;if (discriminator) {msg.discriminator = discriminator;}
const readOnly = json.readOnly ?? json.read_only;if (readOnly) {msg.readOnly = readOnly;}
const externalDocs = json.externalDocs ?? json.external_docs;if (externalDocs) {const m = ExternalDocumentation.initialize();ExternalDocumentation._readMessageJSON(m, externalDocs);msg.externalDocs = m;}
const example = json.example ?? json.example;if (example) {msg.example = example;}
          return msg;
        },

      };

export const JSONSchema = {        /**
         * Serializes a JSONSchema to protobuf.
         */
        encode: function(jSONSchema: Partial<JSONSchema>): Uint8Array {
          return JSONSchema._writeMessage(jSONSchema, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a JSONSchema from protobuf.
         */
        decode: function(bytes: ByteSource): JSONSchema {
          return JSONSchema._readMessage(JSONSchema.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a JSONSchema to JSON.
         */
        encodeJSON: function(jSONSchema: Partial<JSONSchema>): string {
          return JSON.stringify(JSONSchema._writeMessageJSON(jSONSchema));
        },
        

        /**
         * Deserializes a JSONSchema from JSON.
         */
        decodeJSON: function(json: string): JSONSchema {
          return JSONSchema._readMessageJSON(JSONSchema.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a JSONSchema with all fields set to their default value.
         */
        initialize: function(): JSONSchema {
          return {
            ref: '',title: '',description: '',default: '',readOnly: false,example: '',multipleOf: 0,maximum: 0,exclusiveMaximum: false,minimum: 0,exclusiveMinimum: false,maxLength: 0n,minLength: 0n,pattern: '',maxItems: 0n,minItems: 0n,uniqueItems: false,maxProperties: 0n,minProperties: 0n,required: [],array: [],type: [],format: '',enum: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<JSONSchema>, writer: BinaryWriter): BinaryWriter {
          if (msg.ref) {writer.writeString(3, msg.ref);}
if (msg.title) {writer.writeString(5, msg.title);}
if (msg.description) {writer.writeString(6, msg.description);}
if (msg.default) {writer.writeString(7, msg.default);}
if (msg.readOnly) {writer.writeBool(8, msg.readOnly);}
if (msg.example) {writer.writeString(9, msg.example);}
if (msg.multipleOf) {writer.writeDouble(10, msg.multipleOf);}
if (msg.maximum) {writer.writeDouble(11, msg.maximum);}
if (msg.exclusiveMaximum) {writer.writeBool(12, msg.exclusiveMaximum);}
if (msg.minimum) {writer.writeDouble(13, msg.minimum);}
if (msg.exclusiveMinimum) {writer.writeBool(14, msg.exclusiveMinimum);}
if (msg.maxLength) {writer.writeUint64String(15, msg.maxLength.toString());}
if (msg.minLength) {writer.writeUint64String(16, msg.minLength.toString());}
if (msg.pattern) {writer.writeString(17, msg.pattern);}
if (msg.maxItems) {writer.writeUint64String(20, msg.maxItems.toString());}
if (msg.minItems) {writer.writeUint64String(21, msg.minItems.toString());}
if (msg.uniqueItems) {writer.writeBool(22, msg.uniqueItems);}
if (msg.maxProperties) {writer.writeUint64String(24, msg.maxProperties.toString());}
if (msg.minProperties) {writer.writeUint64String(25, msg.minProperties.toString());}
if (msg.required?.length) {writer.writeRepeatedString(26, msg.required);}
if (msg.array?.length) {writer.writeRepeatedString(34, msg.array);}
if (msg.type?.length) {writer.writeRepeatedEnum(35, msg.type);}
if (msg.format) {writer.writeString(36, msg.format);}
if (msg.enum?.length) {writer.writeRepeatedString(46, msg.enum);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<JSONSchema>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.ref) {json.ref = msg.ref;}
if (msg.title) {json.title = msg.title;}
if (msg.description) {json.description = msg.description;}
if (msg.default) {json.default = msg.default;}
if (msg.readOnly) {json.readOnly = msg.readOnly;}
if (msg.example) {json.example = msg.example;}
if (msg.multipleOf) {json.multipleOf = msg.multipleOf;}
if (msg.maximum) {json.maximum = msg.maximum;}
if (msg.exclusiveMaximum) {json.exclusiveMaximum = msg.exclusiveMaximum;}
if (msg.minimum) {json.minimum = msg.minimum;}
if (msg.exclusiveMinimum) {json.exclusiveMinimum = msg.exclusiveMinimum;}
if (msg.maxLength) {json.maxLength = msg.maxLength.toString();}
if (msg.minLength) {json.minLength = msg.minLength.toString();}
if (msg.pattern) {json.pattern = msg.pattern;}
if (msg.maxItems) {json.maxItems = msg.maxItems.toString();}
if (msg.minItems) {json.minItems = msg.minItems.toString();}
if (msg.uniqueItems) {json.uniqueItems = msg.uniqueItems;}
if (msg.maxProperties) {json.maxProperties = msg.maxProperties.toString();}
if (msg.minProperties) {json.minProperties = msg.minProperties.toString();}
if (msg.required?.length) {json.required = msg.required;}
if (msg.array?.length) {json.array = msg.array;}
if (msg.type?.length) {json.type = msg.type;}
if (msg.format) {json.format = msg.format;}
if (msg.enum?.length) {json.enum = msg.enum;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: JSONSchema, reader: BinaryReader): JSONSchema {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 3: {msg.ref = reader.readString();break;
}
case 5: {msg.title = reader.readString();break;
}
case 6: {msg.description = reader.readString();break;
}
case 7: {msg.default = reader.readString();break;
}
case 8: {msg.readOnly = reader.readBool();break;
}
case 9: {msg.example = reader.readString();break;
}
case 10: {msg.multipleOf = reader.readDouble();break;
}
case 11: {msg.maximum = reader.readDouble();break;
}
case 12: {msg.exclusiveMaximum = reader.readBool();break;
}
case 13: {msg.minimum = reader.readDouble();break;
}
case 14: {msg.exclusiveMinimum = reader.readBool();break;
}
case 15: {msg.maxLength = BigInt(reader.readUint64String());break;
}
case 16: {msg.minLength = BigInt(reader.readUint64String());break;
}
case 17: {msg.pattern = reader.readString();break;
}
case 20: {msg.maxItems = BigInt(reader.readUint64String());break;
}
case 21: {msg.minItems = BigInt(reader.readUint64String());break;
}
case 22: {msg.uniqueItems = reader.readBool();break;
}
case 24: {msg.maxProperties = BigInt(reader.readUint64String());break;
}
case 25: {msg.minProperties = BigInt(reader.readUint64String());break;
}
case 26: {msg.required.push(reader.readString());break;
}
case 34: {msg.array.push(reader.readString());break;
}
case 35: {msg.type.push(reader.readEnum() as JSONSchema.JSONSchemaSimpleTypes);break;
}
case 36: {msg.format = reader.readString();break;
}
case 46: {msg.enum.push(reader.readString());break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: JSONSchema, json: any): JSONSchema {
          const ref = json.ref ?? json.ref;if (ref) {msg.ref = ref;}
const title = json.title ?? json.title;if (title) {msg.title = title;}
const description = json.description ?? json.description;if (description) {msg.description = description;}
const default = json.default ?? json.default;if (default) {msg.default = default;}
const readOnly = json.readOnly ?? json.read_only;if (readOnly) {msg.readOnly = readOnly;}
const example = json.example ?? json.example;if (example) {msg.example = example;}
const multipleOf = json.multipleOf ?? json.multiple_of;if (multipleOf) {msg.multipleOf = multipleOf;}
const maximum = json.maximum ?? json.maximum;if (maximum) {msg.maximum = maximum;}
const exclusiveMaximum = json.exclusiveMaximum ?? json.exclusive_maximum;if (exclusiveMaximum) {msg.exclusiveMaximum = exclusiveMaximum;}
const minimum = json.minimum ?? json.minimum;if (minimum) {msg.minimum = minimum;}
const exclusiveMinimum = json.exclusiveMinimum ?? json.exclusive_minimum;if (exclusiveMinimum) {msg.exclusiveMinimum = exclusiveMinimum;}
const maxLength = json.maxLength ?? json.max_length;if (maxLength) {msg.maxLength = BigInt(maxLength);}
const minLength = json.minLength ?? json.min_length;if (minLength) {msg.minLength = BigInt(minLength);}
const pattern = json.pattern ?? json.pattern;if (pattern) {msg.pattern = pattern;}
const maxItems = json.maxItems ?? json.max_items;if (maxItems) {msg.maxItems = BigInt(maxItems);}
const minItems = json.minItems ?? json.min_items;if (minItems) {msg.minItems = BigInt(minItems);}
const uniqueItems = json.uniqueItems ?? json.unique_items;if (uniqueItems) {msg.uniqueItems = uniqueItems;}
const maxProperties = json.maxProperties ?? json.max_properties;if (maxProperties) {msg.maxProperties = BigInt(maxProperties);}
const minProperties = json.minProperties ?? json.min_properties;if (minProperties) {msg.minProperties = BigInt(minProperties);}
const required = json.required ?? json.required;if (required) {msg.required = required;}
const array = json.array ?? json.array;if (array) {msg.array = array;}
const type = json.type ?? json.type;if (type) {msg.type = type;}
const format = json.format ?? json.format;if (format) {msg.format = format;}
const enum = json.enum ?? json.enum;if (enum) {msg.enum = enum;}
          return msg;
        },

      JSONSchemaSimpleTypes: {UNKNOWN: 0,
ARRAY: 1,
BOOLEAN: 2,
INTEGER: 3,
NULL: 4,
NUMBER: 5,
OBJECT: 6,
STRING: 7,
} as const,

};

export const Tag = {        /**
         * Serializes a Tag to protobuf.
         */
        encode: function(tag: Partial<Tag>): Uint8Array {
          return Tag._writeMessage(tag, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Tag from protobuf.
         */
        decode: function(bytes: ByteSource): Tag {
          return Tag._readMessage(Tag.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Tag to JSON.
         */
        encodeJSON: function(tag: Partial<Tag>): string {
          return JSON.stringify(Tag._writeMessageJSON(tag));
        },
        

        /**
         * Deserializes a Tag from JSON.
         */
        decodeJSON: function(json: string): Tag {
          return Tag._readMessageJSON(Tag.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Tag with all fields set to their default value.
         */
        initialize: function(): Tag {
          return {
            description: '',externalDocs: ExternalDocumentation.initialize(),
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Tag>, writer: BinaryWriter): BinaryWriter {
          if (msg.description) {writer.writeString(2, msg.description);}
if (msg.externalDocs) {writer.writeMessage(3, msg.externalDocs , ExternalDocumentation._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Tag>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.description) {json.description = msg.description;}
if (msg.externalDocs) {const externalDocs = ExternalDocumentation._writeMessageJSON(msg.externalDocs);if (Object.keys(externalDocs).length > 0) {json.externalDocs = externalDocs;}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Tag, reader: BinaryReader): Tag {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 2: {msg.description = reader.readString();break;
}
case 3: {
                      reader.readMessage(msg.externalDocs, ExternalDocumentation._readMessage);
                    break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Tag, json: any): Tag {
          const description = json.description ?? json.description;if (description) {msg.description = description;}
const externalDocs = json.externalDocs ?? json.external_docs;if (externalDocs) {const m = ExternalDocumentation.initialize();ExternalDocumentation._readMessageJSON(m, externalDocs);msg.externalDocs = m;}
          return msg;
        },

      };

export const SecurityDefinitions = {        /**
         * Serializes a SecurityDefinitions to protobuf.
         */
        encode: function(securityDefinitions: Partial<SecurityDefinitions>): Uint8Array {
          return SecurityDefinitions._writeMessage(securityDefinitions, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a SecurityDefinitions from protobuf.
         */
        decode: function(bytes: ByteSource): SecurityDefinitions {
          return SecurityDefinitions._readMessage(SecurityDefinitions.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a SecurityDefinitions to JSON.
         */
        encodeJSON: function(securityDefinitions: Partial<SecurityDefinitions>): string {
          return JSON.stringify(SecurityDefinitions._writeMessageJSON(securityDefinitions));
        },
        

        /**
         * Deserializes a SecurityDefinitions from JSON.
         */
        decodeJSON: function(json: string): SecurityDefinitions {
          return SecurityDefinitions._readMessageJSON(SecurityDefinitions.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a SecurityDefinitions with all fields set to their default value.
         */
        initialize: function(): SecurityDefinitions {
          return {
            security: {},
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<SecurityDefinitions>, writer: BinaryWriter): BinaryWriter {
          if (msg.security) {for (const [key, value] of Object.entries(msg.security)) {
                  if (value) {
                    writer.writeMessage(1, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeMessage(2, value, SecurityScheme._writeMessage);})
}}}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<SecurityDefinitions>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.security) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.security)) {
                  if (value) {map[key] =SecurityScheme._writeMessageJSON(value);json.security = map}
}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: SecurityDefinitions, reader: BinaryReader): SecurityDefinitions {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = undefined;
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        reader.readMessage(SecurityScheme.initialize(), SecurityScheme._readMessage);break;
                          }
                        }
                      }
                      if (key) {
                        msg.security[key] = value;
                      }
                    });break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: SecurityDefinitions, json: any): SecurityDefinitions {
          const security = json.security ?? json.security;if (security) {for (const [key, value] of Object.entries<SecurityScheme>(security)) {msg.security[key] =SecurityScheme._readMessageJSON(SecurityScheme.initialize(), value);}}
          return msg;
        },

      };

export const SecurityScheme = {        /**
         * Serializes a SecurityScheme to protobuf.
         */
        encode: function(securityScheme: Partial<SecurityScheme>): Uint8Array {
          return SecurityScheme._writeMessage(securityScheme, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a SecurityScheme from protobuf.
         */
        decode: function(bytes: ByteSource): SecurityScheme {
          return SecurityScheme._readMessage(SecurityScheme.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a SecurityScheme to JSON.
         */
        encodeJSON: function(securityScheme: Partial<SecurityScheme>): string {
          return JSON.stringify(SecurityScheme._writeMessageJSON(securityScheme));
        },
        

        /**
         * Deserializes a SecurityScheme from JSON.
         */
        decodeJSON: function(json: string): SecurityScheme {
          return SecurityScheme._readMessageJSON(SecurityScheme.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a SecurityScheme with all fields set to their default value.
         */
        initialize: function(): SecurityScheme {
          return {
            type: 0,description: '',name: '',in: 0,flow: 0,authorizationUrl: '',tokenUrl: '',scopes: Scopes.initialize(),extensions: {},
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<SecurityScheme>, writer: BinaryWriter): BinaryWriter {
          if (msg.type) {writer.writeEnum(1, msg.type);}
if (msg.description) {writer.writeString(2, msg.description);}
if (msg.name) {writer.writeString(3, msg.name);}
if (msg.in) {writer.writeEnum(4, msg.in);}
if (msg.flow) {writer.writeEnum(5, msg.flow);}
if (msg.authorizationUrl) {writer.writeString(6, msg.authorizationUrl);}
if (msg.tokenUrl) {writer.writeString(7, msg.tokenUrl);}
if (msg.scopes) {writer.writeMessage(8, msg.scopes , Scopes._writeMessage);}
if (msg.extensions) {for (const [key, value] of Object.entries(msg.extensions)) {
                  if (value) {
                    writer.writeMessage(9, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeMessage(2, value, Value._writeMessage);})
}}}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<SecurityScheme>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.type) {json.type = msg.type;}
if (msg.description) {json.description = msg.description;}
if (msg.name) {json.name = msg.name;}
if (msg.in) {json.in = msg.in;}
if (msg.flow) {json.flow = msg.flow;}
if (msg.authorizationUrl) {json.authorizationUrl = msg.authorizationUrl;}
if (msg.tokenUrl) {json.tokenUrl = msg.tokenUrl;}
if (msg.scopes) {const scopes = Scopes._writeMessageJSON(msg.scopes);if (Object.keys(scopes).length > 0) {json.scopes = scopes;}}
if (msg.extensions) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.extensions)) {
                  if (value) {map[key] =Value._writeMessageJSON(value);json.extensions = map}
}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: SecurityScheme, reader: BinaryReader): SecurityScheme {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.type = reader.readEnum() as SecurityScheme.Type;break;
}
case 2: {msg.description = reader.readString();break;
}
case 3: {msg.name = reader.readString();break;
}
case 4: {msg.in = reader.readEnum() as SecurityScheme.In;break;
}
case 5: {msg.flow = reader.readEnum() as SecurityScheme.Flow;break;
}
case 6: {msg.authorizationUrl = reader.readString();break;
}
case 7: {msg.tokenUrl = reader.readString();break;
}
case 8: {
                      reader.readMessage(msg.scopes, Scopes._readMessage);
                    break;
}
case 9: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = undefined;
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        reader.readMessage(Value.initialize(), Value._readMessage);break;
                          }
                        }
                      }
                      if (key) {
                        msg.extensions[key] = value;
                      }
                    });break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: SecurityScheme, json: any): SecurityScheme {
          const type = json.type ?? json.type;if (type) {msg.type = type;}
const description = json.description ?? json.description;if (description) {msg.description = description;}
const name = json.name ?? json.name;if (name) {msg.name = name;}
const in = json.in ?? json.in;if (in) {msg.in = in;}
const flow = json.flow ?? json.flow;if (flow) {msg.flow = flow;}
const authorizationUrl = json.authorizationUrl ?? json.authorization_url;if (authorizationUrl) {msg.authorizationUrl = authorizationUrl;}
const tokenUrl = json.tokenUrl ?? json.token_url;if (tokenUrl) {msg.tokenUrl = tokenUrl;}
const scopes = json.scopes ?? json.scopes;if (scopes) {const m = Scopes.initialize();Scopes._readMessageJSON(m, scopes);msg.scopes = m;}
const extensions = json.extensions ?? json.extensions;if (extensions) {for (const [key, value] of Object.entries<Value>(extensions)) {msg.extensions[key] =Value._readMessageJSON(Value.initialize(), value);}}
          return msg;
        },

      Type: {TYPE_INVALID: 0,
TYPE_BASIC: 1,
TYPE_API_KEY: 2,
TYPE_OAUTH2: 3,
} as const,

In: {IN_INVALID: 0,
IN_QUERY: 1,
IN_HEADER: 2,
} as const,

Flow: {FLOW_INVALID: 0,
FLOW_IMPLICIT: 1,
FLOW_PASSWORD: 2,
FLOW_APPLICATION: 3,
FLOW_ACCESS_CODE: 4,
} as const,

};

export const SecurityRequirement = {        /**
         * Serializes a SecurityRequirement to protobuf.
         */
        encode: function(securityRequirement: Partial<SecurityRequirement>): Uint8Array {
          return SecurityRequirement._writeMessage(securityRequirement, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a SecurityRequirement from protobuf.
         */
        decode: function(bytes: ByteSource): SecurityRequirement {
          return SecurityRequirement._readMessage(SecurityRequirement.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a SecurityRequirement to JSON.
         */
        encodeJSON: function(securityRequirement: Partial<SecurityRequirement>): string {
          return JSON.stringify(SecurityRequirement._writeMessageJSON(securityRequirement));
        },
        

        /**
         * Deserializes a SecurityRequirement from JSON.
         */
        decodeJSON: function(json: string): SecurityRequirement {
          return SecurityRequirement._readMessageJSON(SecurityRequirement.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a SecurityRequirement with all fields set to their default value.
         */
        initialize: function(): SecurityRequirement {
          return {
            securityRequirement: {},
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<SecurityRequirement>, writer: BinaryWriter): BinaryWriter {
          if (msg.securityRequirement) {for (const [key, value] of Object.entries(msg.securityRequirement)) {
                  if (value) {
                    writer.writeMessage(1, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeMessage(2, value, SecurityRequirement.SecurityRequirementValue._writeMessage);})
}}}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<SecurityRequirement>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.securityRequirement) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.securityRequirement)) {
                  if (value) {map[key] =SecurityRequirement.SecurityRequirementValue._writeMessageJSON(value);json.securityRequirement = map}
}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: SecurityRequirement, reader: BinaryReader): SecurityRequirement {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = undefined;
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        reader.readMessage(SecurityRequirement.SecurityRequirementValue.initialize(), SecurityRequirement.SecurityRequirementValue._readMessage);break;
                          }
                        }
                      }
                      if (key) {
                        msg.securityRequirement[key] = value;
                      }
                    });break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: SecurityRequirement, json: any): SecurityRequirement {
          const securityRequirement = json.securityRequirement ?? json.security_requirement;if (securityRequirement) {for (const [key, value] of Object.entries<SecurityRequirement.SecurityRequirementValue>(securityRequirement)) {msg.securityRequirement[key] =SecurityRequirement.SecurityRequirementValue._readMessageJSON(SecurityRequirement.SecurityRequirementValue.initialize(), value);}}
          return msg;
        },

      SecurityRequirementValue: {        /**
         * Serializes a SecurityRequirement.SecurityRequirementValue to protobuf.
         */
        encode: function(securityRequirementValue: Partial<SecurityRequirement.SecurityRequirementValue>): Uint8Array {
          return SecurityRequirement.SecurityRequirementValue._writeMessage(securityRequirementValue, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a SecurityRequirement.SecurityRequirementValue from protobuf.
         */
        decode: function(bytes: ByteSource): SecurityRequirement.SecurityRequirementValue {
          return SecurityRequirement.SecurityRequirementValue._readMessage(SecurityRequirement.SecurityRequirementValue.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a SecurityRequirement.SecurityRequirementValue to JSON.
         */
        encodeJSON: function(securityRequirementValue: Partial<SecurityRequirement.SecurityRequirementValue>): string {
          return JSON.stringify(SecurityRequirement.SecurityRequirementValue._writeMessageJSON(securityRequirementValue));
        },
        

        /**
         * Deserializes a SecurityRequirement.SecurityRequirementValue from JSON.
         */
        decodeJSON: function(json: string): SecurityRequirement.SecurityRequirementValue {
          return SecurityRequirement.SecurityRequirementValue._readMessageJSON(SecurityRequirement.SecurityRequirementValue.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a SecurityRequirement.SecurityRequirementValue with all fields set to their default value.
         */
        initialize: function(): SecurityRequirement.SecurityRequirementValue {
          return {
            scope: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<SecurityRequirement.SecurityRequirementValue>, writer: BinaryWriter): BinaryWriter {
          if (msg.scope?.length) {writer.writeRepeatedString(1, msg.scope);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<SecurityRequirement.SecurityRequirementValue>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.scope?.length) {json.scope = msg.scope;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: SecurityRequirement.SecurityRequirementValue, reader: BinaryReader): SecurityRequirement.SecurityRequirementValue {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.scope.push(reader.readString());break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: SecurityRequirement.SecurityRequirementValue, json: any): SecurityRequirement.SecurityRequirementValue {
          const scope = json.scope ?? json.scope;if (scope) {msg.scope = scope;}
          return msg;
        },

      },

};

export const Scopes = {        /**
         * Serializes a Scopes to protobuf.
         */
        encode: function(scopes: Partial<Scopes>): Uint8Array {
          return Scopes._writeMessage(scopes, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Scopes from protobuf.
         */
        decode: function(bytes: ByteSource): Scopes {
          return Scopes._readMessage(Scopes.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Scopes to JSON.
         */
        encodeJSON: function(scopes: Partial<Scopes>): string {
          return JSON.stringify(Scopes._writeMessageJSON(scopes));
        },
        

        /**
         * Deserializes a Scopes from JSON.
         */
        decodeJSON: function(json: string): Scopes {
          return Scopes._readMessageJSON(Scopes.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Scopes with all fields set to their default value.
         */
        initialize: function(): Scopes {
          return {
            scope: {},
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Scopes>, writer: BinaryWriter): BinaryWriter {
          if (msg.scope) {for (const [key, value] of Object.entries(msg.scope)) {
                  if (value) {
                    writer.writeMessage(1, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeString(2, value);})
}}}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Scopes>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.scope) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.scope)) {
                  if (value) {map[key] =value;json.scope = map}
}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Scopes, reader: BinaryReader): Scopes {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = '';
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        value = reader.readString();break;
                          }
                        }
                      }
                      if (key) {
                        msg.scope[key] = value;
                      }
                    });break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Scopes, json: any): Scopes {
          const scope = json.scope ?? json.scope;if (scope) {for (const [key, value] of Object.entries<string>(scope)) {msg.scope[key] =value;}}
          return msg;
        },

      };


