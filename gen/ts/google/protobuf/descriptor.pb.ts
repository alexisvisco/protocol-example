// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/descriptor.proto


import type {
    ByteSource,

    } from 'twirpscript';
import {
  BinaryReader,
BinaryWriter,

  } from 'twirpscript';
  







  //========================================//
  //                 Types                  //
  //========================================//
  
  
    /**
     * The protocol compiler can output a FileDescriptorSet containing the .proto
 * files it parses.
     */
      export interface FileDescriptorSet {
file: FileDescriptorProto[];
}

    /**
     * Describes a complete .proto file.
     */
      export interface FileDescriptorProto {
name: string;
package: string;
    /**
     * Names of files imported by this file.
     */
      dependency: string[];
    /**
     * Indexes of the public imported files in the dependency list above.
     */
      publicDependency: number[];
    /**
     * Indexes of the weak imported files in the dependency list.
 * For Google-internal migration only. Do not use.
     */
      weakDependency: number[];
    /**
     * All top-level definitions in this file.
     */
      messageType: DescriptorProto[];
enumType: EnumDescriptorProto[];
service: ServiceDescriptorProto[];
extension: FieldDescriptorProto[];
options: FileOptions;
    /**
     * This field contains optional information about the original source code.
 * You may safely remove this entire field without harming runtime
 * functionality of the descriptors -- the information is needed only by
 * development tools.
     */
      sourceCodeInfo: SourceCodeInfo;
    /**
     * The syntax of the proto file.
 * The supported values are "proto2" and "proto3".
     */
      syntax: string;
}

    /**
     * Describes a message type.
     */
      export interface DescriptorProto {
name: string;
field: FieldDescriptorProto[];
extension: FieldDescriptorProto[];
nestedType: DescriptorProto[];
enumType: EnumDescriptorProto[];
extensionRange: DescriptorProto.ExtensionRange[];
oneofDecl: OneofDescriptorProto[];
options: MessageOptions;
reservedRange: DescriptorProto.ReservedRange[];
    /**
     * Reserved field names, which may not be used by fields in the same message.
 * A given name may only be reserved once.
     */
      reservedName: string[];
}

export namespace DescriptorProto { 
export interface ExtensionRange {
start: number;
end: number;
options: ExtensionRangeOptions;
}

    /**
     * Range of reserved tag numbers. Reserved tag numbers may not be used by
 * fields or extension ranges in the same message. Reserved ranges may
 * not overlap.
     */
      export interface ReservedRange {
start: number;
end: number;
}



}

export interface ExtensionRangeOptions {
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
      uninterpretedOption: UninterpretedOption[];
}

    /**
     * Describes a field within a message.
     */
      export interface FieldDescriptorProto {
name: string;
number: number;
label: FieldDescriptorProto.Label;
    /**
     * If type_name is set, this need not be set.  If both this and type_name
 * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     */
      type: FieldDescriptorProto.Type;
    /**
     * For message and enum types, this is the name of the type.  If the name
 * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
 * rules are used to find the type (i.e. first the nested types within this
 * message are searched, then within the parent, on up to the root
 * namespace).
     */
      typeName: string;
    /**
     * For extensions, this is the name of the type being extended.  It is
 * resolved in the same manner as type_name.
     */
      extendee: string;
    /**
     * For numeric types, contains the original text representation of the value.
 * For booleans, "true" or "false".
 * For strings, contains the default text contents (not escaped in any way).
 * For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
 * TODO(kenton):  Base-64 encode?
     */
      defaultValue: string;
    /**
     * If set, gives the index of a oneof in the containing type's oneof_decl
 * list.  This field is a member of that oneof.
     */
      oneofIndex: number;
    /**
     * JSON name of this field. The value is set by protocol compiler. If the
 * user has set a "json_name" option on this field, that option's value
 * will be used. Otherwise, it's deduced from the field's name by converting
 * it to camelCase.
     */
      jsonName: string;
options: FieldOptions;
    /**
     * If true, this is a proto3 "optional". When a proto3 field is optional, it
 * tracks presence regardless of field type.
 *
 * When proto3_optional is true, this field must be belong to a oneof to
 * signal to old proto3 clients that presence is tracked for this field. This
 * oneof is known as a "synthetic" oneof, and this field must be its sole
 * member (each proto3 optional field gets its own synthetic oneof). Synthetic
 * oneofs exist in the descriptor only, and do not generate any API. Synthetic
 * oneofs must be ordered after all "real" oneofs.
 *
 * For message fields, proto3_optional doesn't create any semantic change,
 * since non-repeated message fields always track presence. However it still
 * indicates the semantic detail of whether the user wrote "optional" or not.
 * This can be useful for round-tripping the .proto file. For consistency we
 * give message fields a synthetic oneof also, even though it is not required
 * to track presence. This is especially important because the parser can't
 * tell if a field is a message or an enum, so it must always create a
 * synthetic oneof.
 *
 * Proto2 optional fields do not set this flag, because they already indicate
 * optional with `LABEL_OPTIONAL`.
     */
      proto3Optional: boolean;
}

export namespace FieldDescriptorProto { 
export type Type = typeof FieldDescriptorProto.Type[keyof typeof FieldDescriptorProto.Type];

export type Label = typeof FieldDescriptorProto.Label[keyof typeof FieldDescriptorProto.Label];



}

    /**
     * Describes a oneof.
     */
      export interface OneofDescriptorProto {
name: string;
options: OneofOptions;
}

    /**
     * Describes an enum type.
     */
      export interface EnumDescriptorProto {
name: string;
value: EnumValueDescriptorProto[];
options: EnumOptions;
    /**
     * Range of reserved numeric values. Reserved numeric values may not be used
 * by enum values in the same enum declaration. Reserved ranges may not
 * overlap.
     */
      reservedRange: EnumDescriptorProto.EnumReservedRange[];
    /**
     * Reserved enum value names, which may not be reused. A given name may only
 * be reserved once.
     */
      reservedName: string[];
}

export namespace EnumDescriptorProto { 
    /**
     * Range of reserved numeric values. Reserved values may not be used by
 * entries in the same enum. Reserved ranges may not overlap.
 *
 * Note that this is distinct from DescriptorProto.ReservedRange in that it
 * is inclusive such that it can appropriately represent the entire int32
 * domain.
     */
      export interface EnumReservedRange {
start: number;
end: number;
}



}

    /**
     * Describes a value within an enum.
     */
      export interface EnumValueDescriptorProto {
name: string;
number: number;
options: EnumValueOptions;
}

    /**
     * Describes a service.
     */
      export interface ServiceDescriptorProto {
name: string;
method: MethodDescriptorProto[];
options: ServiceOptions;
}

    /**
     * Describes a method of a service.
     */
      export interface MethodDescriptorProto {
name: string;
    /**
     * Input and output type names.  These are resolved in the same way as
 * FieldDescriptorProto.type_name, but must refer to a message type.
     */
      inputType: string;
outputType: string;
options: MethodOptions;
    /**
     * Identifies if client streams multiple client messages
     */
      clientStreaming: boolean;
    /**
     * Identifies if server streams multiple server messages
     */
      serverStreaming: boolean;
}

export interface FileOptions {
    /**
     * Sets the Java package where classes generated from this .proto will be
 * placed.  By default, the proto package is used, but this is often
 * inappropriate because proto packages do not normally start with backwards
 * domain names.
     */
      javaPackage: string;
    /**
     * Controls the name of the wrapper Java class generated for the .proto file.
 * That class will always contain the .proto file's getDescriptor() method as
 * well as any top-level extensions defined in the .proto file.
 * If java_multiple_files is disabled, then all the other classes from the
 * .proto file will be nested inside the single wrapper outer class.
     */
      javaOuterClassname: string;
    /**
     * If enabled, then the Java code generator will generate a separate .java
 * file for each top-level message, enum, and service defined in the .proto
 * file.  Thus, these types will *not* be nested inside the wrapper class
 * named by java_outer_classname.  However, the wrapper class will still be
 * generated to contain the file's getDescriptor() method as well as any
 * top-level extensions defined in the file.
     */
      javaMultipleFiles: boolean;
    /**
     * This option does nothing.
     */
      javaGenerateEqualsAndHash: boolean;
    /**
     * If set true, then the Java2 code generator will generate code that
 * throws an exception whenever an attempt is made to assign a non-UTF-8
 * byte sequence to a string field.
 * Message reflection will do the same.
 * However, an extension field still accepts non-UTF-8 byte sequences.
 * This option has no effect on when used with the lite runtime.
     */
      javaStringCheckUtf8: boolean;
optimizeFor: FileOptions.OptimizeMode;
    /**
     * Sets the Go package where structs generated from this .proto will be
 * placed. If omitted, the Go package will be derived from the following:
 *   - The basename of the package import path, if provided.
 *   - Otherwise, the package statement in the .proto file, if present.
 *   - Otherwise, the basename of the .proto file, without extension.
     */
      goPackage: string;
    /**
     * Should generic services be generated in each language?  "Generic" services
 * are not specific to any particular RPC system.  They are generated by the
 * main code generators in each language (without additional plugins).
 * Generic services were the only kind of service generation supported by
 * early versions of google.protobuf.
 *
 * Generic services are now considered deprecated in favor of using plugins
 * that generate code specific to your particular RPC system.  Therefore,
 * these default to false.  Old code which depends on generic services should
 * explicitly set them to true.
     */
      ccGenericServices: boolean;
javaGenericServices: boolean;
pyGenericServices: boolean;
phpGenericServices: boolean;
    /**
     * Is this file deprecated?
 * Depending on the target platform, this can emit Deprecated annotations
 * for everything in the file, or it will be completely ignored; in the very
 * least, this is a formalization for deprecating files.
     */
      deprecated: boolean;
    /**
     * Enables the use of arenas for the proto messages in this file. This applies
 * only to generated classes for C++.
     */
      ccEnableArenas: boolean;
    /**
     * Sets the objective c class prefix which is prepended to all objective c
 * generated classes from this .proto. There is no default.
     */
      objcClassPrefix: string;
    /**
     * Namespace for generated classes; defaults to the package.
     */
      csharpNamespace: string;
    /**
     * By default Swift generators will take the proto package and CamelCase it
 * replacing '.' with underscore and use that to prefix the types/symbols
 * defined. When this options is provided, they will use this value instead
 * to prefix the types/symbols defined.
     */
      swiftPrefix: string;
    /**
     * Sets the php class prefix which is prepended to all php generated classes
 * from this .proto. Default is empty.
     */
      phpClassPrefix: string;
    /**
     * Use this option to change the namespace of php generated classes. Default
 * is empty. When this option is empty, the package name will be used for
 * determining the namespace.
     */
      phpNamespace: string;
    /**
     * Use this option to change the namespace of php generated metadata classes.
 * Default is empty. When this option is empty, the proto file name will be
 * used for determining the namespace.
     */
      phpMetadataNamespace: string;
    /**
     * Use this option to change the package of ruby generated classes. Default
 * is empty. When this option is not set, the package name will be used for
 * determining the ruby package.
     */
      rubyPackage: string;
    /**
     * The parser stores options it doesn't recognize here.
 * See the documentation for the "Options" section above.
     */
      uninterpretedOption: UninterpretedOption[];
}

export namespace FileOptions { 
    /**
     * Generated classes can be optimized for speed or code size.
     */
      export type OptimizeMode = typeof FileOptions.OptimizeMode[keyof typeof FileOptions.OptimizeMode];



}

export interface MessageOptions {
    /**
     * Set true to use the old proto1 MessageSet wire format for extensions.
 * This is provided for backwards-compatibility with the MessageSet wire
 * format.  You should not use this for any other reason:  It's less
 * efficient, has fewer features, and is more complicated.
 *
 * The message must be defined exactly as follows:
 *   message Foo {
 *     option message_set_wire_format = true;
 *     extensions 4 to max;
 *   }
 * Note that the message cannot have any defined fields; MessageSets only
 * have extensions.
 *
 * All extensions of your type must be singular messages; e.g. they cannot
 * be int32s, enums, or repeated messages.
 *
 * Because this is an option, the above two restrictions are not enforced by
 * the protocol compiler.
     */
      messageSetWireFormat: boolean;
    /**
     * Disables the generation of the standard "descriptor()" accessor, which can
 * conflict with a field of the same name.  This is meant to make migration
 * from proto1 easier; new code should avoid fields named "descriptor".
     */
      noStandardDescriptorAccessor: boolean;
    /**
     * Is this message deprecated?
 * Depending on the target platform, this can emit Deprecated annotations
 * for the message, or it will be completely ignored; in the very least,
 * this is a formalization for deprecating messages.
     */
      deprecated: boolean;
    /**
     * Whether the message is an automatically generated map entry type for the
 * maps field.
 *
 * For maps fields:
 *     map<KeyType, ValueType> map_field = 1;
 * The parsed descriptor looks like:
 *     message MapFieldEntry {
 *         option map_entry = true;
 *         optional KeyType key = 1;
 *         optional ValueType value = 2;
 *     }
 *     repeated MapFieldEntry map_field = 1;
 *
 * Implementations may choose not to generate the map_entry=true message, but
 * use a native map in the target language to hold the keys and values.
 * The reflection APIs in such implementations still need to work as
 * if the field is a repeated message field.
 *
 * NOTE: Do not set the option in .proto files. Always use the maps syntax
 * instead. The option should only be implicitly set by the proto compiler
 * parser.
     */
      mapEntry: boolean;
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
      uninterpretedOption: UninterpretedOption[];
}

export interface FieldOptions {
    /**
     * The ctype option instructs the C++ code generator to use a different
 * representation of the field than it normally would.  See the specific
 * options below.  This option is not yet implemented in the open source
 * release -- sorry, we'll try to include it in a future version!
     */
      ctype: FieldOptions.CType;
    /**
     * The packed option can be enabled for repeated primitive fields to enable
 * a more efficient representation on the wire. Rather than repeatedly
 * writing the tag and type for each element, the entire array is encoded as
 * a single length-delimited blob. In proto3, only explicit setting it to
 * false will avoid using packed encoding.
     */
      packed: boolean;
    /**
     * The jstype option determines the JavaScript type used for values of the
 * field.  The option is permitted only for 64 bit integral and fixed types
 * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
 * is represented as JavaScript string, which avoids loss of precision that
 * can happen when a large value is converted to a floating point JavaScript.
 * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
 * use the JavaScript "number" type.  The behavior of the default option
 * JS_NORMAL is implementation dependent.
 *
 * This option is an enum to permit additional types to be added, e.g.
 * goog.math.Integer.
     */
      jstype: FieldOptions.JSType;
    /**
     * Should this field be parsed lazily?  Lazy applies only to message-type
 * fields.  It means that when the outer message is initially parsed, the
 * inner message's contents will not be parsed but instead stored in encoded
 * form.  The inner message will actually be parsed when it is first accessed.
 *
 * This is only a hint.  Implementations are free to choose whether to use
 * eager or lazy parsing regardless of the value of this option.  However,
 * setting this option true suggests that the protocol author believes that
 * using lazy parsing on this field is worth the additional bookkeeping
 * overhead typically needed to implement it.
 *
 * This option does not affect the public interface of any generated code;
 * all method signatures remain the same.  Furthermore, thread-safety of the
 * interface is not affected by this option; const methods remain safe to
 * call from multiple threads concurrently, while non-const methods continue
 * to require exclusive access.
 *
 *
 * Note that implementations may choose not to check required fields within
 * a lazy sub-message.  That is, calling IsInitialized() on the outer message
 * may return true even if the inner message has missing required fields.
 * This is necessary because otherwise the inner message would have to be
 * parsed in order to perform the check, defeating the purpose of lazy
 * parsing.  An implementation which chooses not to check required fields
 * must be consistent about it.  That is, for any particular sub-message, the
 * implementation must either *always* check its required fields, or *never*
 * check its required fields, regardless of whether or not the message has
 * been parsed.
     */
      lazy: boolean;
    /**
     * Is this field deprecated?
 * Depending on the target platform, this can emit Deprecated annotations
 * for accessors, or it will be completely ignored; in the very least, this
 * is a formalization for deprecating fields.
     */
      deprecated: boolean;
    /**
     * For Google-internal migration only. Do not use.
     */
      weak: boolean;
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
      uninterpretedOption: UninterpretedOption[];
}

export namespace FieldOptions { 
export type CType = typeof FieldOptions.CType[keyof typeof FieldOptions.CType];

export type JSType = typeof FieldOptions.JSType[keyof typeof FieldOptions.JSType];



}

export interface OneofOptions {
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
      uninterpretedOption: UninterpretedOption[];
}

export interface EnumOptions {
    /**
     * Set this option to true to allow mapping different tag names to the same
 * value.
     */
      allowAlias: boolean;
    /**
     * Is this enum deprecated?
 * Depending on the target platform, this can emit Deprecated annotations
 * for the enum, or it will be completely ignored; in the very least, this
 * is a formalization for deprecating enums.
     */
      deprecated: boolean;
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
      uninterpretedOption: UninterpretedOption[];
}

export interface EnumValueOptions {
    /**
     * Is this enum value deprecated?
 * Depending on the target platform, this can emit Deprecated annotations
 * for the enum value, or it will be completely ignored; in the very least,
 * this is a formalization for deprecating enum values.
     */
      deprecated: boolean;
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
      uninterpretedOption: UninterpretedOption[];
}

export interface ServiceOptions {
    /**
     * Is this service deprecated?
 * Depending on the target platform, this can emit Deprecated annotations
 * for the service, or it will be completely ignored; in the very least,
 * this is a formalization for deprecating services.
     */
      deprecated: boolean;
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
      uninterpretedOption: UninterpretedOption[];
}

export interface MethodOptions {
    /**
     * Is this method deprecated?
 * Depending on the target platform, this can emit Deprecated annotations
 * for the method, or it will be completely ignored; in the very least,
 * this is a formalization for deprecating methods.
     */
      deprecated: boolean;
idempotencyLevel: MethodOptions.IdempotencyLevel;
    /**
     * The parser stores options it doesn't recognize here. See above.
     */
      uninterpretedOption: UninterpretedOption[];
}

export namespace MethodOptions { 
    /**
     * Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
 * or neither? HTTP based RPC implementation may choose GET verb for safe
 * methods, and PUT verb for idempotent methods instead of the default POST.
     */
      export type IdempotencyLevel = typeof MethodOptions.IdempotencyLevel[keyof typeof MethodOptions.IdempotencyLevel];



}

    /**
     * A message representing a option the parser does not recognize. This only
 * appears in options protos created by the compiler::Parser class.
 * DescriptorPool resolves these when building Descriptor objects. Therefore,
 * options protos in descriptor objects (e.g. returned by Descriptor::options(),
 * or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
 * in them.
     */
      export interface UninterpretedOption {
name: UninterpretedOption.NamePart[];
    /**
     * The value of the uninterpreted option, in whatever type the tokenizer
 * identified it as during parsing. Exactly one of these should be set.
     */
      identifierValue: string;
positiveIntValue: bigint;
negativeIntValue: bigint;
doubleValue: number;
stringValue: Uint8Array;
aggregateValue: string;
}

export namespace UninterpretedOption { 
    /**
     * The name of the uninterpreted option.  Each string represents a segment in
 * a dot-separated name.  is_extension is true iff a segment represents an
 * extension (denoted with parentheses in options specs in .proto files).
 * E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
 * "foo.(bar.baz).qux".
     */
      export interface NamePart {
namePart: string;
isExtension: boolean;
}



}

    /**
     * Encapsulates information about the original source file from which a
 * FileDescriptorProto was generated.
     */
      export interface SourceCodeInfo {
    /**
     * A Location identifies a piece of source code in a .proto file which
 * corresponds to a particular definition.  This information is intended
 * to be useful to IDEs, code indexers, documentation generators, and similar
 * tools.
 *
 * For example, say we have a file like:
 *   message Foo {
 *     optional string foo = 1;
 *   }
 * Let's look at just the field definition:
 *   optional string foo = 1;
 *   ^       ^^     ^^  ^  ^^^
 *   a       bc     de  f  ghi
 * We have the following locations:
 *   span   path               represents
 *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
 *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
 *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
 *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
 *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
 *
 * Notes:
 * - A location may refer to a repeated field itself (i.e. not to any
 *   particular index within it).  This is used whenever a set of elements are
 *   logically enclosed in a single code segment.  For example, an entire
 *   extend block (possibly containing multiple extension definitions) will
 *   have an outer location whose path refers to the "extensions" repeated
 *   field without an index.
 * - Multiple locations may have the same path.  This happens when a single
 *   logical declaration is spread out across multiple places.  The most
 *   obvious example is the "extend" block again -- there may be multiple
 *   extend blocks in the same scope, each of which will have the same path.
 * - A location's span is not always a subset of its parent's span.  For
 *   example, the "extendee" of an extension declaration appears at the
 *   beginning of the "extend" block and is shared by all extensions within
 *   the block.
 * - Just because a location's span is a subset of some other location's span
 *   does not mean that it is a descendant.  For example, a "group" defines
 *   both a type and a field in a single declaration.  Thus, the locations
 *   corresponding to the type and field and their components will overlap.
 * - Code which tries to interpret locations should probably be designed to
 *   ignore those that it doesn't understand, as more types of locations could
 *   be recorded in the future.
     */
      location: SourceCodeInfo.Location[];
}

export namespace SourceCodeInfo { 
export interface Location {
    /**
     * Identifies which part of the FileDescriptorProto was defined at this
 * location.
 *
 * Each element is a field number or an index.  They form a path from
 * the root FileDescriptorProto to the place where the definition.  For
 * example, this path:
 *   [ 4, 3, 2, 7, 1 ]
 * refers to:
 *   file.message_type(3)  // 4, 3
 *       .field(7)         // 2, 7
 *       .name()           // 1
 * This is because FileDescriptorProto.message_type has field number 4:
 *   repeated DescriptorProto message_type = 4;
 * and DescriptorProto.field has field number 2:
 *   repeated FieldDescriptorProto field = 2;
 * and FieldDescriptorProto.name has field number 1:
 *   optional string name = 1;
 *
 * Thus, the above path gives the location of a field name.  If we removed
 * the last element:
 *   [ 4, 3, 2, 7 ]
 * this path refers to the whole field declaration (from the beginning
 * of the label to the terminating semicolon).
     */
      path: number[];
    /**
     * Always has exactly three or four elements: start line, start column,
 * end line (optional, otherwise assumed same as start line), end column.
 * These are packed into a single field for efficiency.  Note that line
 * and column numbers are zero-based -- typically you will want to add
 * 1 to each before displaying to a user.
     */
      span: number[];
    /**
     * If this SourceCodeInfo represents a complete declaration, these are any
 * comments appearing before and after the declaration which appear to be
 * attached to the declaration.
 *
 * A series of line comments appearing on consecutive lines, with no other
 * tokens appearing on those lines, will be treated as a single comment.
 *
 * leading_detached_comments will keep paragraphs of comments that appear
 * before (but not connected to) the current element. Each paragraph,
 * separated by empty lines, will be one comment element in the repeated
 * field.
 *
 * Only the comment content is provided; comment markers (e.g. //) are
 * stripped out.  For block comments, leading whitespace and an asterisk
 * will be stripped from the beginning of each line other than the first.
 * Newlines are included in the output.
 *
 * Examples:
 *
 *   optional int32 foo = 1;  // Comment attached to foo.
 *   // Comment attached to bar.
 *   optional int32 bar = 2;
 *
 *   optional string baz = 3;
 *   // Comment attached to baz.
 *   // Another line attached to baz.
 *
 *   // Comment attached to qux.
 *   //
 *   // Another line attached to qux.
 *   optional double qux = 4;
 *
 *   // Detached comment for corge. This is not leading or trailing comments
 *   // to qux or corge because there are blank lines separating it from
 *   // both.
 *
 *   // Detached comment for corge paragraph 2.
 *
 *   optional string corge = 5;
 *   /* Block comment attached
 *    * to corge.  Leading asterisks
 *    * will be removed. *\/
 *   /* Block comment attached to
 *    * grault. */
 *   optional int32 grault = 6;
 *
 *   // ignored detached comments.
     */
      leadingComments: string;
trailingComments: string;
leadingDetachedComments: string[];
}



}

    /**
     * Describes the relationship between generated code and its original source
 * file. A GeneratedCodeInfo message is associated with only one generated
 * source file, but may contain references to different source .proto files.
     */
      export interface GeneratedCodeInfo {
    /**
     * An Annotation connects some span of text in generated code to an element
 * of its generating .proto file.
     */
      annotation: GeneratedCodeInfo.Annotation[];
}

export namespace GeneratedCodeInfo { 
export interface Annotation {
    /**
     * Identifies the element in the original source .proto file. This field
 * is formatted the same as SourceCodeInfo.Location.path.
     */
      path: number[];
    /**
     * Identifies the filesystem path to the original source .proto.
     */
      sourceFile: string;
    /**
     * Identifies the starting offset in bytes in the generated code
 * that relates to the identified object.
     */
      begin: number;
    /**
     * Identifies the ending offset in bytes in the generated code that
 * relates to the identified offset. The end offset should be one past
 * the last relevant byte (so the length of the text = end - begin).
     */
      end: number;
}



}


  //========================================//
  //        Protobuf Encode / Decode        //
  //========================================//
  
  
export const FileDescriptorSet = {        /**
         * Serializes a FileDescriptorSet to protobuf.
         */
        encode: function(fileDescriptorSet: Partial<FileDescriptorSet>): Uint8Array {
          return FileDescriptorSet._writeMessage(fileDescriptorSet, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a FileDescriptorSet from protobuf.
         */
        decode: function(bytes: ByteSource): FileDescriptorSet {
          return FileDescriptorSet._readMessage(FileDescriptorSet.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a FileDescriptorSet to JSON.
         */
        encodeJSON: function(fileDescriptorSet: Partial<FileDescriptorSet>): string {
          return JSON.stringify(FileDescriptorSet._writeMessageJSON(fileDescriptorSet));
        },
        

        /**
         * Deserializes a FileDescriptorSet from JSON.
         */
        decodeJSON: function(json: string): FileDescriptorSet {
          return FileDescriptorSet._readMessageJSON(FileDescriptorSet.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a FileDescriptorSet with all fields set to their default value.
         */
        initialize: function(): FileDescriptorSet {
          return {
            file: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<FileDescriptorSet>, writer: BinaryWriter): BinaryWriter {
          if (msg.file?.length) {writer.writeRepeatedMessage(1, msg.file as any, FileDescriptorProto._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<FileDescriptorSet>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.file?.length) {json.file = msg.file.map(FileDescriptorProto._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: FileDescriptorSet, reader: BinaryReader): FileDescriptorSet {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {const m = FileDescriptorProto.initialize();reader.readMessage(m, FileDescriptorProto._readMessage);msg.file.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: FileDescriptorSet, json: any): FileDescriptorSet {
          const file = json.file ?? json.file;if (file) {for (const item of file) {const m = FileDescriptorProto.initialize();FileDescriptorProto._readMessageJSON(m, item);msg.file.push(m);}}
          return msg;
        },

      };

export const FileDescriptorProto = {        /**
         * Serializes a FileDescriptorProto to protobuf.
         */
        encode: function(fileDescriptorProto: Partial<FileDescriptorProto>): Uint8Array {
          return FileDescriptorProto._writeMessage(fileDescriptorProto, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a FileDescriptorProto from protobuf.
         */
        decode: function(bytes: ByteSource): FileDescriptorProto {
          return FileDescriptorProto._readMessage(FileDescriptorProto.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a FileDescriptorProto to JSON.
         */
        encodeJSON: function(fileDescriptorProto: Partial<FileDescriptorProto>): string {
          return JSON.stringify(FileDescriptorProto._writeMessageJSON(fileDescriptorProto));
        },
        

        /**
         * Deserializes a FileDescriptorProto from JSON.
         */
        decodeJSON: function(json: string): FileDescriptorProto {
          return FileDescriptorProto._readMessageJSON(FileDescriptorProto.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a FileDescriptorProto with all fields set to their default value.
         */
        initialize: function(): FileDescriptorProto {
          return {
            name: '',package: '',dependency: [],publicDependency: [],weakDependency: [],messageType: [],enumType: [],service: [],extension: [],options: FileOptions.initialize(),sourceCodeInfo: SourceCodeInfo.initialize(),syntax: '',
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<FileDescriptorProto>, writer: BinaryWriter): BinaryWriter {
          if (msg.name) {writer.writeString(1, msg.name);}
if (msg.package) {writer.writeString(2, msg.package);}
if (msg.dependency?.length) {writer.writeRepeatedString(3, msg.dependency);}
if (msg.publicDependency?.length) {writer.writeRepeatedInt32(10, msg.publicDependency);}
if (msg.weakDependency?.length) {writer.writeRepeatedInt32(11, msg.weakDependency);}
if (msg.messageType?.length) {writer.writeRepeatedMessage(4, msg.messageType as any, DescriptorProto._writeMessage);}
if (msg.enumType?.length) {writer.writeRepeatedMessage(5, msg.enumType as any, EnumDescriptorProto._writeMessage);}
if (msg.service?.length) {writer.writeRepeatedMessage(6, msg.service as any, ServiceDescriptorProto._writeMessage);}
if (msg.extension?.length) {writer.writeRepeatedMessage(7, msg.extension as any, FieldDescriptorProto._writeMessage);}
if (msg.options) {writer.writeMessage(8, msg.options , FileOptions._writeMessage);}
if (msg.sourceCodeInfo) {writer.writeMessage(9, msg.sourceCodeInfo , SourceCodeInfo._writeMessage);}
if (msg.syntax) {writer.writeString(12, msg.syntax);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<FileDescriptorProto>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name) {json.name = msg.name;}
if (msg.package) {json.package = msg.package;}
if (msg.dependency?.length) {json.dependency = msg.dependency;}
if (msg.publicDependency?.length) {json.publicDependency = msg.publicDependency;}
if (msg.weakDependency?.length) {json.weakDependency = msg.weakDependency;}
if (msg.messageType?.length) {json.messageType = msg.messageType.map(DescriptorProto._writeMessageJSON)}
if (msg.enumType?.length) {json.enumType = msg.enumType.map(EnumDescriptorProto._writeMessageJSON)}
if (msg.service?.length) {json.service = msg.service.map(ServiceDescriptorProto._writeMessageJSON)}
if (msg.extension?.length) {json.extension = msg.extension.map(FieldDescriptorProto._writeMessageJSON)}
if (msg.options) {const options = FileOptions._writeMessageJSON(msg.options);if (Object.keys(options).length > 0) {json.options = options;}}
if (msg.sourceCodeInfo) {const sourceCodeInfo = SourceCodeInfo._writeMessageJSON(msg.sourceCodeInfo);if (Object.keys(sourceCodeInfo).length > 0) {json.sourceCodeInfo = sourceCodeInfo;}}
if (msg.syntax) {json.syntax = msg.syntax;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: FileDescriptorProto, reader: BinaryReader): FileDescriptorProto {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.name = reader.readString();break;
}
case 2: {msg.package = reader.readString();break;
}
case 3: {msg.dependency.push(reader.readString());break;
}
case 10: {msg.publicDependency.push(reader.readInt32());break;
}
case 11: {msg.weakDependency.push(reader.readInt32());break;
}
case 4: {const m = DescriptorProto.initialize();reader.readMessage(m, DescriptorProto._readMessage);msg.messageType.push(m);break;
}
case 5: {const m = EnumDescriptorProto.initialize();reader.readMessage(m, EnumDescriptorProto._readMessage);msg.enumType.push(m);break;
}
case 6: {const m = ServiceDescriptorProto.initialize();reader.readMessage(m, ServiceDescriptorProto._readMessage);msg.service.push(m);break;
}
case 7: {const m = FieldDescriptorProto.initialize();reader.readMessage(m, FieldDescriptorProto._readMessage);msg.extension.push(m);break;
}
case 8: {
                      reader.readMessage(msg.options, FileOptions._readMessage);
                    break;
}
case 9: {
                      reader.readMessage(msg.sourceCodeInfo, SourceCodeInfo._readMessage);
                    break;
}
case 12: {msg.syntax = reader.readString();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: FileDescriptorProto, json: any): FileDescriptorProto {
          const name = json.name ?? json.name;if (name) {msg.name = name;}
const package = json.package ?? json.package;if (package) {msg.package = package;}
const dependency = json.dependency ?? json.dependency;if (dependency) {msg.dependency = dependency;}
const publicDependency = json.publicDependency ?? json.public_dependency;if (publicDependency) {msg.publicDependency = publicDependency;}
const weakDependency = json.weakDependency ?? json.weak_dependency;if (weakDependency) {msg.weakDependency = weakDependency;}
const messageType = json.messageType ?? json.message_type;if (messageType) {for (const item of messageType) {const m = DescriptorProto.initialize();DescriptorProto._readMessageJSON(m, item);msg.messageType.push(m);}}
const enumType = json.enumType ?? json.enum_type;if (enumType) {for (const item of enumType) {const m = EnumDescriptorProto.initialize();EnumDescriptorProto._readMessageJSON(m, item);msg.enumType.push(m);}}
const service = json.service ?? json.service;if (service) {for (const item of service) {const m = ServiceDescriptorProto.initialize();ServiceDescriptorProto._readMessageJSON(m, item);msg.service.push(m);}}
const extension = json.extension ?? json.extension;if (extension) {for (const item of extension) {const m = FieldDescriptorProto.initialize();FieldDescriptorProto._readMessageJSON(m, item);msg.extension.push(m);}}
const options = json.options ?? json.options;if (options) {const m = FileOptions.initialize();FileOptions._readMessageJSON(m, options);msg.options = m;}
const sourceCodeInfo = json.sourceCodeInfo ?? json.source_code_info;if (sourceCodeInfo) {const m = SourceCodeInfo.initialize();SourceCodeInfo._readMessageJSON(m, sourceCodeInfo);msg.sourceCodeInfo = m;}
const syntax = json.syntax ?? json.syntax;if (syntax) {msg.syntax = syntax;}
          return msg;
        },

      };

export const DescriptorProto = {        /**
         * Serializes a DescriptorProto to protobuf.
         */
        encode: function(descriptorProto: Partial<DescriptorProto>): Uint8Array {
          return DescriptorProto._writeMessage(descriptorProto, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a DescriptorProto from protobuf.
         */
        decode: function(bytes: ByteSource): DescriptorProto {
          return DescriptorProto._readMessage(DescriptorProto.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a DescriptorProto to JSON.
         */
        encodeJSON: function(descriptorProto: Partial<DescriptorProto>): string {
          return JSON.stringify(DescriptorProto._writeMessageJSON(descriptorProto));
        },
        

        /**
         * Deserializes a DescriptorProto from JSON.
         */
        decodeJSON: function(json: string): DescriptorProto {
          return DescriptorProto._readMessageJSON(DescriptorProto.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a DescriptorProto with all fields set to their default value.
         */
        initialize: function(): DescriptorProto {
          return {
            name: '',field: [],extension: [],nestedType: [],enumType: [],extensionRange: [],oneofDecl: [],options: MessageOptions.initialize(),reservedRange: [],reservedName: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<DescriptorProto>, writer: BinaryWriter): BinaryWriter {
          if (msg.name) {writer.writeString(1, msg.name);}
if (msg.field?.length) {writer.writeRepeatedMessage(2, msg.field as any, FieldDescriptorProto._writeMessage);}
if (msg.extension?.length) {writer.writeRepeatedMessage(6, msg.extension as any, FieldDescriptorProto._writeMessage);}
if (msg.nestedType?.length) {writer.writeRepeatedMessage(3, msg.nestedType as any, DescriptorProto._writeMessage);}
if (msg.enumType?.length) {writer.writeRepeatedMessage(4, msg.enumType as any, EnumDescriptorProto._writeMessage);}
if (msg.extensionRange?.length) {writer.writeRepeatedMessage(5, msg.extensionRange as any, DescriptorProto.ExtensionRange._writeMessage);}
if (msg.oneofDecl?.length) {writer.writeRepeatedMessage(8, msg.oneofDecl as any, OneofDescriptorProto._writeMessage);}
if (msg.options) {writer.writeMessage(7, msg.options , MessageOptions._writeMessage);}
if (msg.reservedRange?.length) {writer.writeRepeatedMessage(9, msg.reservedRange as any, DescriptorProto.ReservedRange._writeMessage);}
if (msg.reservedName?.length) {writer.writeRepeatedString(10, msg.reservedName);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<DescriptorProto>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name) {json.name = msg.name;}
if (msg.field?.length) {json.field = msg.field.map(FieldDescriptorProto._writeMessageJSON)}
if (msg.extension?.length) {json.extension = msg.extension.map(FieldDescriptorProto._writeMessageJSON)}
if (msg.nestedType?.length) {json.nestedType = msg.nestedType.map(DescriptorProto._writeMessageJSON)}
if (msg.enumType?.length) {json.enumType = msg.enumType.map(EnumDescriptorProto._writeMessageJSON)}
if (msg.extensionRange?.length) {json.extensionRange = msg.extensionRange.map(DescriptorProto.ExtensionRange._writeMessageJSON)}
if (msg.oneofDecl?.length) {json.oneofDecl = msg.oneofDecl.map(OneofDescriptorProto._writeMessageJSON)}
if (msg.options) {const options = MessageOptions._writeMessageJSON(msg.options);if (Object.keys(options).length > 0) {json.options = options;}}
if (msg.reservedRange?.length) {json.reservedRange = msg.reservedRange.map(DescriptorProto.ReservedRange._writeMessageJSON)}
if (msg.reservedName?.length) {json.reservedName = msg.reservedName;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: DescriptorProto, reader: BinaryReader): DescriptorProto {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.name = reader.readString();break;
}
case 2: {const m = FieldDescriptorProto.initialize();reader.readMessage(m, FieldDescriptorProto._readMessage);msg.field.push(m);break;
}
case 6: {const m = FieldDescriptorProto.initialize();reader.readMessage(m, FieldDescriptorProto._readMessage);msg.extension.push(m);break;
}
case 3: {const m = DescriptorProto.initialize();reader.readMessage(m, DescriptorProto._readMessage);msg.nestedType.push(m);break;
}
case 4: {const m = EnumDescriptorProto.initialize();reader.readMessage(m, EnumDescriptorProto._readMessage);msg.enumType.push(m);break;
}
case 5: {const m = DescriptorProto.ExtensionRange.initialize();reader.readMessage(m, DescriptorProto.ExtensionRange._readMessage);msg.extensionRange.push(m);break;
}
case 8: {const m = OneofDescriptorProto.initialize();reader.readMessage(m, OneofDescriptorProto._readMessage);msg.oneofDecl.push(m);break;
}
case 7: {
                      reader.readMessage(msg.options, MessageOptions._readMessage);
                    break;
}
case 9: {const m = DescriptorProto.ReservedRange.initialize();reader.readMessage(m, DescriptorProto.ReservedRange._readMessage);msg.reservedRange.push(m);break;
}
case 10: {msg.reservedName.push(reader.readString());break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: DescriptorProto, json: any): DescriptorProto {
          const name = json.name ?? json.name;if (name) {msg.name = name;}
const field = json.field ?? json.field;if (field) {for (const item of field) {const m = FieldDescriptorProto.initialize();FieldDescriptorProto._readMessageJSON(m, item);msg.field.push(m);}}
const extension = json.extension ?? json.extension;if (extension) {for (const item of extension) {const m = FieldDescriptorProto.initialize();FieldDescriptorProto._readMessageJSON(m, item);msg.extension.push(m);}}
const nestedType = json.nestedType ?? json.nested_type;if (nestedType) {for (const item of nestedType) {const m = DescriptorProto.initialize();DescriptorProto._readMessageJSON(m, item);msg.nestedType.push(m);}}
const enumType = json.enumType ?? json.enum_type;if (enumType) {for (const item of enumType) {const m = EnumDescriptorProto.initialize();EnumDescriptorProto._readMessageJSON(m, item);msg.enumType.push(m);}}
const extensionRange = json.extensionRange ?? json.extension_range;if (extensionRange) {for (const item of extensionRange) {const m = DescriptorProto.ExtensionRange.initialize();DescriptorProto.ExtensionRange._readMessageJSON(m, item);msg.extensionRange.push(m);}}
const oneofDecl = json.oneofDecl ?? json.oneof_decl;if (oneofDecl) {for (const item of oneofDecl) {const m = OneofDescriptorProto.initialize();OneofDescriptorProto._readMessageJSON(m, item);msg.oneofDecl.push(m);}}
const options = json.options ?? json.options;if (options) {const m = MessageOptions.initialize();MessageOptions._readMessageJSON(m, options);msg.options = m;}
const reservedRange = json.reservedRange ?? json.reserved_range;if (reservedRange) {for (const item of reservedRange) {const m = DescriptorProto.ReservedRange.initialize();DescriptorProto.ReservedRange._readMessageJSON(m, item);msg.reservedRange.push(m);}}
const reservedName = json.reservedName ?? json.reserved_name;if (reservedName) {msg.reservedName = reservedName;}
          return msg;
        },

      ExtensionRange: {        /**
         * Serializes a DescriptorProto.ExtensionRange to protobuf.
         */
        encode: function(extensionRange: Partial<DescriptorProto.ExtensionRange>): Uint8Array {
          return DescriptorProto.ExtensionRange._writeMessage(extensionRange, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a DescriptorProto.ExtensionRange from protobuf.
         */
        decode: function(bytes: ByteSource): DescriptorProto.ExtensionRange {
          return DescriptorProto.ExtensionRange._readMessage(DescriptorProto.ExtensionRange.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a DescriptorProto.ExtensionRange to JSON.
         */
        encodeJSON: function(extensionRange: Partial<DescriptorProto.ExtensionRange>): string {
          return JSON.stringify(DescriptorProto.ExtensionRange._writeMessageJSON(extensionRange));
        },
        

        /**
         * Deserializes a DescriptorProto.ExtensionRange from JSON.
         */
        decodeJSON: function(json: string): DescriptorProto.ExtensionRange {
          return DescriptorProto.ExtensionRange._readMessageJSON(DescriptorProto.ExtensionRange.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a DescriptorProto.ExtensionRange with all fields set to their default value.
         */
        initialize: function(): DescriptorProto.ExtensionRange {
          return {
            start: 0,end: 0,options: ExtensionRangeOptions.initialize(),
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<DescriptorProto.ExtensionRange>, writer: BinaryWriter): BinaryWriter {
          if (msg.start) {writer.writeInt32(1, msg.start);}
if (msg.end) {writer.writeInt32(2, msg.end);}
if (msg.options) {writer.writeMessage(3, msg.options , ExtensionRangeOptions._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<DescriptorProto.ExtensionRange>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.start) {json.start = msg.start;}
if (msg.end) {json.end = msg.end;}
if (msg.options) {const options = ExtensionRangeOptions._writeMessageJSON(msg.options);if (Object.keys(options).length > 0) {json.options = options;}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: DescriptorProto.ExtensionRange, reader: BinaryReader): DescriptorProto.ExtensionRange {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.start = reader.readInt32();break;
}
case 2: {msg.end = reader.readInt32();break;
}
case 3: {
                      reader.readMessage(msg.options, ExtensionRangeOptions._readMessage);
                    break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: DescriptorProto.ExtensionRange, json: any): DescriptorProto.ExtensionRange {
          const start = json.start ?? json.start;if (start) {msg.start = start;}
const end = json.end ?? json.end;if (end) {msg.end = end;}
const options = json.options ?? json.options;if (options) {const m = ExtensionRangeOptions.initialize();ExtensionRangeOptions._readMessageJSON(m, options);msg.options = m;}
          return msg;
        },

      },

ReservedRange: {        /**
         * Serializes a DescriptorProto.ReservedRange to protobuf.
         */
        encode: function(reservedRange: Partial<DescriptorProto.ReservedRange>): Uint8Array {
          return DescriptorProto.ReservedRange._writeMessage(reservedRange, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a DescriptorProto.ReservedRange from protobuf.
         */
        decode: function(bytes: ByteSource): DescriptorProto.ReservedRange {
          return DescriptorProto.ReservedRange._readMessage(DescriptorProto.ReservedRange.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a DescriptorProto.ReservedRange to JSON.
         */
        encodeJSON: function(reservedRange: Partial<DescriptorProto.ReservedRange>): string {
          return JSON.stringify(DescriptorProto.ReservedRange._writeMessageJSON(reservedRange));
        },
        

        /**
         * Deserializes a DescriptorProto.ReservedRange from JSON.
         */
        decodeJSON: function(json: string): DescriptorProto.ReservedRange {
          return DescriptorProto.ReservedRange._readMessageJSON(DescriptorProto.ReservedRange.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a DescriptorProto.ReservedRange with all fields set to their default value.
         */
        initialize: function(): DescriptorProto.ReservedRange {
          return {
            start: 0,end: 0,
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<DescriptorProto.ReservedRange>, writer: BinaryWriter): BinaryWriter {
          if (msg.start) {writer.writeInt32(1, msg.start);}
if (msg.end) {writer.writeInt32(2, msg.end);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<DescriptorProto.ReservedRange>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.start) {json.start = msg.start;}
if (msg.end) {json.end = msg.end;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: DescriptorProto.ReservedRange, reader: BinaryReader): DescriptorProto.ReservedRange {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.start = reader.readInt32();break;
}
case 2: {msg.end = reader.readInt32();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: DescriptorProto.ReservedRange, json: any): DescriptorProto.ReservedRange {
          const start = json.start ?? json.start;if (start) {msg.start = start;}
const end = json.end ?? json.end;if (end) {msg.end = end;}
          return msg;
        },

      },

};

export const ExtensionRangeOptions = {        /**
         * Serializes a ExtensionRangeOptions to protobuf.
         */
        encode: function(extensionRangeOptions: Partial<ExtensionRangeOptions>): Uint8Array {
          return ExtensionRangeOptions._writeMessage(extensionRangeOptions, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a ExtensionRangeOptions from protobuf.
         */
        decode: function(bytes: ByteSource): ExtensionRangeOptions {
          return ExtensionRangeOptions._readMessage(ExtensionRangeOptions.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a ExtensionRangeOptions to JSON.
         */
        encodeJSON: function(extensionRangeOptions: Partial<ExtensionRangeOptions>): string {
          return JSON.stringify(ExtensionRangeOptions._writeMessageJSON(extensionRangeOptions));
        },
        

        /**
         * Deserializes a ExtensionRangeOptions from JSON.
         */
        decodeJSON: function(json: string): ExtensionRangeOptions {
          return ExtensionRangeOptions._readMessageJSON(ExtensionRangeOptions.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a ExtensionRangeOptions with all fields set to their default value.
         */
        initialize: function(): ExtensionRangeOptions {
          return {
            uninterpretedOption: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<ExtensionRangeOptions>, writer: BinaryWriter): BinaryWriter {
          if (msg.uninterpretedOption?.length) {writer.writeRepeatedMessage(999, msg.uninterpretedOption as any, UninterpretedOption._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<ExtensionRangeOptions>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.uninterpretedOption?.length) {json.uninterpretedOption = msg.uninterpretedOption.map(UninterpretedOption._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: ExtensionRangeOptions, reader: BinaryReader): ExtensionRangeOptions {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 999: {const m = UninterpretedOption.initialize();reader.readMessage(m, UninterpretedOption._readMessage);msg.uninterpretedOption.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: ExtensionRangeOptions, json: any): ExtensionRangeOptions {
          const uninterpretedOption = json.uninterpretedOption ?? json.uninterpreted_option;if (uninterpretedOption) {for (const item of uninterpretedOption) {const m = UninterpretedOption.initialize();UninterpretedOption._readMessageJSON(m, item);msg.uninterpretedOption.push(m);}}
          return msg;
        },

      };

export const FieldDescriptorProto = {        /**
         * Serializes a FieldDescriptorProto to protobuf.
         */
        encode: function(fieldDescriptorProto: Partial<FieldDescriptorProto>): Uint8Array {
          return FieldDescriptorProto._writeMessage(fieldDescriptorProto, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a FieldDescriptorProto from protobuf.
         */
        decode: function(bytes: ByteSource): FieldDescriptorProto {
          return FieldDescriptorProto._readMessage(FieldDescriptorProto.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a FieldDescriptorProto to JSON.
         */
        encodeJSON: function(fieldDescriptorProto: Partial<FieldDescriptorProto>): string {
          return JSON.stringify(FieldDescriptorProto._writeMessageJSON(fieldDescriptorProto));
        },
        

        /**
         * Deserializes a FieldDescriptorProto from JSON.
         */
        decodeJSON: function(json: string): FieldDescriptorProto {
          return FieldDescriptorProto._readMessageJSON(FieldDescriptorProto.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a FieldDescriptorProto with all fields set to their default value.
         */
        initialize: function(): FieldDescriptorProto {
          return {
            name: '',number: 0,label: 0,type: 0,typeName: '',extendee: '',defaultValue: '',oneofIndex: 0,jsonName: '',options: FieldOptions.initialize(),proto3Optional: false,
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<FieldDescriptorProto>, writer: BinaryWriter): BinaryWriter {
          if (msg.name) {writer.writeString(1, msg.name);}
if (msg.number) {writer.writeInt32(3, msg.number);}
if (msg.label) {writer.writeEnum(4, msg.label);}
if (msg.type) {writer.writeEnum(5, msg.type);}
if (msg.typeName) {writer.writeString(6, msg.typeName);}
if (msg.extendee) {writer.writeString(2, msg.extendee);}
if (msg.defaultValue) {writer.writeString(7, msg.defaultValue);}
if (msg.oneofIndex) {writer.writeInt32(9, msg.oneofIndex);}
if (msg.jsonName) {writer.writeString(10, msg.jsonName);}
if (msg.options) {writer.writeMessage(8, msg.options , FieldOptions._writeMessage);}
if (msg.proto3Optional) {writer.writeBool(17, msg.proto3Optional);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<FieldDescriptorProto>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name) {json.name = msg.name;}
if (msg.number) {json.number = msg.number;}
if (msg.label) {json.label = msg.label;}
if (msg.type) {json.type = msg.type;}
if (msg.typeName) {json.typeName = msg.typeName;}
if (msg.extendee) {json.extendee = msg.extendee;}
if (msg.defaultValue) {json.defaultValue = msg.defaultValue;}
if (msg.oneofIndex) {json.oneofIndex = msg.oneofIndex;}
if (msg.jsonName) {json.jsonName = msg.jsonName;}
if (msg.options) {const options = FieldOptions._writeMessageJSON(msg.options);if (Object.keys(options).length > 0) {json.options = options;}}
if (msg.proto3Optional) {json.proto3Optional = msg.proto3Optional;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: FieldDescriptorProto, reader: BinaryReader): FieldDescriptorProto {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.name = reader.readString();break;
}
case 3: {msg.number = reader.readInt32();break;
}
case 4: {msg.label = reader.readEnum() as FieldDescriptorProto.Label;break;
}
case 5: {msg.type = reader.readEnum() as FieldDescriptorProto.Type;break;
}
case 6: {msg.typeName = reader.readString();break;
}
case 2: {msg.extendee = reader.readString();break;
}
case 7: {msg.defaultValue = reader.readString();break;
}
case 9: {msg.oneofIndex = reader.readInt32();break;
}
case 10: {msg.jsonName = reader.readString();break;
}
case 8: {
                      reader.readMessage(msg.options, FieldOptions._readMessage);
                    break;
}
case 17: {msg.proto3Optional = reader.readBool();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: FieldDescriptorProto, json: any): FieldDescriptorProto {
          const name = json.name ?? json.name;if (name) {msg.name = name;}
const number = json.number ?? json.number;if (number) {msg.number = number;}
const label = json.label ?? json.label;if (label) {msg.label = label;}
const type = json.type ?? json.type;if (type) {msg.type = type;}
const typeName = json.typeName ?? json.type_name;if (typeName) {msg.typeName = typeName;}
const extendee = json.extendee ?? json.extendee;if (extendee) {msg.extendee = extendee;}
const defaultValue = json.defaultValue ?? json.default_value;if (defaultValue) {msg.defaultValue = defaultValue;}
const oneofIndex = json.oneofIndex ?? json.oneof_index;if (oneofIndex) {msg.oneofIndex = oneofIndex;}
const jsonName = json.jsonName ?? json.json_name;if (jsonName) {msg.jsonName = jsonName;}
const options = json.options ?? json.options;if (options) {const m = FieldOptions.initialize();FieldOptions._readMessageJSON(m, options);msg.options = m;}
const proto3Optional = json.proto3Optional ?? json.proto3_optional;if (proto3Optional) {msg.proto3Optional = proto3Optional;}
          return msg;
        },

      Type: {    /**
     * 0 is reserved for errors.
 * Order is weird for historical reasons.
     */
      TYPE_DOUBLE: 1,
TYPE_FLOAT: 2,
    /**
     * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
 * negative values are likely.
     */
      TYPE_INT64: 3,
TYPE_UINT64: 4,
    /**
     * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
 * negative values are likely.
     */
      TYPE_INT32: 5,
TYPE_FIXED64: 6,
TYPE_FIXED32: 7,
TYPE_BOOL: 8,
TYPE_STRING: 9,
    /**
     * Tag-delimited aggregate.
 * Group type is deprecated and not supported in proto3. However, Proto3
 * implementations should still be able to parse the group wire format and
 * treat group fields as unknown fields.
     */
      TYPE_GROUP: 10,
TYPE_MESSAGE: 11,
    /**
     * New in version 2.
     */
      TYPE_BYTES: 12,
TYPE_UINT32: 13,
TYPE_ENUM: 14,
TYPE_SFIXED32: 15,
TYPE_SFIXED64: 16,
TYPE_SINT32: 17,
TYPE_SINT64: 18,
} as const,

Label: {    /**
     * 0 is reserved for errors
     */
      LABEL_OPTIONAL: 1,
LABEL_REQUIRED: 2,
LABEL_REPEATED: 3,
} as const,

};

export const OneofDescriptorProto = {        /**
         * Serializes a OneofDescriptorProto to protobuf.
         */
        encode: function(oneofDescriptorProto: Partial<OneofDescriptorProto>): Uint8Array {
          return OneofDescriptorProto._writeMessage(oneofDescriptorProto, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a OneofDescriptorProto from protobuf.
         */
        decode: function(bytes: ByteSource): OneofDescriptorProto {
          return OneofDescriptorProto._readMessage(OneofDescriptorProto.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a OneofDescriptorProto to JSON.
         */
        encodeJSON: function(oneofDescriptorProto: Partial<OneofDescriptorProto>): string {
          return JSON.stringify(OneofDescriptorProto._writeMessageJSON(oneofDescriptorProto));
        },
        

        /**
         * Deserializes a OneofDescriptorProto from JSON.
         */
        decodeJSON: function(json: string): OneofDescriptorProto {
          return OneofDescriptorProto._readMessageJSON(OneofDescriptorProto.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a OneofDescriptorProto with all fields set to their default value.
         */
        initialize: function(): OneofDescriptorProto {
          return {
            name: '',options: OneofOptions.initialize(),
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<OneofDescriptorProto>, writer: BinaryWriter): BinaryWriter {
          if (msg.name) {writer.writeString(1, msg.name);}
if (msg.options) {writer.writeMessage(2, msg.options , OneofOptions._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<OneofDescriptorProto>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name) {json.name = msg.name;}
if (msg.options) {const options = OneofOptions._writeMessageJSON(msg.options);if (Object.keys(options).length > 0) {json.options = options;}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: OneofDescriptorProto, reader: BinaryReader): OneofDescriptorProto {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.name = reader.readString();break;
}
case 2: {
                      reader.readMessage(msg.options, OneofOptions._readMessage);
                    break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: OneofDescriptorProto, json: any): OneofDescriptorProto {
          const name = json.name ?? json.name;if (name) {msg.name = name;}
const options = json.options ?? json.options;if (options) {const m = OneofOptions.initialize();OneofOptions._readMessageJSON(m, options);msg.options = m;}
          return msg;
        },

      };

export const EnumDescriptorProto = {        /**
         * Serializes a EnumDescriptorProto to protobuf.
         */
        encode: function(enumDescriptorProto: Partial<EnumDescriptorProto>): Uint8Array {
          return EnumDescriptorProto._writeMessage(enumDescriptorProto, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a EnumDescriptorProto from protobuf.
         */
        decode: function(bytes: ByteSource): EnumDescriptorProto {
          return EnumDescriptorProto._readMessage(EnumDescriptorProto.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a EnumDescriptorProto to JSON.
         */
        encodeJSON: function(enumDescriptorProto: Partial<EnumDescriptorProto>): string {
          return JSON.stringify(EnumDescriptorProto._writeMessageJSON(enumDescriptorProto));
        },
        

        /**
         * Deserializes a EnumDescriptorProto from JSON.
         */
        decodeJSON: function(json: string): EnumDescriptorProto {
          return EnumDescriptorProto._readMessageJSON(EnumDescriptorProto.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a EnumDescriptorProto with all fields set to their default value.
         */
        initialize: function(): EnumDescriptorProto {
          return {
            name: '',value: [],options: EnumOptions.initialize(),reservedRange: [],reservedName: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<EnumDescriptorProto>, writer: BinaryWriter): BinaryWriter {
          if (msg.name) {writer.writeString(1, msg.name);}
if (msg.value?.length) {writer.writeRepeatedMessage(2, msg.value as any, EnumValueDescriptorProto._writeMessage);}
if (msg.options) {writer.writeMessage(3, msg.options , EnumOptions._writeMessage);}
if (msg.reservedRange?.length) {writer.writeRepeatedMessage(4, msg.reservedRange as any, EnumDescriptorProto.EnumReservedRange._writeMessage);}
if (msg.reservedName?.length) {writer.writeRepeatedString(5, msg.reservedName);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<EnumDescriptorProto>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name) {json.name = msg.name;}
if (msg.value?.length) {json.value = msg.value.map(EnumValueDescriptorProto._writeMessageJSON)}
if (msg.options) {const options = EnumOptions._writeMessageJSON(msg.options);if (Object.keys(options).length > 0) {json.options = options;}}
if (msg.reservedRange?.length) {json.reservedRange = msg.reservedRange.map(EnumDescriptorProto.EnumReservedRange._writeMessageJSON)}
if (msg.reservedName?.length) {json.reservedName = msg.reservedName;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: EnumDescriptorProto, reader: BinaryReader): EnumDescriptorProto {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.name = reader.readString();break;
}
case 2: {const m = EnumValueDescriptorProto.initialize();reader.readMessage(m, EnumValueDescriptorProto._readMessage);msg.value.push(m);break;
}
case 3: {
                      reader.readMessage(msg.options, EnumOptions._readMessage);
                    break;
}
case 4: {const m = EnumDescriptorProto.EnumReservedRange.initialize();reader.readMessage(m, EnumDescriptorProto.EnumReservedRange._readMessage);msg.reservedRange.push(m);break;
}
case 5: {msg.reservedName.push(reader.readString());break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: EnumDescriptorProto, json: any): EnumDescriptorProto {
          const name = json.name ?? json.name;if (name) {msg.name = name;}
const value = json.value ?? json.value;if (value) {for (const item of value) {const m = EnumValueDescriptorProto.initialize();EnumValueDescriptorProto._readMessageJSON(m, item);msg.value.push(m);}}
const options = json.options ?? json.options;if (options) {const m = EnumOptions.initialize();EnumOptions._readMessageJSON(m, options);msg.options = m;}
const reservedRange = json.reservedRange ?? json.reserved_range;if (reservedRange) {for (const item of reservedRange) {const m = EnumDescriptorProto.EnumReservedRange.initialize();EnumDescriptorProto.EnumReservedRange._readMessageJSON(m, item);msg.reservedRange.push(m);}}
const reservedName = json.reservedName ?? json.reserved_name;if (reservedName) {msg.reservedName = reservedName;}
          return msg;
        },

      EnumReservedRange: {        /**
         * Serializes a EnumDescriptorProto.EnumReservedRange to protobuf.
         */
        encode: function(enumReservedRange: Partial<EnumDescriptorProto.EnumReservedRange>): Uint8Array {
          return EnumDescriptorProto.EnumReservedRange._writeMessage(enumReservedRange, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a EnumDescriptorProto.EnumReservedRange from protobuf.
         */
        decode: function(bytes: ByteSource): EnumDescriptorProto.EnumReservedRange {
          return EnumDescriptorProto.EnumReservedRange._readMessage(EnumDescriptorProto.EnumReservedRange.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a EnumDescriptorProto.EnumReservedRange to JSON.
         */
        encodeJSON: function(enumReservedRange: Partial<EnumDescriptorProto.EnumReservedRange>): string {
          return JSON.stringify(EnumDescriptorProto.EnumReservedRange._writeMessageJSON(enumReservedRange));
        },
        

        /**
         * Deserializes a EnumDescriptorProto.EnumReservedRange from JSON.
         */
        decodeJSON: function(json: string): EnumDescriptorProto.EnumReservedRange {
          return EnumDescriptorProto.EnumReservedRange._readMessageJSON(EnumDescriptorProto.EnumReservedRange.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a EnumDescriptorProto.EnumReservedRange with all fields set to their default value.
         */
        initialize: function(): EnumDescriptorProto.EnumReservedRange {
          return {
            start: 0,end: 0,
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<EnumDescriptorProto.EnumReservedRange>, writer: BinaryWriter): BinaryWriter {
          if (msg.start) {writer.writeInt32(1, msg.start);}
if (msg.end) {writer.writeInt32(2, msg.end);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<EnumDescriptorProto.EnumReservedRange>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.start) {json.start = msg.start;}
if (msg.end) {json.end = msg.end;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: EnumDescriptorProto.EnumReservedRange, reader: BinaryReader): EnumDescriptorProto.EnumReservedRange {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.start = reader.readInt32();break;
}
case 2: {msg.end = reader.readInt32();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: EnumDescriptorProto.EnumReservedRange, json: any): EnumDescriptorProto.EnumReservedRange {
          const start = json.start ?? json.start;if (start) {msg.start = start;}
const end = json.end ?? json.end;if (end) {msg.end = end;}
          return msg;
        },

      },

};

export const EnumValueDescriptorProto = {        /**
         * Serializes a EnumValueDescriptorProto to protobuf.
         */
        encode: function(enumValueDescriptorProto: Partial<EnumValueDescriptorProto>): Uint8Array {
          return EnumValueDescriptorProto._writeMessage(enumValueDescriptorProto, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a EnumValueDescriptorProto from protobuf.
         */
        decode: function(bytes: ByteSource): EnumValueDescriptorProto {
          return EnumValueDescriptorProto._readMessage(EnumValueDescriptorProto.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a EnumValueDescriptorProto to JSON.
         */
        encodeJSON: function(enumValueDescriptorProto: Partial<EnumValueDescriptorProto>): string {
          return JSON.stringify(EnumValueDescriptorProto._writeMessageJSON(enumValueDescriptorProto));
        },
        

        /**
         * Deserializes a EnumValueDescriptorProto from JSON.
         */
        decodeJSON: function(json: string): EnumValueDescriptorProto {
          return EnumValueDescriptorProto._readMessageJSON(EnumValueDescriptorProto.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a EnumValueDescriptorProto with all fields set to their default value.
         */
        initialize: function(): EnumValueDescriptorProto {
          return {
            name: '',number: 0,options: EnumValueOptions.initialize(),
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<EnumValueDescriptorProto>, writer: BinaryWriter): BinaryWriter {
          if (msg.name) {writer.writeString(1, msg.name);}
if (msg.number) {writer.writeInt32(2, msg.number);}
if (msg.options) {writer.writeMessage(3, msg.options , EnumValueOptions._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<EnumValueDescriptorProto>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name) {json.name = msg.name;}
if (msg.number) {json.number = msg.number;}
if (msg.options) {const options = EnumValueOptions._writeMessageJSON(msg.options);if (Object.keys(options).length > 0) {json.options = options;}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: EnumValueDescriptorProto, reader: BinaryReader): EnumValueDescriptorProto {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.name = reader.readString();break;
}
case 2: {msg.number = reader.readInt32();break;
}
case 3: {
                      reader.readMessage(msg.options, EnumValueOptions._readMessage);
                    break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: EnumValueDescriptorProto, json: any): EnumValueDescriptorProto {
          const name = json.name ?? json.name;if (name) {msg.name = name;}
const number = json.number ?? json.number;if (number) {msg.number = number;}
const options = json.options ?? json.options;if (options) {const m = EnumValueOptions.initialize();EnumValueOptions._readMessageJSON(m, options);msg.options = m;}
          return msg;
        },

      };

export const ServiceDescriptorProto = {        /**
         * Serializes a ServiceDescriptorProto to protobuf.
         */
        encode: function(serviceDescriptorProto: Partial<ServiceDescriptorProto>): Uint8Array {
          return ServiceDescriptorProto._writeMessage(serviceDescriptorProto, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a ServiceDescriptorProto from protobuf.
         */
        decode: function(bytes: ByteSource): ServiceDescriptorProto {
          return ServiceDescriptorProto._readMessage(ServiceDescriptorProto.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a ServiceDescriptorProto to JSON.
         */
        encodeJSON: function(serviceDescriptorProto: Partial<ServiceDescriptorProto>): string {
          return JSON.stringify(ServiceDescriptorProto._writeMessageJSON(serviceDescriptorProto));
        },
        

        /**
         * Deserializes a ServiceDescriptorProto from JSON.
         */
        decodeJSON: function(json: string): ServiceDescriptorProto {
          return ServiceDescriptorProto._readMessageJSON(ServiceDescriptorProto.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a ServiceDescriptorProto with all fields set to their default value.
         */
        initialize: function(): ServiceDescriptorProto {
          return {
            name: '',method: [],options: ServiceOptions.initialize(),
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<ServiceDescriptorProto>, writer: BinaryWriter): BinaryWriter {
          if (msg.name) {writer.writeString(1, msg.name);}
if (msg.method?.length) {writer.writeRepeatedMessage(2, msg.method as any, MethodDescriptorProto._writeMessage);}
if (msg.options) {writer.writeMessage(3, msg.options , ServiceOptions._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<ServiceDescriptorProto>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name) {json.name = msg.name;}
if (msg.method?.length) {json.method = msg.method.map(MethodDescriptorProto._writeMessageJSON)}
if (msg.options) {const options = ServiceOptions._writeMessageJSON(msg.options);if (Object.keys(options).length > 0) {json.options = options;}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: ServiceDescriptorProto, reader: BinaryReader): ServiceDescriptorProto {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.name = reader.readString();break;
}
case 2: {const m = MethodDescriptorProto.initialize();reader.readMessage(m, MethodDescriptorProto._readMessage);msg.method.push(m);break;
}
case 3: {
                      reader.readMessage(msg.options, ServiceOptions._readMessage);
                    break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: ServiceDescriptorProto, json: any): ServiceDescriptorProto {
          const name = json.name ?? json.name;if (name) {msg.name = name;}
const method = json.method ?? json.method;if (method) {for (const item of method) {const m = MethodDescriptorProto.initialize();MethodDescriptorProto._readMessageJSON(m, item);msg.method.push(m);}}
const options = json.options ?? json.options;if (options) {const m = ServiceOptions.initialize();ServiceOptions._readMessageJSON(m, options);msg.options = m;}
          return msg;
        },

      };

export const MethodDescriptorProto = {        /**
         * Serializes a MethodDescriptorProto to protobuf.
         */
        encode: function(methodDescriptorProto: Partial<MethodDescriptorProto>): Uint8Array {
          return MethodDescriptorProto._writeMessage(methodDescriptorProto, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a MethodDescriptorProto from protobuf.
         */
        decode: function(bytes: ByteSource): MethodDescriptorProto {
          return MethodDescriptorProto._readMessage(MethodDescriptorProto.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a MethodDescriptorProto to JSON.
         */
        encodeJSON: function(methodDescriptorProto: Partial<MethodDescriptorProto>): string {
          return JSON.stringify(MethodDescriptorProto._writeMessageJSON(methodDescriptorProto));
        },
        

        /**
         * Deserializes a MethodDescriptorProto from JSON.
         */
        decodeJSON: function(json: string): MethodDescriptorProto {
          return MethodDescriptorProto._readMessageJSON(MethodDescriptorProto.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a MethodDescriptorProto with all fields set to their default value.
         */
        initialize: function(): MethodDescriptorProto {
          return {
            name: '',inputType: '',outputType: '',options: MethodOptions.initialize(),clientStreaming: false,serverStreaming: false,
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<MethodDescriptorProto>, writer: BinaryWriter): BinaryWriter {
          if (msg.name) {writer.writeString(1, msg.name);}
if (msg.inputType) {writer.writeString(2, msg.inputType);}
if (msg.outputType) {writer.writeString(3, msg.outputType);}
if (msg.options) {writer.writeMessage(4, msg.options , MethodOptions._writeMessage);}
if (msg.clientStreaming) {writer.writeBool(5, msg.clientStreaming);}
if (msg.serverStreaming) {writer.writeBool(6, msg.serverStreaming);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<MethodDescriptorProto>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name) {json.name = msg.name;}
if (msg.inputType) {json.inputType = msg.inputType;}
if (msg.outputType) {json.outputType = msg.outputType;}
if (msg.options) {const options = MethodOptions._writeMessageJSON(msg.options);if (Object.keys(options).length > 0) {json.options = options;}}
if (msg.clientStreaming) {json.clientStreaming = msg.clientStreaming;}
if (msg.serverStreaming) {json.serverStreaming = msg.serverStreaming;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: MethodDescriptorProto, reader: BinaryReader): MethodDescriptorProto {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.name = reader.readString();break;
}
case 2: {msg.inputType = reader.readString();break;
}
case 3: {msg.outputType = reader.readString();break;
}
case 4: {
                      reader.readMessage(msg.options, MethodOptions._readMessage);
                    break;
}
case 5: {msg.clientStreaming = reader.readBool();break;
}
case 6: {msg.serverStreaming = reader.readBool();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: MethodDescriptorProto, json: any): MethodDescriptorProto {
          const name = json.name ?? json.name;if (name) {msg.name = name;}
const inputType = json.inputType ?? json.input_type;if (inputType) {msg.inputType = inputType;}
const outputType = json.outputType ?? json.output_type;if (outputType) {msg.outputType = outputType;}
const options = json.options ?? json.options;if (options) {const m = MethodOptions.initialize();MethodOptions._readMessageJSON(m, options);msg.options = m;}
const clientStreaming = json.clientStreaming ?? json.client_streaming;if (clientStreaming) {msg.clientStreaming = clientStreaming;}
const serverStreaming = json.serverStreaming ?? json.server_streaming;if (serverStreaming) {msg.serverStreaming = serverStreaming;}
          return msg;
        },

      };

export const FileOptions = {        /**
         * Serializes a FileOptions to protobuf.
         */
        encode: function(fileOptions: Partial<FileOptions>): Uint8Array {
          return FileOptions._writeMessage(fileOptions, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a FileOptions from protobuf.
         */
        decode: function(bytes: ByteSource): FileOptions {
          return FileOptions._readMessage(FileOptions.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a FileOptions to JSON.
         */
        encodeJSON: function(fileOptions: Partial<FileOptions>): string {
          return JSON.stringify(FileOptions._writeMessageJSON(fileOptions));
        },
        

        /**
         * Deserializes a FileOptions from JSON.
         */
        decodeJSON: function(json: string): FileOptions {
          return FileOptions._readMessageJSON(FileOptions.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a FileOptions with all fields set to their default value.
         */
        initialize: function(): FileOptions {
          return {
            javaPackage: '',javaOuterClassname: '',javaMultipleFiles: false,javaGenerateEqualsAndHash: false,javaStringCheckUtf8: false,optimizeFor: 0,goPackage: '',ccGenericServices: false,javaGenericServices: false,pyGenericServices: false,phpGenericServices: false,deprecated: false,ccEnableArenas: false,objcClassPrefix: '',csharpNamespace: '',swiftPrefix: '',phpClassPrefix: '',phpNamespace: '',phpMetadataNamespace: '',rubyPackage: '',uninterpretedOption: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<FileOptions>, writer: BinaryWriter): BinaryWriter {
          if (msg.javaPackage) {writer.writeString(1, msg.javaPackage);}
if (msg.javaOuterClassname) {writer.writeString(8, msg.javaOuterClassname);}
if (msg.javaMultipleFiles) {writer.writeBool(10, msg.javaMultipleFiles);}
if (msg.javaGenerateEqualsAndHash) {writer.writeBool(20, msg.javaGenerateEqualsAndHash);}
if (msg.javaStringCheckUtf8) {writer.writeBool(27, msg.javaStringCheckUtf8);}
if (msg.optimizeFor) {writer.writeEnum(9, msg.optimizeFor);}
if (msg.goPackage) {writer.writeString(11, msg.goPackage);}
if (msg.ccGenericServices) {writer.writeBool(16, msg.ccGenericServices);}
if (msg.javaGenericServices) {writer.writeBool(17, msg.javaGenericServices);}
if (msg.pyGenericServices) {writer.writeBool(18, msg.pyGenericServices);}
if (msg.phpGenericServices) {writer.writeBool(42, msg.phpGenericServices);}
if (msg.deprecated) {writer.writeBool(23, msg.deprecated);}
if (msg.ccEnableArenas) {writer.writeBool(31, msg.ccEnableArenas);}
if (msg.objcClassPrefix) {writer.writeString(36, msg.objcClassPrefix);}
if (msg.csharpNamespace) {writer.writeString(37, msg.csharpNamespace);}
if (msg.swiftPrefix) {writer.writeString(39, msg.swiftPrefix);}
if (msg.phpClassPrefix) {writer.writeString(40, msg.phpClassPrefix);}
if (msg.phpNamespace) {writer.writeString(41, msg.phpNamespace);}
if (msg.phpMetadataNamespace) {writer.writeString(44, msg.phpMetadataNamespace);}
if (msg.rubyPackage) {writer.writeString(45, msg.rubyPackage);}
if (msg.uninterpretedOption?.length) {writer.writeRepeatedMessage(999, msg.uninterpretedOption as any, UninterpretedOption._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<FileOptions>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.javaPackage) {json.javaPackage = msg.javaPackage;}
if (msg.javaOuterClassname) {json.javaOuterClassname = msg.javaOuterClassname;}
if (msg.javaMultipleFiles) {json.javaMultipleFiles = msg.javaMultipleFiles;}
if (msg.javaGenerateEqualsAndHash) {json.javaGenerateEqualsAndHash = msg.javaGenerateEqualsAndHash;}
if (msg.javaStringCheckUtf8) {json.javaStringCheckUtf8 = msg.javaStringCheckUtf8;}
if (msg.optimizeFor) {json.optimizeFor = msg.optimizeFor;}
if (msg.goPackage) {json.goPackage = msg.goPackage;}
if (msg.ccGenericServices) {json.ccGenericServices = msg.ccGenericServices;}
if (msg.javaGenericServices) {json.javaGenericServices = msg.javaGenericServices;}
if (msg.pyGenericServices) {json.pyGenericServices = msg.pyGenericServices;}
if (msg.phpGenericServices) {json.phpGenericServices = msg.phpGenericServices;}
if (msg.deprecated) {json.deprecated = msg.deprecated;}
if (msg.ccEnableArenas) {json.ccEnableArenas = msg.ccEnableArenas;}
if (msg.objcClassPrefix) {json.objcClassPrefix = msg.objcClassPrefix;}
if (msg.csharpNamespace) {json.csharpNamespace = msg.csharpNamespace;}
if (msg.swiftPrefix) {json.swiftPrefix = msg.swiftPrefix;}
if (msg.phpClassPrefix) {json.phpClassPrefix = msg.phpClassPrefix;}
if (msg.phpNamespace) {json.phpNamespace = msg.phpNamespace;}
if (msg.phpMetadataNamespace) {json.phpMetadataNamespace = msg.phpMetadataNamespace;}
if (msg.rubyPackage) {json.rubyPackage = msg.rubyPackage;}
if (msg.uninterpretedOption?.length) {json.uninterpretedOption = msg.uninterpretedOption.map(UninterpretedOption._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: FileOptions, reader: BinaryReader): FileOptions {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.javaPackage = reader.readString();break;
}
case 8: {msg.javaOuterClassname = reader.readString();break;
}
case 10: {msg.javaMultipleFiles = reader.readBool();break;
}
case 20: {msg.javaGenerateEqualsAndHash = reader.readBool();break;
}
case 27: {msg.javaStringCheckUtf8 = reader.readBool();break;
}
case 9: {msg.optimizeFor = reader.readEnum() as FileOptions.OptimizeMode;break;
}
case 11: {msg.goPackage = reader.readString();break;
}
case 16: {msg.ccGenericServices = reader.readBool();break;
}
case 17: {msg.javaGenericServices = reader.readBool();break;
}
case 18: {msg.pyGenericServices = reader.readBool();break;
}
case 42: {msg.phpGenericServices = reader.readBool();break;
}
case 23: {msg.deprecated = reader.readBool();break;
}
case 31: {msg.ccEnableArenas = reader.readBool();break;
}
case 36: {msg.objcClassPrefix = reader.readString();break;
}
case 37: {msg.csharpNamespace = reader.readString();break;
}
case 39: {msg.swiftPrefix = reader.readString();break;
}
case 40: {msg.phpClassPrefix = reader.readString();break;
}
case 41: {msg.phpNamespace = reader.readString();break;
}
case 44: {msg.phpMetadataNamespace = reader.readString();break;
}
case 45: {msg.rubyPackage = reader.readString();break;
}
case 999: {const m = UninterpretedOption.initialize();reader.readMessage(m, UninterpretedOption._readMessage);msg.uninterpretedOption.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: FileOptions, json: any): FileOptions {
          const javaPackage = json.javaPackage ?? json.java_package;if (javaPackage) {msg.javaPackage = javaPackage;}
const javaOuterClassname = json.javaOuterClassname ?? json.java_outer_classname;if (javaOuterClassname) {msg.javaOuterClassname = javaOuterClassname;}
const javaMultipleFiles = json.javaMultipleFiles ?? json.java_multiple_files;if (javaMultipleFiles) {msg.javaMultipleFiles = javaMultipleFiles;}
const javaGenerateEqualsAndHash = json.javaGenerateEqualsAndHash ?? json.java_generate_equals_and_hash;if (javaGenerateEqualsAndHash) {msg.javaGenerateEqualsAndHash = javaGenerateEqualsAndHash;}
const javaStringCheckUtf8 = json.javaStringCheckUtf8 ?? json.java_string_check_utf8;if (javaStringCheckUtf8) {msg.javaStringCheckUtf8 = javaStringCheckUtf8;}
const optimizeFor = json.optimizeFor ?? json.optimize_for;if (optimizeFor) {msg.optimizeFor = optimizeFor;}
const goPackage = json.goPackage ?? json.go_package;if (goPackage) {msg.goPackage = goPackage;}
const ccGenericServices = json.ccGenericServices ?? json.cc_generic_services;if (ccGenericServices) {msg.ccGenericServices = ccGenericServices;}
const javaGenericServices = json.javaGenericServices ?? json.java_generic_services;if (javaGenericServices) {msg.javaGenericServices = javaGenericServices;}
const pyGenericServices = json.pyGenericServices ?? json.py_generic_services;if (pyGenericServices) {msg.pyGenericServices = pyGenericServices;}
const phpGenericServices = json.phpGenericServices ?? json.php_generic_services;if (phpGenericServices) {msg.phpGenericServices = phpGenericServices;}
const deprecated = json.deprecated ?? json.deprecated;if (deprecated) {msg.deprecated = deprecated;}
const ccEnableArenas = json.ccEnableArenas ?? json.cc_enable_arenas;if (ccEnableArenas) {msg.ccEnableArenas = ccEnableArenas;}
const objcClassPrefix = json.objcClassPrefix ?? json.objc_class_prefix;if (objcClassPrefix) {msg.objcClassPrefix = objcClassPrefix;}
const csharpNamespace = json.csharpNamespace ?? json.csharp_namespace;if (csharpNamespace) {msg.csharpNamespace = csharpNamespace;}
const swiftPrefix = json.swiftPrefix ?? json.swift_prefix;if (swiftPrefix) {msg.swiftPrefix = swiftPrefix;}
const phpClassPrefix = json.phpClassPrefix ?? json.php_class_prefix;if (phpClassPrefix) {msg.phpClassPrefix = phpClassPrefix;}
const phpNamespace = json.phpNamespace ?? json.php_namespace;if (phpNamespace) {msg.phpNamespace = phpNamespace;}
const phpMetadataNamespace = json.phpMetadataNamespace ?? json.php_metadata_namespace;if (phpMetadataNamespace) {msg.phpMetadataNamespace = phpMetadataNamespace;}
const rubyPackage = json.rubyPackage ?? json.ruby_package;if (rubyPackage) {msg.rubyPackage = rubyPackage;}
const uninterpretedOption = json.uninterpretedOption ?? json.uninterpreted_option;if (uninterpretedOption) {for (const item of uninterpretedOption) {const m = UninterpretedOption.initialize();UninterpretedOption._readMessageJSON(m, item);msg.uninterpretedOption.push(m);}}
          return msg;
        },

      OptimizeMode: {SPEED: 1,
    /**
     * etc.
     */
      CODE_SIZE: 2,
LITE_RUNTIME: 3,
} as const,

};

export const MessageOptions = {        /**
         * Serializes a MessageOptions to protobuf.
         */
        encode: function(messageOptions: Partial<MessageOptions>): Uint8Array {
          return MessageOptions._writeMessage(messageOptions, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a MessageOptions from protobuf.
         */
        decode: function(bytes: ByteSource): MessageOptions {
          return MessageOptions._readMessage(MessageOptions.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a MessageOptions to JSON.
         */
        encodeJSON: function(messageOptions: Partial<MessageOptions>): string {
          return JSON.stringify(MessageOptions._writeMessageJSON(messageOptions));
        },
        

        /**
         * Deserializes a MessageOptions from JSON.
         */
        decodeJSON: function(json: string): MessageOptions {
          return MessageOptions._readMessageJSON(MessageOptions.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a MessageOptions with all fields set to their default value.
         */
        initialize: function(): MessageOptions {
          return {
            messageSetWireFormat: false,noStandardDescriptorAccessor: false,deprecated: false,mapEntry: false,uninterpretedOption: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<MessageOptions>, writer: BinaryWriter): BinaryWriter {
          if (msg.messageSetWireFormat) {writer.writeBool(1, msg.messageSetWireFormat);}
if (msg.noStandardDescriptorAccessor) {writer.writeBool(2, msg.noStandardDescriptorAccessor);}
if (msg.deprecated) {writer.writeBool(3, msg.deprecated);}
if (msg.mapEntry) {writer.writeBool(7, msg.mapEntry);}
if (msg.uninterpretedOption?.length) {writer.writeRepeatedMessage(999, msg.uninterpretedOption as any, UninterpretedOption._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<MessageOptions>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.messageSetWireFormat) {json.messageSetWireFormat = msg.messageSetWireFormat;}
if (msg.noStandardDescriptorAccessor) {json.noStandardDescriptorAccessor = msg.noStandardDescriptorAccessor;}
if (msg.deprecated) {json.deprecated = msg.deprecated;}
if (msg.mapEntry) {json.mapEntry = msg.mapEntry;}
if (msg.uninterpretedOption?.length) {json.uninterpretedOption = msg.uninterpretedOption.map(UninterpretedOption._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: MessageOptions, reader: BinaryReader): MessageOptions {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.messageSetWireFormat = reader.readBool();break;
}
case 2: {msg.noStandardDescriptorAccessor = reader.readBool();break;
}
case 3: {msg.deprecated = reader.readBool();break;
}
case 7: {msg.mapEntry = reader.readBool();break;
}
case 999: {const m = UninterpretedOption.initialize();reader.readMessage(m, UninterpretedOption._readMessage);msg.uninterpretedOption.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: MessageOptions, json: any): MessageOptions {
          const messageSetWireFormat = json.messageSetWireFormat ?? json.message_set_wire_format;if (messageSetWireFormat) {msg.messageSetWireFormat = messageSetWireFormat;}
const noStandardDescriptorAccessor = json.noStandardDescriptorAccessor ?? json.no_standard_descriptor_accessor;if (noStandardDescriptorAccessor) {msg.noStandardDescriptorAccessor = noStandardDescriptorAccessor;}
const deprecated = json.deprecated ?? json.deprecated;if (deprecated) {msg.deprecated = deprecated;}
const mapEntry = json.mapEntry ?? json.map_entry;if (mapEntry) {msg.mapEntry = mapEntry;}
const uninterpretedOption = json.uninterpretedOption ?? json.uninterpreted_option;if (uninterpretedOption) {for (const item of uninterpretedOption) {const m = UninterpretedOption.initialize();UninterpretedOption._readMessageJSON(m, item);msg.uninterpretedOption.push(m);}}
          return msg;
        },

      };

export const FieldOptions = {        /**
         * Serializes a FieldOptions to protobuf.
         */
        encode: function(fieldOptions: Partial<FieldOptions>): Uint8Array {
          return FieldOptions._writeMessage(fieldOptions, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a FieldOptions from protobuf.
         */
        decode: function(bytes: ByteSource): FieldOptions {
          return FieldOptions._readMessage(FieldOptions.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a FieldOptions to JSON.
         */
        encodeJSON: function(fieldOptions: Partial<FieldOptions>): string {
          return JSON.stringify(FieldOptions._writeMessageJSON(fieldOptions));
        },
        

        /**
         * Deserializes a FieldOptions from JSON.
         */
        decodeJSON: function(json: string): FieldOptions {
          return FieldOptions._readMessageJSON(FieldOptions.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a FieldOptions with all fields set to their default value.
         */
        initialize: function(): FieldOptions {
          return {
            ctype: 0,packed: false,jstype: 0,lazy: false,deprecated: false,weak: false,uninterpretedOption: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<FieldOptions>, writer: BinaryWriter): BinaryWriter {
          if (msg.ctype) {writer.writeEnum(1, msg.ctype);}
if (msg.packed) {writer.writeBool(2, msg.packed);}
if (msg.jstype) {writer.writeEnum(6, msg.jstype);}
if (msg.lazy) {writer.writeBool(5, msg.lazy);}
if (msg.deprecated) {writer.writeBool(3, msg.deprecated);}
if (msg.weak) {writer.writeBool(10, msg.weak);}
if (msg.uninterpretedOption?.length) {writer.writeRepeatedMessage(999, msg.uninterpretedOption as any, UninterpretedOption._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<FieldOptions>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.ctype) {json.ctype = msg.ctype;}
if (msg.packed) {json.packed = msg.packed;}
if (msg.jstype) {json.jstype = msg.jstype;}
if (msg.lazy) {json.lazy = msg.lazy;}
if (msg.deprecated) {json.deprecated = msg.deprecated;}
if (msg.weak) {json.weak = msg.weak;}
if (msg.uninterpretedOption?.length) {json.uninterpretedOption = msg.uninterpretedOption.map(UninterpretedOption._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: FieldOptions, reader: BinaryReader): FieldOptions {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.ctype = reader.readEnum() as FieldOptions.CType;break;
}
case 2: {msg.packed = reader.readBool();break;
}
case 6: {msg.jstype = reader.readEnum() as FieldOptions.JSType;break;
}
case 5: {msg.lazy = reader.readBool();break;
}
case 3: {msg.deprecated = reader.readBool();break;
}
case 10: {msg.weak = reader.readBool();break;
}
case 999: {const m = UninterpretedOption.initialize();reader.readMessage(m, UninterpretedOption._readMessage);msg.uninterpretedOption.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: FieldOptions, json: any): FieldOptions {
          const ctype = json.ctype ?? json.ctype;if (ctype) {msg.ctype = ctype;}
const packed = json.packed ?? json.packed;if (packed) {msg.packed = packed;}
const jstype = json.jstype ?? json.jstype;if (jstype) {msg.jstype = jstype;}
const lazy = json.lazy ?? json.lazy;if (lazy) {msg.lazy = lazy;}
const deprecated = json.deprecated ?? json.deprecated;if (deprecated) {msg.deprecated = deprecated;}
const weak = json.weak ?? json.weak;if (weak) {msg.weak = weak;}
const uninterpretedOption = json.uninterpretedOption ?? json.uninterpreted_option;if (uninterpretedOption) {for (const item of uninterpretedOption) {const m = UninterpretedOption.initialize();UninterpretedOption._readMessageJSON(m, item);msg.uninterpretedOption.push(m);}}
          return msg;
        },

      CType: {    /**
     * Default mode.
     */
      STRING: 0,
CORD: 1,
STRING_PIECE: 2,
} as const,

JSType: {    /**
     * Use the default type.
     */
      JS_NORMAL: 0,
    /**
     * Use JavaScript strings.
     */
      JS_STRING: 1,
    /**
     * Use JavaScript numbers.
     */
      JS_NUMBER: 2,
} as const,

};

export const OneofOptions = {        /**
         * Serializes a OneofOptions to protobuf.
         */
        encode: function(oneofOptions: Partial<OneofOptions>): Uint8Array {
          return OneofOptions._writeMessage(oneofOptions, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a OneofOptions from protobuf.
         */
        decode: function(bytes: ByteSource): OneofOptions {
          return OneofOptions._readMessage(OneofOptions.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a OneofOptions to JSON.
         */
        encodeJSON: function(oneofOptions: Partial<OneofOptions>): string {
          return JSON.stringify(OneofOptions._writeMessageJSON(oneofOptions));
        },
        

        /**
         * Deserializes a OneofOptions from JSON.
         */
        decodeJSON: function(json: string): OneofOptions {
          return OneofOptions._readMessageJSON(OneofOptions.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a OneofOptions with all fields set to their default value.
         */
        initialize: function(): OneofOptions {
          return {
            uninterpretedOption: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<OneofOptions>, writer: BinaryWriter): BinaryWriter {
          if (msg.uninterpretedOption?.length) {writer.writeRepeatedMessage(999, msg.uninterpretedOption as any, UninterpretedOption._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<OneofOptions>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.uninterpretedOption?.length) {json.uninterpretedOption = msg.uninterpretedOption.map(UninterpretedOption._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: OneofOptions, reader: BinaryReader): OneofOptions {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 999: {const m = UninterpretedOption.initialize();reader.readMessage(m, UninterpretedOption._readMessage);msg.uninterpretedOption.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: OneofOptions, json: any): OneofOptions {
          const uninterpretedOption = json.uninterpretedOption ?? json.uninterpreted_option;if (uninterpretedOption) {for (const item of uninterpretedOption) {const m = UninterpretedOption.initialize();UninterpretedOption._readMessageJSON(m, item);msg.uninterpretedOption.push(m);}}
          return msg;
        },

      };

export const EnumOptions = {        /**
         * Serializes a EnumOptions to protobuf.
         */
        encode: function(enumOptions: Partial<EnumOptions>): Uint8Array {
          return EnumOptions._writeMessage(enumOptions, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a EnumOptions from protobuf.
         */
        decode: function(bytes: ByteSource): EnumOptions {
          return EnumOptions._readMessage(EnumOptions.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a EnumOptions to JSON.
         */
        encodeJSON: function(enumOptions: Partial<EnumOptions>): string {
          return JSON.stringify(EnumOptions._writeMessageJSON(enumOptions));
        },
        

        /**
         * Deserializes a EnumOptions from JSON.
         */
        decodeJSON: function(json: string): EnumOptions {
          return EnumOptions._readMessageJSON(EnumOptions.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a EnumOptions with all fields set to their default value.
         */
        initialize: function(): EnumOptions {
          return {
            allowAlias: false,deprecated: false,uninterpretedOption: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<EnumOptions>, writer: BinaryWriter): BinaryWriter {
          if (msg.allowAlias) {writer.writeBool(2, msg.allowAlias);}
if (msg.deprecated) {writer.writeBool(3, msg.deprecated);}
if (msg.uninterpretedOption?.length) {writer.writeRepeatedMessage(999, msg.uninterpretedOption as any, UninterpretedOption._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<EnumOptions>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.allowAlias) {json.allowAlias = msg.allowAlias;}
if (msg.deprecated) {json.deprecated = msg.deprecated;}
if (msg.uninterpretedOption?.length) {json.uninterpretedOption = msg.uninterpretedOption.map(UninterpretedOption._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: EnumOptions, reader: BinaryReader): EnumOptions {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 2: {msg.allowAlias = reader.readBool();break;
}
case 3: {msg.deprecated = reader.readBool();break;
}
case 999: {const m = UninterpretedOption.initialize();reader.readMessage(m, UninterpretedOption._readMessage);msg.uninterpretedOption.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: EnumOptions, json: any): EnumOptions {
          const allowAlias = json.allowAlias ?? json.allow_alias;if (allowAlias) {msg.allowAlias = allowAlias;}
const deprecated = json.deprecated ?? json.deprecated;if (deprecated) {msg.deprecated = deprecated;}
const uninterpretedOption = json.uninterpretedOption ?? json.uninterpreted_option;if (uninterpretedOption) {for (const item of uninterpretedOption) {const m = UninterpretedOption.initialize();UninterpretedOption._readMessageJSON(m, item);msg.uninterpretedOption.push(m);}}
          return msg;
        },

      };

export const EnumValueOptions = {        /**
         * Serializes a EnumValueOptions to protobuf.
         */
        encode: function(enumValueOptions: Partial<EnumValueOptions>): Uint8Array {
          return EnumValueOptions._writeMessage(enumValueOptions, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a EnumValueOptions from protobuf.
         */
        decode: function(bytes: ByteSource): EnumValueOptions {
          return EnumValueOptions._readMessage(EnumValueOptions.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a EnumValueOptions to JSON.
         */
        encodeJSON: function(enumValueOptions: Partial<EnumValueOptions>): string {
          return JSON.stringify(EnumValueOptions._writeMessageJSON(enumValueOptions));
        },
        

        /**
         * Deserializes a EnumValueOptions from JSON.
         */
        decodeJSON: function(json: string): EnumValueOptions {
          return EnumValueOptions._readMessageJSON(EnumValueOptions.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a EnumValueOptions with all fields set to their default value.
         */
        initialize: function(): EnumValueOptions {
          return {
            deprecated: false,uninterpretedOption: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<EnumValueOptions>, writer: BinaryWriter): BinaryWriter {
          if (msg.deprecated) {writer.writeBool(1, msg.deprecated);}
if (msg.uninterpretedOption?.length) {writer.writeRepeatedMessage(999, msg.uninterpretedOption as any, UninterpretedOption._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<EnumValueOptions>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.deprecated) {json.deprecated = msg.deprecated;}
if (msg.uninterpretedOption?.length) {json.uninterpretedOption = msg.uninterpretedOption.map(UninterpretedOption._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: EnumValueOptions, reader: BinaryReader): EnumValueOptions {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.deprecated = reader.readBool();break;
}
case 999: {const m = UninterpretedOption.initialize();reader.readMessage(m, UninterpretedOption._readMessage);msg.uninterpretedOption.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: EnumValueOptions, json: any): EnumValueOptions {
          const deprecated = json.deprecated ?? json.deprecated;if (deprecated) {msg.deprecated = deprecated;}
const uninterpretedOption = json.uninterpretedOption ?? json.uninterpreted_option;if (uninterpretedOption) {for (const item of uninterpretedOption) {const m = UninterpretedOption.initialize();UninterpretedOption._readMessageJSON(m, item);msg.uninterpretedOption.push(m);}}
          return msg;
        },

      };

export const ServiceOptions = {        /**
         * Serializes a ServiceOptions to protobuf.
         */
        encode: function(serviceOptions: Partial<ServiceOptions>): Uint8Array {
          return ServiceOptions._writeMessage(serviceOptions, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a ServiceOptions from protobuf.
         */
        decode: function(bytes: ByteSource): ServiceOptions {
          return ServiceOptions._readMessage(ServiceOptions.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a ServiceOptions to JSON.
         */
        encodeJSON: function(serviceOptions: Partial<ServiceOptions>): string {
          return JSON.stringify(ServiceOptions._writeMessageJSON(serviceOptions));
        },
        

        /**
         * Deserializes a ServiceOptions from JSON.
         */
        decodeJSON: function(json: string): ServiceOptions {
          return ServiceOptions._readMessageJSON(ServiceOptions.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a ServiceOptions with all fields set to their default value.
         */
        initialize: function(): ServiceOptions {
          return {
            deprecated: false,uninterpretedOption: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<ServiceOptions>, writer: BinaryWriter): BinaryWriter {
          if (msg.deprecated) {writer.writeBool(33, msg.deprecated);}
if (msg.uninterpretedOption?.length) {writer.writeRepeatedMessage(999, msg.uninterpretedOption as any, UninterpretedOption._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<ServiceOptions>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.deprecated) {json.deprecated = msg.deprecated;}
if (msg.uninterpretedOption?.length) {json.uninterpretedOption = msg.uninterpretedOption.map(UninterpretedOption._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: ServiceOptions, reader: BinaryReader): ServiceOptions {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 33: {msg.deprecated = reader.readBool();break;
}
case 999: {const m = UninterpretedOption.initialize();reader.readMessage(m, UninterpretedOption._readMessage);msg.uninterpretedOption.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: ServiceOptions, json: any): ServiceOptions {
          const deprecated = json.deprecated ?? json.deprecated;if (deprecated) {msg.deprecated = deprecated;}
const uninterpretedOption = json.uninterpretedOption ?? json.uninterpreted_option;if (uninterpretedOption) {for (const item of uninterpretedOption) {const m = UninterpretedOption.initialize();UninterpretedOption._readMessageJSON(m, item);msg.uninterpretedOption.push(m);}}
          return msg;
        },

      };

export const MethodOptions = {        /**
         * Serializes a MethodOptions to protobuf.
         */
        encode: function(methodOptions: Partial<MethodOptions>): Uint8Array {
          return MethodOptions._writeMessage(methodOptions, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a MethodOptions from protobuf.
         */
        decode: function(bytes: ByteSource): MethodOptions {
          return MethodOptions._readMessage(MethodOptions.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a MethodOptions to JSON.
         */
        encodeJSON: function(methodOptions: Partial<MethodOptions>): string {
          return JSON.stringify(MethodOptions._writeMessageJSON(methodOptions));
        },
        

        /**
         * Deserializes a MethodOptions from JSON.
         */
        decodeJSON: function(json: string): MethodOptions {
          return MethodOptions._readMessageJSON(MethodOptions.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a MethodOptions with all fields set to their default value.
         */
        initialize: function(): MethodOptions {
          return {
            deprecated: false,idempotencyLevel: 0,uninterpretedOption: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<MethodOptions>, writer: BinaryWriter): BinaryWriter {
          if (msg.deprecated) {writer.writeBool(33, msg.deprecated);}
if (msg.idempotencyLevel) {writer.writeEnum(34, msg.idempotencyLevel);}
if (msg.uninterpretedOption?.length) {writer.writeRepeatedMessage(999, msg.uninterpretedOption as any, UninterpretedOption._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<MethodOptions>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.deprecated) {json.deprecated = msg.deprecated;}
if (msg.idempotencyLevel) {json.idempotencyLevel = msg.idempotencyLevel;}
if (msg.uninterpretedOption?.length) {json.uninterpretedOption = msg.uninterpretedOption.map(UninterpretedOption._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: MethodOptions, reader: BinaryReader): MethodOptions {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 33: {msg.deprecated = reader.readBool();break;
}
case 34: {msg.idempotencyLevel = reader.readEnum() as MethodOptions.IdempotencyLevel;break;
}
case 999: {const m = UninterpretedOption.initialize();reader.readMessage(m, UninterpretedOption._readMessage);msg.uninterpretedOption.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: MethodOptions, json: any): MethodOptions {
          const deprecated = json.deprecated ?? json.deprecated;if (deprecated) {msg.deprecated = deprecated;}
const idempotencyLevel = json.idempotencyLevel ?? json.idempotency_level;if (idempotencyLevel) {msg.idempotencyLevel = idempotencyLevel;}
const uninterpretedOption = json.uninterpretedOption ?? json.uninterpreted_option;if (uninterpretedOption) {for (const item of uninterpretedOption) {const m = UninterpretedOption.initialize();UninterpretedOption._readMessageJSON(m, item);msg.uninterpretedOption.push(m);}}
          return msg;
        },

      IdempotencyLevel: {IDEMPOTENCY_UNKNOWN: 0,
NO_SIDE_EFFECTS: 1,
IDEMPOTENT: 2,
} as const,

};

export const UninterpretedOption = {        /**
         * Serializes a UninterpretedOption to protobuf.
         */
        encode: function(uninterpretedOption: Partial<UninterpretedOption>): Uint8Array {
          return UninterpretedOption._writeMessage(uninterpretedOption, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a UninterpretedOption from protobuf.
         */
        decode: function(bytes: ByteSource): UninterpretedOption {
          return UninterpretedOption._readMessage(UninterpretedOption.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a UninterpretedOption to JSON.
         */
        encodeJSON: function(uninterpretedOption: Partial<UninterpretedOption>): string {
          return JSON.stringify(UninterpretedOption._writeMessageJSON(uninterpretedOption));
        },
        

        /**
         * Deserializes a UninterpretedOption from JSON.
         */
        decodeJSON: function(json: string): UninterpretedOption {
          return UninterpretedOption._readMessageJSON(UninterpretedOption.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a UninterpretedOption with all fields set to their default value.
         */
        initialize: function(): UninterpretedOption {
          return {
            name: [],identifierValue: '',positiveIntValue: 0n,negativeIntValue: 0n,doubleValue: 0,stringValue: new Uint8Array(),aggregateValue: '',
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<UninterpretedOption>, writer: BinaryWriter): BinaryWriter {
          if (msg.name?.length) {writer.writeRepeatedMessage(2, msg.name as any, UninterpretedOption.NamePart._writeMessage);}
if (msg.identifierValue) {writer.writeString(3, msg.identifierValue);}
if (msg.positiveIntValue) {writer.writeUint64String(4, msg.positiveIntValue.toString());}
if (msg.negativeIntValue) {writer.writeInt64String(5, msg.negativeIntValue.toString());}
if (msg.doubleValue) {writer.writeDouble(6, msg.doubleValue);}
if (msg.stringValue) {writer.writeBytes(7, msg.stringValue);}
if (msg.aggregateValue) {writer.writeString(8, msg.aggregateValue);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<UninterpretedOption>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name?.length) {json.name = msg.name.map(UninterpretedOption.NamePart._writeMessageJSON)}
if (msg.identifierValue) {json.identifierValue = msg.identifierValue;}
if (msg.positiveIntValue) {json.positiveIntValue = msg.positiveIntValue.toString();}
if (msg.negativeIntValue) {json.negativeIntValue = msg.negativeIntValue.toString();}
if (msg.doubleValue) {json.doubleValue = msg.doubleValue;}
if (msg.stringValue) {json.stringValue = msg.stringValue;}
if (msg.aggregateValue) {json.aggregateValue = msg.aggregateValue;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: UninterpretedOption, reader: BinaryReader): UninterpretedOption {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 2: {const m = UninterpretedOption.NamePart.initialize();reader.readMessage(m, UninterpretedOption.NamePart._readMessage);msg.name.push(m);break;
}
case 3: {msg.identifierValue = reader.readString();break;
}
case 4: {msg.positiveIntValue = BigInt(reader.readUint64String());break;
}
case 5: {msg.negativeIntValue = BigInt(reader.readInt64String());break;
}
case 6: {msg.doubleValue = reader.readDouble();break;
}
case 7: {msg.stringValue = reader.readBytes();break;
}
case 8: {msg.aggregateValue = reader.readString();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: UninterpretedOption, json: any): UninterpretedOption {
          const name = json.name ?? json.name;if (name) {for (const item of name) {const m = UninterpretedOption.NamePart.initialize();UninterpretedOption.NamePart._readMessageJSON(m, item);msg.name.push(m);}}
const identifierValue = json.identifierValue ?? json.identifier_value;if (identifierValue) {msg.identifierValue = identifierValue;}
const positiveIntValue = json.positiveIntValue ?? json.positive_int_value;if (positiveIntValue) {msg.positiveIntValue = BigInt(positiveIntValue);}
const negativeIntValue = json.negativeIntValue ?? json.negative_int_value;if (negativeIntValue) {msg.negativeIntValue = BigInt(negativeIntValue);}
const doubleValue = json.doubleValue ?? json.double_value;if (doubleValue) {msg.doubleValue = doubleValue;}
const stringValue = json.stringValue ?? json.string_value;if (stringValue) {msg.stringValue = stringValue;}
const aggregateValue = json.aggregateValue ?? json.aggregate_value;if (aggregateValue) {msg.aggregateValue = aggregateValue;}
          return msg;
        },

      NamePart: {        /**
         * Serializes a UninterpretedOption.NamePart to protobuf.
         */
        encode: function(namePart: Partial<UninterpretedOption.NamePart>): Uint8Array {
          return UninterpretedOption.NamePart._writeMessage(namePart, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a UninterpretedOption.NamePart from protobuf.
         */
        decode: function(bytes: ByteSource): UninterpretedOption.NamePart {
          return UninterpretedOption.NamePart._readMessage(UninterpretedOption.NamePart.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a UninterpretedOption.NamePart to JSON.
         */
        encodeJSON: function(namePart: Partial<UninterpretedOption.NamePart>): string {
          return JSON.stringify(UninterpretedOption.NamePart._writeMessageJSON(namePart));
        },
        

        /**
         * Deserializes a UninterpretedOption.NamePart from JSON.
         */
        decodeJSON: function(json: string): UninterpretedOption.NamePart {
          return UninterpretedOption.NamePart._readMessageJSON(UninterpretedOption.NamePart.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a UninterpretedOption.NamePart with all fields set to their default value.
         */
        initialize: function(): UninterpretedOption.NamePart {
          return {
            namePart: '',isExtension: false,
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<UninterpretedOption.NamePart>, writer: BinaryWriter): BinaryWriter {
          if (msg.namePart) {writer.writeString(1, msg.namePart);}
if (msg.isExtension) {writer.writeBool(2, msg.isExtension);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<UninterpretedOption.NamePart>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.namePart) {json.namePart = msg.namePart;}
if (msg.isExtension) {json.isExtension = msg.isExtension;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: UninterpretedOption.NamePart, reader: BinaryReader): UninterpretedOption.NamePart {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.namePart = reader.readString();break;
}
case 2: {msg.isExtension = reader.readBool();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: UninterpretedOption.NamePart, json: any): UninterpretedOption.NamePart {
          const namePart = json.namePart ?? json.name_part;if (namePart) {msg.namePart = namePart;}
const isExtension = json.isExtension ?? json.is_extension;if (isExtension) {msg.isExtension = isExtension;}
          return msg;
        },

      },

};

export const SourceCodeInfo = {        /**
         * Serializes a SourceCodeInfo to protobuf.
         */
        encode: function(sourceCodeInfo: Partial<SourceCodeInfo>): Uint8Array {
          return SourceCodeInfo._writeMessage(sourceCodeInfo, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a SourceCodeInfo from protobuf.
         */
        decode: function(bytes: ByteSource): SourceCodeInfo {
          return SourceCodeInfo._readMessage(SourceCodeInfo.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a SourceCodeInfo to JSON.
         */
        encodeJSON: function(sourceCodeInfo: Partial<SourceCodeInfo>): string {
          return JSON.stringify(SourceCodeInfo._writeMessageJSON(sourceCodeInfo));
        },
        

        /**
         * Deserializes a SourceCodeInfo from JSON.
         */
        decodeJSON: function(json: string): SourceCodeInfo {
          return SourceCodeInfo._readMessageJSON(SourceCodeInfo.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a SourceCodeInfo with all fields set to their default value.
         */
        initialize: function(): SourceCodeInfo {
          return {
            location: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<SourceCodeInfo>, writer: BinaryWriter): BinaryWriter {
          if (msg.location?.length) {writer.writeRepeatedMessage(1, msg.location as any, SourceCodeInfo.Location._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<SourceCodeInfo>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.location?.length) {json.location = msg.location.map(SourceCodeInfo.Location._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: SourceCodeInfo, reader: BinaryReader): SourceCodeInfo {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {const m = SourceCodeInfo.Location.initialize();reader.readMessage(m, SourceCodeInfo.Location._readMessage);msg.location.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: SourceCodeInfo, json: any): SourceCodeInfo {
          const location = json.location ?? json.location;if (location) {for (const item of location) {const m = SourceCodeInfo.Location.initialize();SourceCodeInfo.Location._readMessageJSON(m, item);msg.location.push(m);}}
          return msg;
        },

      Location: {        /**
         * Serializes a SourceCodeInfo.Location to protobuf.
         */
        encode: function(location: Partial<SourceCodeInfo.Location>): Uint8Array {
          return SourceCodeInfo.Location._writeMessage(location, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a SourceCodeInfo.Location from protobuf.
         */
        decode: function(bytes: ByteSource): SourceCodeInfo.Location {
          return SourceCodeInfo.Location._readMessage(SourceCodeInfo.Location.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a SourceCodeInfo.Location to JSON.
         */
        encodeJSON: function(location: Partial<SourceCodeInfo.Location>): string {
          return JSON.stringify(SourceCodeInfo.Location._writeMessageJSON(location));
        },
        

        /**
         * Deserializes a SourceCodeInfo.Location from JSON.
         */
        decodeJSON: function(json: string): SourceCodeInfo.Location {
          return SourceCodeInfo.Location._readMessageJSON(SourceCodeInfo.Location.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a SourceCodeInfo.Location with all fields set to their default value.
         */
        initialize: function(): SourceCodeInfo.Location {
          return {
            path: [],span: [],leadingComments: '',trailingComments: '',leadingDetachedComments: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<SourceCodeInfo.Location>, writer: BinaryWriter): BinaryWriter {
          if (msg.path?.length) {writer.writeRepeatedInt32(1, msg.path);}
if (msg.span?.length) {writer.writeRepeatedInt32(2, msg.span);}
if (msg.leadingComments) {writer.writeString(3, msg.leadingComments);}
if (msg.trailingComments) {writer.writeString(4, msg.trailingComments);}
if (msg.leadingDetachedComments?.length) {writer.writeRepeatedString(6, msg.leadingDetachedComments);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<SourceCodeInfo.Location>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.path?.length) {json.path = msg.path;}
if (msg.span?.length) {json.span = msg.span;}
if (msg.leadingComments) {json.leadingComments = msg.leadingComments;}
if (msg.trailingComments) {json.trailingComments = msg.trailingComments;}
if (msg.leadingDetachedComments?.length) {json.leadingDetachedComments = msg.leadingDetachedComments;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: SourceCodeInfo.Location, reader: BinaryReader): SourceCodeInfo.Location {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.path.push(reader.readInt32());break;
}
case 2: {msg.span.push(reader.readInt32());break;
}
case 3: {msg.leadingComments = reader.readString();break;
}
case 4: {msg.trailingComments = reader.readString();break;
}
case 6: {msg.leadingDetachedComments.push(reader.readString());break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: SourceCodeInfo.Location, json: any): SourceCodeInfo.Location {
          const path = json.path ?? json.path;if (path) {msg.path = path;}
const span = json.span ?? json.span;if (span) {msg.span = span;}
const leadingComments = json.leadingComments ?? json.leading_comments;if (leadingComments) {msg.leadingComments = leadingComments;}
const trailingComments = json.trailingComments ?? json.trailing_comments;if (trailingComments) {msg.trailingComments = trailingComments;}
const leadingDetachedComments = json.leadingDetachedComments ?? json.leading_detached_comments;if (leadingDetachedComments) {msg.leadingDetachedComments = leadingDetachedComments;}
          return msg;
        },

      },

};

export const GeneratedCodeInfo = {        /**
         * Serializes a GeneratedCodeInfo to protobuf.
         */
        encode: function(generatedCodeInfo: Partial<GeneratedCodeInfo>): Uint8Array {
          return GeneratedCodeInfo._writeMessage(generatedCodeInfo, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a GeneratedCodeInfo from protobuf.
         */
        decode: function(bytes: ByteSource): GeneratedCodeInfo {
          return GeneratedCodeInfo._readMessage(GeneratedCodeInfo.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a GeneratedCodeInfo to JSON.
         */
        encodeJSON: function(generatedCodeInfo: Partial<GeneratedCodeInfo>): string {
          return JSON.stringify(GeneratedCodeInfo._writeMessageJSON(generatedCodeInfo));
        },
        

        /**
         * Deserializes a GeneratedCodeInfo from JSON.
         */
        decodeJSON: function(json: string): GeneratedCodeInfo {
          return GeneratedCodeInfo._readMessageJSON(GeneratedCodeInfo.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a GeneratedCodeInfo with all fields set to their default value.
         */
        initialize: function(): GeneratedCodeInfo {
          return {
            annotation: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<GeneratedCodeInfo>, writer: BinaryWriter): BinaryWriter {
          if (msg.annotation?.length) {writer.writeRepeatedMessage(1, msg.annotation as any, GeneratedCodeInfo.Annotation._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<GeneratedCodeInfo>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.annotation?.length) {json.annotation = msg.annotation.map(GeneratedCodeInfo.Annotation._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: GeneratedCodeInfo, reader: BinaryReader): GeneratedCodeInfo {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {const m = GeneratedCodeInfo.Annotation.initialize();reader.readMessage(m, GeneratedCodeInfo.Annotation._readMessage);msg.annotation.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: GeneratedCodeInfo, json: any): GeneratedCodeInfo {
          const annotation = json.annotation ?? json.annotation;if (annotation) {for (const item of annotation) {const m = GeneratedCodeInfo.Annotation.initialize();GeneratedCodeInfo.Annotation._readMessageJSON(m, item);msg.annotation.push(m);}}
          return msg;
        },

      Annotation: {        /**
         * Serializes a GeneratedCodeInfo.Annotation to protobuf.
         */
        encode: function(annotation: Partial<GeneratedCodeInfo.Annotation>): Uint8Array {
          return GeneratedCodeInfo.Annotation._writeMessage(annotation, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a GeneratedCodeInfo.Annotation from protobuf.
         */
        decode: function(bytes: ByteSource): GeneratedCodeInfo.Annotation {
          return GeneratedCodeInfo.Annotation._readMessage(GeneratedCodeInfo.Annotation.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a GeneratedCodeInfo.Annotation to JSON.
         */
        encodeJSON: function(annotation: Partial<GeneratedCodeInfo.Annotation>): string {
          return JSON.stringify(GeneratedCodeInfo.Annotation._writeMessageJSON(annotation));
        },
        

        /**
         * Deserializes a GeneratedCodeInfo.Annotation from JSON.
         */
        decodeJSON: function(json: string): GeneratedCodeInfo.Annotation {
          return GeneratedCodeInfo.Annotation._readMessageJSON(GeneratedCodeInfo.Annotation.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a GeneratedCodeInfo.Annotation with all fields set to their default value.
         */
        initialize: function(): GeneratedCodeInfo.Annotation {
          return {
            path: [],sourceFile: '',begin: 0,end: 0,
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<GeneratedCodeInfo.Annotation>, writer: BinaryWriter): BinaryWriter {
          if (msg.path?.length) {writer.writeRepeatedInt32(1, msg.path);}
if (msg.sourceFile) {writer.writeString(2, msg.sourceFile);}
if (msg.begin) {writer.writeInt32(3, msg.begin);}
if (msg.end) {writer.writeInt32(4, msg.end);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<GeneratedCodeInfo.Annotation>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.path?.length) {json.path = msg.path;}
if (msg.sourceFile) {json.sourceFile = msg.sourceFile;}
if (msg.begin) {json.begin = msg.begin;}
if (msg.end) {json.end = msg.end;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: GeneratedCodeInfo.Annotation, reader: BinaryReader): GeneratedCodeInfo.Annotation {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.path.push(reader.readInt32());break;
}
case 2: {msg.sourceFile = reader.readString();break;
}
case 3: {msg.begin = reader.readInt32();break;
}
case 4: {msg.end = reader.readInt32();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: GeneratedCodeInfo.Annotation, json: any): GeneratedCodeInfo.Annotation {
          const path = json.path ?? json.path;if (path) {msg.path = path;}
const sourceFile = json.sourceFile ?? json.source_file;if (sourceFile) {msg.sourceFile = sourceFile;}
const begin = json.begin ?? json.begin;if (begin) {msg.begin = begin;}
const end = json.end ?? json.end;if (end) {msg.end = end;}
          return msg;
        },

      },

};


