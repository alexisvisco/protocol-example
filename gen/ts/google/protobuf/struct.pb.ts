// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/struct.proto


import type {
    ByteSource,

    } from 'twirpscript';
import {
  BinaryReader,
BinaryWriter,

  } from 'twirpscript';
  







  //========================================//
  //                 Types                  //
  //========================================//
  
  
    /**
     * `NullValue` is a singleton enumeration to represent the null value for the
 * `Value` type union.
 *
 *  The JSON representation for `NullValue` is JSON `null`.
     */
      export type NullValue = typeof NullValue[keyof typeof NullValue];

    /**
     * `Struct` represents a structured data value, consisting of fields
 * which map to dynamically typed values. In some languages, `Struct`
 * might be supported by a native representation. For example, in
 * scripting languages like JS a struct is represented as an
 * object. The details of that representation are described together
 * with the proto support for the language.
 *
 * The JSON representation for `Struct` is JSON object.
     */
      export interface Struct {
    /**
     * Unordered map of dynamically typed values.
     */
      fields: Record<
              string,
              Value | undefined>;
}

    /**
     * `Value` represents a dynamically typed value which can be either
 * null, a number, a string, a boolean, a recursive struct value, or a
 * list of values. A producer of value is expected to set one of that
 * variants, absence of any variant indicates an error.
 *
 * The JSON representation for `Value` is JSON value.
     */
      export interface Value {
    /**
     * Represents a null value.
     */
      nullValue?: NullValue| null | undefined;
    /**
     * Represents a double value.
     */
      numberValue?: number| null | undefined;
    /**
     * Represents a string value.
     */
      stringValue?: string| null | undefined;
    /**
     * Represents a boolean value.
     */
      boolValue?: boolean| null | undefined;
    /**
     * Represents a structured value.
     */
      structValue?: Struct| null | undefined;
    /**
     * Represents a repeated `Value`.
     */
      listValue?: ListValue| null | undefined;
}

    /**
     * `ListValue` is a wrapper around a repeated field of values.
 *
 * The JSON representation for `ListValue` is JSON array.
     */
      export interface ListValue {
    /**
     * Repeated field of dynamically typed values.
     */
      values: Value[];
}


  //========================================//
  //        Protobuf Encode / Decode        //
  //========================================//
  
  
export const NullValue = {    /**
     * Null value.
     */
      NULL_VALUE: 0,
} as const;

export const Struct = {        /**
         * Serializes a Struct to protobuf.
         */
        encode: function(struct: Partial<Struct>): Uint8Array {
          return Struct._writeMessage(struct, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Struct from protobuf.
         */
        decode: function(bytes: ByteSource): Struct {
          return Struct._readMessage(Struct.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Struct to JSON.
         */
        encodeJSON: function(struct: Partial<Struct>): string {
          return JSON.stringify(Struct._writeMessageJSON(struct));
        },
        

        /**
         * Deserializes a Struct from JSON.
         */
        decodeJSON: function(json: string): Struct {
          return Struct._readMessageJSON(Struct.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Struct with all fields set to their default value.
         */
        initialize: function(): Struct {
          return {
            fields: {},
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Struct>, writer: BinaryWriter): BinaryWriter {
          if (msg.fields) {for (const [key, value] of Object.entries(msg.fields)) {
                  if (value) {
                    writer.writeMessage(1, {}, (_, mapWriter) => {
                mapWriter.writeString(1, key as any);mapWriter.writeMessage(2, value, Value._writeMessage);})
}}}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Struct>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.fields) {const map: Record<string, unknown> = {};for (const [key, value] of Object.entries(msg.fields)) {
                  if (value) {map[key] =Value._writeMessageJSON(value);json.fields = map}
}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Struct, reader: BinaryReader): Struct {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {reader.readMessage(undefined, () => {
                      let key: string | undefined;
                      let value = undefined;
                      while (reader.nextField()) {
                        const field = reader.getFieldNumber();
                        switch (field) {
                          case 1: {
                            key = reader.readString();
                            break;
                          }
                          case 2: {
                        reader.readMessage(Value.initialize(), Value._readMessage);break;
                          }
                        }
                      }
                      if (key) {
                        msg.fields[key] = value;
                      }
                    });break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Struct, json: any): Struct {
          const fields = json.fields ?? json.fields;if (fields) {for (const [key, value] of Object.entries<Value>(fields)) {msg.fields[key] =Value._readMessageJSON(Value.initialize(), value);}}
          return msg;
        },

      };

export const Value = {        /**
         * Serializes a Value to protobuf.
         */
        encode: function(value: Partial<Value>): Uint8Array {
          return Value._writeMessage(value, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Value from protobuf.
         */
        decode: function(bytes: ByteSource): Value {
          return Value._readMessage(Value.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Value to JSON.
         */
        encodeJSON: function(value: Partial<Value>): string {
          return JSON.stringify(Value._writeMessageJSON(value));
        },
        

        /**
         * Deserializes a Value from JSON.
         */
        decodeJSON: function(json: string): Value {
          return Value._readMessageJSON(Value.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Value with all fields set to their default value.
         */
        initialize: function(): Value {
          return {
            structValue: Struct.initialize(),listValue: ListValue.initialize(),
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Value>, writer: BinaryWriter): BinaryWriter {
          if (msg.nullValue != undefined) {writer.writeEnum(1, msg.nullValue);}
if (msg.numberValue != undefined) {writer.writeDouble(2, msg.numberValue);}
if (msg.stringValue != undefined) {writer.writeString(3, msg.stringValue);}
if (msg.boolValue != undefined) {writer.writeBool(4, msg.boolValue);}
if (msg.structValue != undefined) {writer.writeMessage(5, msg.structValue , Struct._writeMessage);}
if (msg.listValue != undefined) {writer.writeMessage(6, msg.listValue , ListValue._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Value>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.nullValue != undefined) {json.nullValue = msg.nullValue;}
if (msg.numberValue != undefined) {json.numberValue = msg.numberValue;}
if (msg.stringValue != undefined) {json.stringValue = msg.stringValue;}
if (msg.boolValue != undefined) {json.boolValue = msg.boolValue;}
if (msg.structValue != undefined) {const structValue = Struct._writeMessageJSON(msg.structValue);if (Object.keys(structValue).length > 0) {json.structValue = structValue;}}
if (msg.listValue != undefined) {const listValue = ListValue._writeMessageJSON(msg.listValue);if (Object.keys(listValue).length > 0) {json.listValue = listValue;}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Value, reader: BinaryReader): Value {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.nullValue = reader.readEnum() as NullValue;break;
}
case 2: {msg.numberValue = reader.readDouble();break;
}
case 3: {msg.stringValue = reader.readString();break;
}
case 4: {msg.boolValue = reader.readBool();break;
}
case 5: {
                      reader.readMessage(msg.structValue, Struct._readMessage);
                    break;
}
case 6: {
                      reader.readMessage(msg.listValue, ListValue._readMessage);
                    break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Value, json: any): Value {
          const nullValue = json.nullValue ?? json.null_value;if (nullValue) {msg.nullValue = nullValue;}
const numberValue = json.numberValue ?? json.number_value;if (numberValue) {msg.numberValue = numberValue;}
const stringValue = json.stringValue ?? json.string_value;if (stringValue) {msg.stringValue = stringValue;}
const boolValue = json.boolValue ?? json.bool_value;if (boolValue) {msg.boolValue = boolValue;}
const structValue = json.structValue ?? json.struct_value;if (structValue) {const m = Struct.initialize();Struct._readMessageJSON(m, structValue);msg.structValue = m;}
const listValue = json.listValue ?? json.list_value;if (listValue) {const m = ListValue.initialize();ListValue._readMessageJSON(m, listValue);msg.listValue = m;}
          return msg;
        },

      };

export const ListValue = {        /**
         * Serializes a ListValue to protobuf.
         */
        encode: function(listValue: Partial<ListValue>): Uint8Array {
          return ListValue._writeMessage(listValue, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a ListValue from protobuf.
         */
        decode: function(bytes: ByteSource): ListValue {
          return ListValue._readMessage(ListValue.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a ListValue to JSON.
         */
        encodeJSON: function(listValue: Partial<ListValue>): string {
          return JSON.stringify(ListValue._writeMessageJSON(listValue));
        },
        

        /**
         * Deserializes a ListValue from JSON.
         */
        decodeJSON: function(json: string): ListValue {
          return ListValue._readMessageJSON(ListValue.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a ListValue with all fields set to their default value.
         */
        initialize: function(): ListValue {
          return {
            values: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<ListValue>, writer: BinaryWriter): BinaryWriter {
          if (msg.values?.length) {writer.writeRepeatedMessage(1, msg.values as any, Value._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<ListValue>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.values?.length) {json.values = msg.values.map(Value._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: ListValue, reader: BinaryReader): ListValue {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {const m = Value.initialize();reader.readMessage(m, Value._readMessage);msg.values.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: ListValue, json: any): ListValue {
          const values = json.values ?? json.values;if (values) {for (const item of values) {const m = Value.initialize();Value._readMessageJSON(m, item);msg.values.push(m);}}
          return msg;
        },

      };


