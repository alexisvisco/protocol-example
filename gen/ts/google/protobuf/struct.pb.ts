// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/struct.proto

import type { ByteSource, MapMessage } from "twirpscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

/**
 * `NullValue` is a singleton enumeration to represent the null value for the
 * `Value` type union.
 *
 *  The JSON representation for `NullValue` is JSON `null`.
 */
export type NullValue = "NULL_VALUE";

/**
 * `Struct` represents a structured data value, consisting of fields
 * which map to dynamically typed values. In some languages, `Struct`
 * might be supported by a native representation. For example, in
 * scripting languages like JS a struct is represented as an
 * object. The details of that representation are described together
 * with the proto support for the language.
 *
 * The JSON representation for `Struct` is JSON object.
 */
export interface Struct {
  /**
   * Unordered map of dynamically typed values.
   */
  fields: Struct.Fields;
}

declare namespace Struct {
  export type Fields = Record<string, Value | undefined>;
}

/**
 * `Value` represents a dynamically typed value which can be either
 * null, a number, a string, a boolean, a recursive struct value, or a
 * list of values. A producer of value is expected to set one of that
 * variants, absence of any variant indicates an error.
 *
 * The JSON representation for `Value` is JSON value.
 */
export interface Value {
  /**
   * Represents a null value.
   */
  nullValue?: NullValue | null | undefined;
  /**
   * Represents a double value.
   */
  numberValue?: number | null | undefined;
  /**
   * Represents a string value.
   */
  stringValue?: string | null | undefined;
  /**
   * Represents a boolean value.
   */
  boolValue?: boolean | null | undefined;
  /**
   * Represents a structured value.
   */
  structValue?: Struct | null | undefined;
  /**
   * Represents a repeated `Value`.
   */
  listValue?: ListValue | null | undefined;
}

/**
 * `ListValue` is a wrapper around a repeated field of values.
 *
 * The JSON representation for `ListValue` is JSON array.
 */
export interface ListValue {
  /**
   * Repeated field of dynamically typed values.
   */
  values: Value[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const NullValue = {
  /**
   * Null value.
   */
  NULL_VALUE: "NULL_VALUE",
} as const;

const NullValueFromInt = function (i: number): NullValue {
  switch (i) {
    case 0: {
      return "NULL_VALUE";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as NullValue;
    }
  }
};

const NullValueToInt = function (i: NullValue): number {
  switch (i) {
    case "NULL_VALUE": {
      return 0;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const Struct = {
  /**
   * Serializes a Struct to protobuf.
   */
  encode: function (msg: Partial<Struct>): Uint8Array {
    return Struct._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Struct from protobuf.
   */
  decode: function (bytes: ByteSource): Struct {
    return Struct._readMessage(Struct.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Struct to JSON.
   */
  encodeJSON: function (msg: Partial<Struct>): string {
    return JSON.stringify(Struct._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Struct from JSON.
   */
  decodeJSON: function (json: string): Struct {
    return Struct._readMessageJSON(Struct.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Struct with all fields set to their default value.
   */
  initialize: function (): Struct {
    return {
      fields: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Struct>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fields) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.fields).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        Struct.Fields._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Struct>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fields) {
      const fields = Object.fromEntries(
        Object.entries<any>(msg.fields)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Struct.Fields._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(fields).length > 0) {
        json.fields = fields;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Struct, reader: BinaryReader): Struct {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const fields = {} as MapMessage<Struct.Fields>;
          reader.readMessage(fields, Struct.Fields._readMessage);
          msg.fields[fields.key] = fields.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Struct, json: any): Struct {
    const _fields = json.fields;
    if (_fields) {
      msg.fields = Object.fromEntries(
        Object.entries<any>(_fields)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Struct.Fields._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Fields: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<Struct.Fields>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<Struct.Fields>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<Struct.Fields>,
      reader: BinaryReader
    ): MapMessage<Struct.Fields> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Value.initialize(), Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<Struct.Fields>,
      json: any
    ): MapMessage<Struct.Fields> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Value.initialize();
        Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const Value = {
  /**
   * Serializes a Value to protobuf.
   */
  encode: function (msg: Partial<Value>): Uint8Array {
    return Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Value from protobuf.
   */
  decode: function (bytes: ByteSource): Value {
    return Value._readMessage(Value.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Value to JSON.
   */
  encodeJSON: function (msg: Partial<Value>): string {
    return JSON.stringify(Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Value from JSON.
   */
  decodeJSON: function (json: string): Value {
    return Value._readMessageJSON(Value.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Value with all fields set to their default value.
   */
  initialize: function (): Value {
    return {
      structValue: Struct.initialize(),
      listValue: ListValue.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Value>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.nullValue != undefined) {
      writer.writeEnum(1, NullValueToInt(msg.nullValue));
    }
    if (msg.numberValue != undefined) {
      writer.writeDouble(2, msg.numberValue);
    }
    if (msg.stringValue != undefined) {
      writer.writeString(3, msg.stringValue);
    }
    if (msg.boolValue != undefined) {
      writer.writeBool(4, msg.boolValue);
    }
    if (msg.structValue != undefined) {
      writer.writeMessage(5, msg.structValue, Struct._writeMessage);
    }
    if (msg.listValue != undefined) {
      writer.writeMessage(6, msg.listValue, ListValue._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Value>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.nullValue != undefined) {
      json.nullValue = msg.nullValue;
    }
    if (msg.numberValue != undefined) {
      json.numberValue = msg.numberValue;
    }
    if (msg.stringValue != undefined) {
      json.stringValue = msg.stringValue;
    }
    if (msg.boolValue != undefined) {
      json.boolValue = msg.boolValue;
    }
    if (msg.structValue != undefined) {
      const structValue = Struct._writeMessageJSON(msg.structValue);
      if (Object.keys(structValue).length > 0) {
        json.structValue = structValue;
      }
    }
    if (msg.listValue != undefined) {
      const listValue = ListValue._writeMessageJSON(msg.listValue);
      if (Object.keys(listValue).length > 0) {
        json.listValue = listValue;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Value, reader: BinaryReader): Value {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.nullValue = NullValueFromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.numberValue = reader.readDouble();
          break;
        }
        case 3: {
          msg.stringValue = reader.readString();
          break;
        }
        case 4: {
          msg.boolValue = reader.readBool();
          break;
        }
        case 5: {
          reader.readMessage(msg.structValue, Struct._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(msg.listValue, ListValue._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Value, json: any): Value {
    const _nullValue = json.nullValue ?? json.null_value;
    if (_nullValue) {
      msg.nullValue = _nullValue;
    }
    const _numberValue = json.numberValue ?? json.number_value;
    if (_numberValue) {
      msg.numberValue = _numberValue;
    }
    const _stringValue = json.stringValue ?? json.string_value;
    if (_stringValue) {
      msg.stringValue = _stringValue;
    }
    const _boolValue = json.boolValue ?? json.bool_value;
    if (_boolValue) {
      msg.boolValue = _boolValue;
    }
    const _structValue = json.structValue ?? json.struct_value;
    if (_structValue) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structValue);
      msg.structValue = m;
    }
    const _listValue = json.listValue ?? json.list_value;
    if (_listValue) {
      const m = ListValue.initialize();
      ListValue._readMessageJSON(m, _listValue);
      msg.listValue = m;
    }
    return msg;
  },
};

export const ListValue = {
  /**
   * Serializes a ListValue to protobuf.
   */
  encode: function (msg: Partial<ListValue>): Uint8Array {
    return ListValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a ListValue from protobuf.
   */
  decode: function (bytes: ByteSource): ListValue {
    return ListValue._readMessage(
      ListValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ListValue to JSON.
   */
  encodeJSON: function (msg: Partial<ListValue>): string {
    return JSON.stringify(ListValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ListValue from JSON.
   */
  decodeJSON: function (json: string): ListValue {
    return ListValue._readMessageJSON(ListValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a ListValue with all fields set to their default value.
   */
  initialize: function (): ListValue {
    return {
      values: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ListValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.values?.length) {
      writer.writeRepeatedMessage(1, msg.values as any, Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ListValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.values?.length) {
      json.values = msg.values.map(Value._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ListValue, reader: BinaryReader): ListValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Value.initialize();
          reader.readMessage(m, Value._readMessage);
          msg.values.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ListValue, json: any): ListValue {
    const _values = json.values;
    if (_values) {
      for (const item of _values) {
        const m = Value.initialize();
        Value._readMessageJSON(m, item);
        msg.values.push(m);
      }
    }
    return msg;
  },
};
