// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: protos/dummy/v1/service_dummy.proto


import type {
    ByteSource,

    ClientConfiguration} from 'twirpscript';
import {
  BinaryReader,
BinaryWriter,

  JSONrequest,
PBrequest} from 'twirpscript';
  // This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `yarn twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_44 } from "twirpscript";

import { HealthRequest, HealthResponse } from '../../common/v1/health.pb';

  //========================================//
  //      DummyService Protobuf Client      //
  //========================================//
  
      /**
     *
 * The primary usage of this endpoint is for the Kubernetes probes
 * (readinessProbe, liveProbe, startupProbe) and responds without
 * any authentication or authorization
     */
      export async function Health(healthRequest: HealthRequest, config?: ClientConfiguration): Promise<HealthResponse> {
  const response = await PBrequest('/protos.dummy.v1.DummyService/Health', HealthRequest.encode(healthRequest), config);
  return HealthResponse.decode(response);
}

export async function Log(logRequest: LogRequest, config?: ClientConfiguration): Promise<LogResponse> {
  const response = await PBrequest('/protos.dummy.v1.DummyService/Log', LogRequest.encode(logRequest), config);
  return LogResponse.decode(response);
}

  //========================================//
  //        DummyService JSON Client        //
  //========================================//
  
      /**
     *
 * The primary usage of this endpoint is for the Kubernetes probes
 * (readinessProbe, liveProbe, startupProbe) and responds without
 * any authentication or authorization
     */
      export async function HealthJSON(healthRequest: HealthRequest, config?: ClientConfiguration): Promise<HealthResponse> {
  const response = await JSONrequest<HealthResponse>('/protos.dummy.v1.DummyService/Health', healthRequest, config);
  return response;
}

export async function LogJSON(logRequest: LogRequest, config?: ClientConfiguration): Promise<LogResponse> {
  const response = await JSONrequest<LogResponse>('/protos.dummy.v1.DummyService/Log', logRequest, config);
  return response;
}



  //========================================//
  //              DummyService              //
  //========================================//
  
  export interface DummyService<Context = unknown> {
    /**
     *
 * The primary usage of this endpoint is for the Kubernetes probes
 * (readinessProbe, liveProbe, startupProbe) and responds without
 * any authentication or authorization
     */
      Health: (healthRequest: HealthRequest, context: Context) => Promise<HealthResponse> | HealthResponse;
Log: (logRequest: LogRequest, context: Context) => Promise<LogResponse> | LogResponse;
}

export function createDummyService<Context>(service: DummyService<Context>) { return {
    name: 'protos.dummy.v1.DummyService',
    methods: {
Health: { name: 'Health', handler: service.Health, input: HealthRequest, output: HealthResponse },Log: { name: 'Log', handler: service.Log, input: LogRequest, output: LogResponse },}
} as const
}



  //========================================//
  //                 Types                  //
  //========================================//
  
  
export interface LogRequest {
name: string;
level: LogRequest.LogLevel;
}

export namespace LogRequest { 
export type LogLevel = typeof LogRequest.LogLevel[keyof typeof LogRequest.LogLevel];



}

export interface LogResponse {
response: string;
}


  //========================================//
  //        Protobuf Encode / Decode        //
  //========================================//
  
  
export const LogRequest = {        /**
         * Serializes a LogRequest to protobuf.
         */
        encode: function(logRequest: Partial<LogRequest>): Uint8Array {
          return LogRequest._writeMessage(logRequest, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a LogRequest from protobuf.
         */
        decode: function(bytes: ByteSource): LogRequest {
          return LogRequest._readMessage(LogRequest.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a LogRequest to JSON.
         */
        encodeJSON: function(logRequest: Partial<LogRequest>): string {
          return JSON.stringify(LogRequest._writeMessageJSON(logRequest));
        },
        

        /**
         * Deserializes a LogRequest from JSON.
         */
        decodeJSON: function(json: string): LogRequest {
          return LogRequest._readMessageJSON(LogRequest.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a LogRequest with all fields set to their default value.
         */
        initialize: function(): LogRequest {
          return {
            name: '',level: 0,
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<LogRequest>, writer: BinaryWriter): BinaryWriter {
          if (msg.name) {writer.writeString(1, msg.name);}
if (msg.level) {writer.writeEnum(2, msg.level);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<LogRequest>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name) {json.name = msg.name;}
if (msg.level) {json.level = msg.level;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: LogRequest, reader: BinaryReader): LogRequest {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.name = reader.readString();break;
}
case 2: {msg.level = reader.readEnum() as LogRequest.LogLevel;break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: LogRequest, json: any): LogRequest {
          const name = json.name ?? json.name;if (name) {msg.name = name;}
const level = json.level ?? json.level;if (level) {msg.level = level;}
          return msg;
        },

      LogLevel: {LOG_LEVEL_UNSPECIFIED: 0,
LOG_LEVEL_DEBUG: 1,
LOG_LEVEL_INFO: 2,
LOG_LEVEL_WARN: 3,
LOG_LEVEL_ERROR: 4,
LOG_LEVEL_FATAL: 5,
LOG_LEVEL_PANIC: 6,
LOG_LEVEL_NO: 7,
LOG_LEVEL_DIS: 8,
LOG_LEVEL_TRACE: 9,
} as const,

};

export const LogResponse = {        /**
         * Serializes a LogResponse to protobuf.
         */
        encode: function(logResponse: Partial<LogResponse>): Uint8Array {
          return LogResponse._writeMessage(logResponse, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a LogResponse from protobuf.
         */
        decode: function(bytes: ByteSource): LogResponse {
          return LogResponse._readMessage(LogResponse.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a LogResponse to JSON.
         */
        encodeJSON: function(logResponse: Partial<LogResponse>): string {
          return JSON.stringify(LogResponse._writeMessageJSON(logResponse));
        },
        

        /**
         * Deserializes a LogResponse from JSON.
         */
        decodeJSON: function(json: string): LogResponse {
          return LogResponse._readMessageJSON(LogResponse.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a LogResponse with all fields set to their default value.
         */
        initialize: function(): LogResponse {
          return {
            response: '',
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<LogResponse>, writer: BinaryWriter): BinaryWriter {
          if (msg.response) {writer.writeString(1, msg.response);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<LogResponse>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.response) {json.response = msg.response;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: LogResponse, reader: BinaryReader): LogResponse {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.response = reader.readString();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: LogResponse, json: any): LogResponse {
          const response = json.response ?? json.response;if (response) {msg.response = response;}
          return msg;
        },

      };


