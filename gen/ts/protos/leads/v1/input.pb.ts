// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: protos/leads/v1/input.proto

import type { ByteSource, MapMessage } from "twirpscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

/**
 * InputName represent the name of a input, it allow use to determine the i18n for the label, helper text...
 * The type of the in
 */
export type InputName =
  | "INPUT_NAME_UNSPECIFIED"
  | "INPUT_NAME_AMOUNT"
  | "INPUT_NAME_ACCOUNT_TYPE";

/**
 * InputType represent the type of an input
 */
export type InputType =
  | "INPUT_TYPE_UNSPECIFIED"
  | "INPUT_TYPE_CURRENCY"
  | "INPUT_TYPE_TEXT"
  | "INPUT_TYPE_TEXT_AREA"
  | "INPUT_TYPE_SELECT_OPTION"
  | "INPUT_TYPE_REGION_OPTION"
  | "INPUT_TYPE_PHONE";

export interface InputDescriptor {
  inputName: InputName;
  inputType: InputType;
  options: string[];
}

export interface InputValue {
  inputName: InputName;
  inputValueNumber?: bigint | null | undefined;
  inputValueString?: string | null | undefined;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const InputName = {
  INPUT_NAME_UNSPECIFIED: "INPUT_NAME_UNSPECIFIED",
  INPUT_NAME_AMOUNT: "INPUT_NAME_AMOUNT",
  INPUT_NAME_ACCOUNT_TYPE: "INPUT_NAME_ACCOUNT_TYPE",
} as const;

const InputNameFromInt = function (i: number): InputName {
  switch (i) {
    case 0: {
      return "INPUT_NAME_UNSPECIFIED";
    }
    case 1: {
      return "INPUT_NAME_AMOUNT";
    }
    case 2: {
      return "INPUT_NAME_ACCOUNT_TYPE";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as InputName;
    }
  }
};

const InputNameToInt = function (i: InputName): number {
  switch (i) {
    case "INPUT_NAME_UNSPECIFIED": {
      return 0;
    }
    case "INPUT_NAME_AMOUNT": {
      return 1;
    }
    case "INPUT_NAME_ACCOUNT_TYPE": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const InputType = {
  INPUT_TYPE_UNSPECIFIED: "INPUT_TYPE_UNSPECIFIED",
  INPUT_TYPE_CURRENCY: "INPUT_TYPE_CURRENCY",
  INPUT_TYPE_TEXT: "INPUT_TYPE_TEXT",
  INPUT_TYPE_TEXT_AREA: "INPUT_TYPE_TEXT_AREA",
  INPUT_TYPE_SELECT_OPTION: "INPUT_TYPE_SELECT_OPTION",
  INPUT_TYPE_REGION_OPTION: "INPUT_TYPE_REGION_OPTION",
  INPUT_TYPE_PHONE: "INPUT_TYPE_PHONE",
} as const;

const InputTypeFromInt = function (i: number): InputType {
  switch (i) {
    case 0: {
      return "INPUT_TYPE_UNSPECIFIED";
    }
    case 1: {
      return "INPUT_TYPE_CURRENCY";
    }
    case 2: {
      return "INPUT_TYPE_TEXT";
    }
    case 3: {
      return "INPUT_TYPE_TEXT_AREA";
    }
    case 4: {
      return "INPUT_TYPE_SELECT_OPTION";
    }
    case 5: {
      return "INPUT_TYPE_REGION_OPTION";
    }
    case 6: {
      return "INPUT_TYPE_PHONE";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as InputType;
    }
  }
};

const InputTypeToInt = function (i: InputType): number {
  switch (i) {
    case "INPUT_TYPE_UNSPECIFIED": {
      return 0;
    }
    case "INPUT_TYPE_CURRENCY": {
      return 1;
    }
    case "INPUT_TYPE_TEXT": {
      return 2;
    }
    case "INPUT_TYPE_TEXT_AREA": {
      return 3;
    }
    case "INPUT_TYPE_SELECT_OPTION": {
      return 4;
    }
    case "INPUT_TYPE_REGION_OPTION": {
      return 5;
    }
    case "INPUT_TYPE_PHONE": {
      return 6;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const InputDescriptor = {
  /**
   * Serializes a InputDescriptor to protobuf.
   */
  encode: function (msg: Partial<InputDescriptor>): Uint8Array {
    return InputDescriptor._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a InputDescriptor from protobuf.
   */
  decode: function (bytes: ByteSource): InputDescriptor {
    return InputDescriptor._readMessage(
      InputDescriptor.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a InputDescriptor to JSON.
   */
  encodeJSON: function (msg: Partial<InputDescriptor>): string {
    return JSON.stringify(InputDescriptor._writeMessageJSON(msg));
  },

  /**
   * Deserializes a InputDescriptor from JSON.
   */
  decodeJSON: function (json: string): InputDescriptor {
    return InputDescriptor._readMessageJSON(
      InputDescriptor.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a InputDescriptor with all fields set to their default value.
   */
  initialize: function (): InputDescriptor {
    return {
      inputName: InputNameFromInt(0),
      inputType: InputTypeFromInt(0),
      options: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<InputDescriptor>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.inputName && InputNameToInt(msg.inputName)) {
      writer.writeEnum(1, InputNameToInt(msg.inputName));
    }
    if (msg.inputType && InputTypeToInt(msg.inputType)) {
      writer.writeEnum(2, InputTypeToInt(msg.inputType));
    }
    if (msg.options?.length) {
      writer.writeRepeatedString(3, msg.options);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<InputDescriptor>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.inputName && InputNameToInt(msg.inputName)) {
      json.inputName = msg.inputName;
    }
    if (msg.inputType && InputTypeToInt(msg.inputType)) {
      json.inputType = msg.inputType;
    }
    if (msg.options?.length) {
      json.options = msg.options;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: InputDescriptor,
    reader: BinaryReader
  ): InputDescriptor {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.inputName = InputNameFromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.inputType = InputTypeFromInt(reader.readEnum());
          break;
        }
        case 3: {
          msg.options.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: InputDescriptor,
    json: any
  ): InputDescriptor {
    const _inputName = json.inputName ?? json.input_name;
    if (_inputName) {
      msg.inputName = _inputName;
    }
    const _inputType = json.inputType ?? json.input_type;
    if (_inputType) {
      msg.inputType = _inputType;
    }
    const _options = json.options;
    if (_options) {
      msg.options = _options;
    }
    return msg;
  },
};

export const InputValue = {
  /**
   * Serializes a InputValue to protobuf.
   */
  encode: function (msg: Partial<InputValue>): Uint8Array {
    return InputValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a InputValue from protobuf.
   */
  decode: function (bytes: ByteSource): InputValue {
    return InputValue._readMessage(
      InputValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a InputValue to JSON.
   */
  encodeJSON: function (msg: Partial<InputValue>): string {
    return JSON.stringify(InputValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a InputValue from JSON.
   */
  decodeJSON: function (json: string): InputValue {
    return InputValue._readMessageJSON(
      InputValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a InputValue with all fields set to their default value.
   */
  initialize: function (): InputValue {
    return {
      inputName: InputNameFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<InputValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.inputName && InputNameToInt(msg.inputName)) {
      writer.writeEnum(1, InputNameToInt(msg.inputName));
    }
    if (msg.inputValueNumber != undefined) {
      writer.writeInt64String(100, msg.inputValueNumber.toString());
    }
    if (msg.inputValueString != undefined) {
      writer.writeString(101, msg.inputValueString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<InputValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.inputName && InputNameToInt(msg.inputName)) {
      json.inputName = msg.inputName;
    }
    if (msg.inputValueNumber != undefined) {
      json.inputValueNumber = msg.inputValueNumber.toString();
    }
    if (msg.inputValueString != undefined) {
      json.inputValueString = msg.inputValueString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: InputValue, reader: BinaryReader): InputValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.inputName = InputNameFromInt(reader.readEnum());
          break;
        }
        case 100: {
          msg.inputValueNumber = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.inputValueString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: InputValue, json: any): InputValue {
    const _inputName = json.inputName ?? json.input_name;
    if (_inputName) {
      msg.inputName = _inputName;
    }
    const _inputValueNumber = json.inputValueNumber ?? json.input_value_number;
    if (_inputValueNumber) {
      msg.inputValueNumber = BigInt(_inputValueNumber);
    }
    const _inputValueString = json.inputValueString ?? json.input_value_string;
    if (_inputValueString) {
      msg.inputValueString = _inputValueString;
    }
    return msg;
  },
};
