// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: protos/leads/v1/leads.proto

import type { ByteSource, MapMessage, ClientConfiguration } from "twirpscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
  JSONrequest,
  PBrequest,
} from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `yarn twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_49 } from "twirpscript";

import { HealthRequest, HealthResponse } from "../../common/v1/health.pb";

//========================================//
//      LeadsService Protobuf Client      //
//========================================//

export async function Health(
  healthRequest: HealthRequest,
  config?: ClientConfiguration
): Promise<HealthResponse> {
  const response = await PBrequest(
    "/protos.leads.v1.LeadsService/Health",
    HealthRequest.encode(healthRequest),
    config
  );
  return HealthResponse.decode(response);
}

export async function Create(
  createRequest: CreateRequest,
  config?: ClientConfiguration
): Promise<CreateResponse> {
  const response = await PBrequest(
    "/protos.leads.v1.LeadsService/Create",
    CreateRequest.encode(createRequest),
    config
  );
  return CreateResponse.decode(response);
}

export async function Update(
  updateRequest: UpdateRequest,
  config?: ClientConfiguration
): Promise<UpdateResponse> {
  const response = await PBrequest(
    "/protos.leads.v1.LeadsService/Update",
    UpdateRequest.encode(updateRequest),
    config
  );
  return UpdateResponse.decode(response);
}

export async function Fetch(
  fetchRequest: FetchRequest,
  config?: ClientConfiguration
): Promise<FetchResponse> {
  const response = await PBrequest(
    "/protos.leads.v1.LeadsService/Fetch",
    FetchRequest.encode(fetchRequest),
    config
  );
  return FetchResponse.decode(response);
}

export async function Previous(
  previousRequest: PreviousRequest,
  config?: ClientConfiguration
): Promise<PreviousResponse> {
  const response = await PBrequest(
    "/protos.leads.v1.LeadsService/Previous",
    PreviousRequest.encode(previousRequest),
    config
  );
  return PreviousResponse.decode(response);
}

//========================================//
//        LeadsService JSON Client        //
//========================================//

export async function HealthJSON(
  healthRequest: HealthRequest,
  config?: ClientConfiguration
): Promise<HealthResponse> {
  const response = await JSONrequest<HealthResponse>(
    "/protos.leads.v1.LeadsService/Health",
    healthRequest,
    config
  );
  return response;
}

export async function CreateJSON(
  createRequest: CreateRequest,
  config?: ClientConfiguration
): Promise<CreateResponse> {
  const response = await JSONrequest<CreateResponse>(
    "/protos.leads.v1.LeadsService/Create",
    createRequest,
    config
  );
  return response;
}

export async function UpdateJSON(
  updateRequest: UpdateRequest,
  config?: ClientConfiguration
): Promise<UpdateResponse> {
  const response = await JSONrequest<UpdateResponse>(
    "/protos.leads.v1.LeadsService/Update",
    updateRequest,
    config
  );
  return response;
}

export async function FetchJSON(
  fetchRequest: FetchRequest,
  config?: ClientConfiguration
): Promise<FetchResponse> {
  const response = await JSONrequest<FetchResponse>(
    "/protos.leads.v1.LeadsService/Fetch",
    fetchRequest,
    config
  );
  return response;
}

export async function PreviousJSON(
  previousRequest: PreviousRequest,
  config?: ClientConfiguration
): Promise<PreviousResponse> {
  const response = await JSONrequest<PreviousResponse>(
    "/protos.leads.v1.LeadsService/Previous",
    previousRequest,
    config
  );
  return response;
}

//========================================//
//              LeadsService              //
//========================================//

export interface LeadsService<Context = unknown> {
  Health: (
    healthRequest: HealthRequest,
    context: Context
  ) => Promise<HealthResponse> | HealthResponse;
  Create: (
    createRequest: CreateRequest,
    context: Context
  ) => Promise<CreateResponse> | CreateResponse;
  Update: (
    updateRequest: UpdateRequest,
    context: Context
  ) => Promise<UpdateResponse> | UpdateResponse;
  Fetch: (
    fetchRequest: FetchRequest,
    context: Context
  ) => Promise<FetchResponse> | FetchResponse;
  Previous: (
    previousRequest: PreviousRequest,
    context: Context
  ) => Promise<PreviousResponse> | PreviousResponse;
}

export function createLeadsService<Context>(service: LeadsService<Context>) {
  return {
    name: "protos.leads.v1.LeadsService",
    methods: {
      Health: {
        name: "Health",
        handler: service.Health,
        input: HealthRequest,
        output: HealthResponse,
      },
      Create: {
        name: "Create",
        handler: service.Create,
        input: CreateRequest,
        output: CreateResponse,
      },
      Update: {
        name: "Update",
        handler: service.Update,
        input: UpdateRequest,
        output: UpdateResponse,
      },
      Fetch: {
        name: "Fetch",
        handler: service.Fetch,
        input: FetchRequest,
        output: FetchResponse,
      },
      Previous: {
        name: "Previous",
        handler: service.Previous,
        input: PreviousRequest,
        output: PreviousResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export interface LoanPlanTerm {
  amount: number;
  amortizedCapitalAmount: number;
  interestAmount: number;
  capitalAmount: number;
  outstandingCapitalAmount: number;
  index: number;
}

export interface LenderLoanPlanTerm {
  term: LoanPlanTerm;
  intercallaryInterestAmount: number;
  scheduledAt: string;
}

export interface LenderLoanPlan {
  lenderLoanPlanTerms: LenderLoanPlanTerm[];
}

export interface CreateRequest {
  amount: bigint;
  lenderPlans: CreateRequest.LenderPlans;
}

declare namespace CreateRequest {
  export type LenderPlans = Record<number, LenderLoanPlan | undefined>;
}

export interface CreateResponse {
  leadId: bigint;
  progress: Progress;
  step: Step;
}

export interface FetchRequest {
  leadId: bigint;
}

export interface FetchResponse {
  progress: Progress;
  step: Step;
}

export interface UpdateRequest {
  leadId: bigint;
  stepName: string;
}

export interface UpdateResponse {
  progress: Progress;
  step: Step;
}

export interface PreviousRequest {
  leadId: bigint;
}

export interface PreviousResponse {
  progress: Progress;
  step: Step;
}

/**
 * returns the all needed for each step
 * name is the step name
 * list of inputs names for the front to build
 * when filling inputs answers returns a map of inputs names with their values
 */
export interface Step {
  name: string;
  previousName: string;
}

/**
 * Represent the progression of a lead, primary usage is for the frontend
 * **-- ---- ---- ---- = {step_count: 4, current_step: 1, sub_step_count: 4, current_sub_step: 2}
 */
export interface Progress {
  stepCount: number;
  currentStep: number;
  subStepCount: number;
  currentSubStep: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const LoanPlanTerm = {
  /**
   * Serializes a LoanPlanTerm to protobuf.
   */
  encode: function (msg: Partial<LoanPlanTerm>): Uint8Array {
    return LoanPlanTerm._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a LoanPlanTerm from protobuf.
   */
  decode: function (bytes: ByteSource): LoanPlanTerm {
    return LoanPlanTerm._readMessage(
      LoanPlanTerm.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a LoanPlanTerm to JSON.
   */
  encodeJSON: function (msg: Partial<LoanPlanTerm>): string {
    return JSON.stringify(LoanPlanTerm._writeMessageJSON(msg));
  },

  /**
   * Deserializes a LoanPlanTerm from JSON.
   */
  decodeJSON: function (json: string): LoanPlanTerm {
    return LoanPlanTerm._readMessageJSON(
      LoanPlanTerm.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a LoanPlanTerm with all fields set to their default value.
   */
  initialize: function (): LoanPlanTerm {
    return {
      amount: 0,
      amortizedCapitalAmount: 0,
      interestAmount: 0,
      capitalAmount: 0,
      outstandingCapitalAmount: 0,
      index: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<LoanPlanTerm>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.amount) {
      writer.writeDouble(1, msg.amount);
    }
    if (msg.amortizedCapitalAmount) {
      writer.writeDouble(2, msg.amortizedCapitalAmount);
    }
    if (msg.interestAmount) {
      writer.writeDouble(3, msg.interestAmount);
    }
    if (msg.capitalAmount) {
      writer.writeDouble(4, msg.capitalAmount);
    }
    if (msg.outstandingCapitalAmount) {
      writer.writeDouble(5, msg.outstandingCapitalAmount);
    }
    if (msg.index) {
      writer.writeInt32(6, msg.index);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<LoanPlanTerm>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.amount) {
      json.amount = msg.amount;
    }
    if (msg.amortizedCapitalAmount) {
      json.amortizedCapitalAmount = msg.amortizedCapitalAmount;
    }
    if (msg.interestAmount) {
      json.interestAmount = msg.interestAmount;
    }
    if (msg.capitalAmount) {
      json.capitalAmount = msg.capitalAmount;
    }
    if (msg.outstandingCapitalAmount) {
      json.outstandingCapitalAmount = msg.outstandingCapitalAmount;
    }
    if (msg.index) {
      json.index = msg.index;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: LoanPlanTerm,
    reader: BinaryReader
  ): LoanPlanTerm {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.amount = reader.readDouble();
          break;
        }
        case 2: {
          msg.amortizedCapitalAmount = reader.readDouble();
          break;
        }
        case 3: {
          msg.interestAmount = reader.readDouble();
          break;
        }
        case 4: {
          msg.capitalAmount = reader.readDouble();
          break;
        }
        case 5: {
          msg.outstandingCapitalAmount = reader.readDouble();
          break;
        }
        case 6: {
          msg.index = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: LoanPlanTerm, json: any): LoanPlanTerm {
    const _amount = json.amount;
    if (_amount) {
      msg.amount = _amount;
    }
    const _amortizedCapitalAmount =
      json.amortizedCapitalAmount ?? json.amortized_capital_amount;
    if (_amortizedCapitalAmount) {
      msg.amortizedCapitalAmount = _amortizedCapitalAmount;
    }
    const _interestAmount = json.interestAmount ?? json.interest_amount;
    if (_interestAmount) {
      msg.interestAmount = _interestAmount;
    }
    const _capitalAmount = json.capitalAmount ?? json.capital_amount;
    if (_capitalAmount) {
      msg.capitalAmount = _capitalAmount;
    }
    const _outstandingCapitalAmount =
      json.outstandingCapitalAmount ?? json.outstanding_capital_amount;
    if (_outstandingCapitalAmount) {
      msg.outstandingCapitalAmount = _outstandingCapitalAmount;
    }
    const _index = json.index;
    if (_index) {
      msg.index = _index;
    }
    return msg;
  },
};

export const LenderLoanPlanTerm = {
  /**
   * Serializes a LenderLoanPlanTerm to protobuf.
   */
  encode: function (msg: Partial<LenderLoanPlanTerm>): Uint8Array {
    return LenderLoanPlanTerm._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a LenderLoanPlanTerm from protobuf.
   */
  decode: function (bytes: ByteSource): LenderLoanPlanTerm {
    return LenderLoanPlanTerm._readMessage(
      LenderLoanPlanTerm.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a LenderLoanPlanTerm to JSON.
   */
  encodeJSON: function (msg: Partial<LenderLoanPlanTerm>): string {
    return JSON.stringify(LenderLoanPlanTerm._writeMessageJSON(msg));
  },

  /**
   * Deserializes a LenderLoanPlanTerm from JSON.
   */
  decodeJSON: function (json: string): LenderLoanPlanTerm {
    return LenderLoanPlanTerm._readMessageJSON(
      LenderLoanPlanTerm.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a LenderLoanPlanTerm with all fields set to their default value.
   */
  initialize: function (): LenderLoanPlanTerm {
    return {
      term: LoanPlanTerm.initialize(),
      intercallaryInterestAmount: 0,
      scheduledAt: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<LenderLoanPlanTerm>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.term) {
      writer.writeMessage(1, msg.term, LoanPlanTerm._writeMessage);
    }
    if (msg.intercallaryInterestAmount) {
      writer.writeDouble(2, msg.intercallaryInterestAmount);
    }
    if (msg.scheduledAt) {
      writer.writeString(3, msg.scheduledAt);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<LenderLoanPlanTerm>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.term) {
      const term = LoanPlanTerm._writeMessageJSON(msg.term);
      if (Object.keys(term).length > 0) {
        json.term = term;
      }
    }
    if (msg.intercallaryInterestAmount) {
      json.intercallaryInterestAmount = msg.intercallaryInterestAmount;
    }
    if (msg.scheduledAt) {
      json.scheduledAt = msg.scheduledAt;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: LenderLoanPlanTerm,
    reader: BinaryReader
  ): LenderLoanPlanTerm {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.term, LoanPlanTerm._readMessage);
          break;
        }
        case 2: {
          msg.intercallaryInterestAmount = reader.readDouble();
          break;
        }
        case 3: {
          msg.scheduledAt = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: LenderLoanPlanTerm,
    json: any
  ): LenderLoanPlanTerm {
    const _term = json.term;
    if (_term) {
      const m = LoanPlanTerm.initialize();
      LoanPlanTerm._readMessageJSON(m, _term);
      msg.term = m;
    }
    const _intercallaryInterestAmount =
      json.intercallaryInterestAmount ?? json.intercallary_interest_amount;
    if (_intercallaryInterestAmount) {
      msg.intercallaryInterestAmount = _intercallaryInterestAmount;
    }
    const _scheduledAt = json.scheduledAt ?? json.scheduled_at;
    if (_scheduledAt) {
      msg.scheduledAt = _scheduledAt;
    }
    return msg;
  },
};

export const LenderLoanPlan = {
  /**
   * Serializes a LenderLoanPlan to protobuf.
   */
  encode: function (msg: Partial<LenderLoanPlan>): Uint8Array {
    return LenderLoanPlan._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a LenderLoanPlan from protobuf.
   */
  decode: function (bytes: ByteSource): LenderLoanPlan {
    return LenderLoanPlan._readMessage(
      LenderLoanPlan.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a LenderLoanPlan to JSON.
   */
  encodeJSON: function (msg: Partial<LenderLoanPlan>): string {
    return JSON.stringify(LenderLoanPlan._writeMessageJSON(msg));
  },

  /**
   * Deserializes a LenderLoanPlan from JSON.
   */
  decodeJSON: function (json: string): LenderLoanPlan {
    return LenderLoanPlan._readMessageJSON(
      LenderLoanPlan.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a LenderLoanPlan with all fields set to their default value.
   */
  initialize: function (): LenderLoanPlan {
    return {
      lenderLoanPlanTerms: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<LenderLoanPlan>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.lenderLoanPlanTerms?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.lenderLoanPlanTerms as any,
        LenderLoanPlanTerm._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<LenderLoanPlan>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.lenderLoanPlanTerms?.length) {
      json.lenderLoanPlanTerms = msg.lenderLoanPlanTerms.map(
        LenderLoanPlanTerm._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: LenderLoanPlan,
    reader: BinaryReader
  ): LenderLoanPlan {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = LenderLoanPlanTerm.initialize();
          reader.readMessage(m, LenderLoanPlanTerm._readMessage);
          msg.lenderLoanPlanTerms.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: LenderLoanPlan, json: any): LenderLoanPlan {
    const _lenderLoanPlanTerms =
      json.lenderLoanPlanTerms ?? json.lender_loan_plan_terms;
    if (_lenderLoanPlanTerms) {
      for (const item of _lenderLoanPlanTerms) {
        const m = LenderLoanPlanTerm.initialize();
        LenderLoanPlanTerm._readMessageJSON(m, item);
        msg.lenderLoanPlanTerms.push(m);
      }
    }
    return msg;
  },
};

export const CreateRequest = {
  /**
   * Serializes a CreateRequest to protobuf.
   */
  encode: function (msg: Partial<CreateRequest>): Uint8Array {
    return CreateRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a CreateRequest from protobuf.
   */
  decode: function (bytes: ByteSource): CreateRequest {
    return CreateRequest._readMessage(
      CreateRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a CreateRequest to JSON.
   */
  encodeJSON: function (msg: Partial<CreateRequest>): string {
    return JSON.stringify(CreateRequest._writeMessageJSON(msg));
  },

  /**
   * Deserializes a CreateRequest from JSON.
   */
  decodeJSON: function (json: string): CreateRequest {
    return CreateRequest._readMessageJSON(
      CreateRequest.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a CreateRequest with all fields set to their default value.
   */
  initialize: function (): CreateRequest {
    return {
      amount: 0n,
      lenderPlans: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<CreateRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.amount) {
      writer.writeInt64String(1, msg.amount.toString());
    }
    if (msg.lenderPlans) {
      writer.writeRepeatedMessage(
        2,
        Object.entries<any>(msg.lenderPlans).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        CreateRequest.LenderPlans._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<CreateRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.amount) {
      json.amount = msg.amount.toString();
    }
    if (msg.lenderPlans) {
      const lenderPlans = Object.fromEntries(
        Object.entries<any>(msg.lenderPlans)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(CreateRequest.LenderPlans._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(lenderPlans).length > 0) {
        json.lenderPlans = lenderPlans;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateRequest,
    reader: BinaryReader
  ): CreateRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.amount = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          const lenderPlans = {} as MapMessage<CreateRequest.LenderPlans>;
          reader.readMessage(
            lenderPlans,
            CreateRequest.LenderPlans._readMessage
          );
          msg.lenderPlans[lenderPlans.key] = lenderPlans.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: CreateRequest, json: any): CreateRequest {
    const _amount = json.amount;
    if (_amount) {
      msg.amount = BigInt(_amount);
    }
    const _lenderPlans = json.lenderPlans ?? json.lender_plans;
    if (_lenderPlans) {
      msg.lenderPlans = Object.fromEntries(
        Object.entries<any>(_lenderPlans)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(CreateRequest.LenderPlans._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  LenderPlans: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<CreateRequest.LenderPlans>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, LenderLoanPlan._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<CreateRequest.LenderPlans>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = LenderLoanPlan._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<CreateRequest.LenderPlans>,
      reader: BinaryReader
    ): MapMessage<CreateRequest.LenderPlans> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              LenderLoanPlan.initialize(),
              LenderLoanPlan._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<CreateRequest.LenderPlans>,
      json: any
    ): MapMessage<CreateRequest.LenderPlans> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = LenderLoanPlan.initialize();
        LenderLoanPlan._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const CreateResponse = {
  /**
   * Serializes a CreateResponse to protobuf.
   */
  encode: function (msg: Partial<CreateResponse>): Uint8Array {
    return CreateResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a CreateResponse from protobuf.
   */
  decode: function (bytes: ByteSource): CreateResponse {
    return CreateResponse._readMessage(
      CreateResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a CreateResponse to JSON.
   */
  encodeJSON: function (msg: Partial<CreateResponse>): string {
    return JSON.stringify(CreateResponse._writeMessageJSON(msg));
  },

  /**
   * Deserializes a CreateResponse from JSON.
   */
  decodeJSON: function (json: string): CreateResponse {
    return CreateResponse._readMessageJSON(
      CreateResponse.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a CreateResponse with all fields set to their default value.
   */
  initialize: function (): CreateResponse {
    return {
      leadId: 0n,
      progress: Progress.initialize(),
      step: Step.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<CreateResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.leadId) {
      writer.writeInt64String(1, msg.leadId.toString());
    }
    if (msg.progress) {
      writer.writeMessage(2, msg.progress, Progress._writeMessage);
    }
    if (msg.step) {
      writer.writeMessage(3, msg.step, Step._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<CreateResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.leadId) {
      json.leadId = msg.leadId.toString();
    }
    if (msg.progress) {
      const progress = Progress._writeMessageJSON(msg.progress);
      if (Object.keys(progress).length > 0) {
        json.progress = progress;
      }
    }
    if (msg.step) {
      const step = Step._writeMessageJSON(msg.step);
      if (Object.keys(step).length > 0) {
        json.step = step;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateResponse,
    reader: BinaryReader
  ): CreateResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.leadId = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          reader.readMessage(msg.progress, Progress._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.step, Step._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: CreateResponse, json: any): CreateResponse {
    const _leadId = json.leadId ?? json.lead_id;
    if (_leadId) {
      msg.leadId = BigInt(_leadId);
    }
    const _progress = json.progress;
    if (_progress) {
      const m = Progress.initialize();
      Progress._readMessageJSON(m, _progress);
      msg.progress = m;
    }
    const _step = json.step;
    if (_step) {
      const m = Step.initialize();
      Step._readMessageJSON(m, _step);
      msg.step = m;
    }
    return msg;
  },
};

export const FetchRequest = {
  /**
   * Serializes a FetchRequest to protobuf.
   */
  encode: function (msg: Partial<FetchRequest>): Uint8Array {
    return FetchRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FetchRequest from protobuf.
   */
  decode: function (bytes: ByteSource): FetchRequest {
    return FetchRequest._readMessage(
      FetchRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a FetchRequest to JSON.
   */
  encodeJSON: function (msg: Partial<FetchRequest>): string {
    return JSON.stringify(FetchRequest._writeMessageJSON(msg));
  },

  /**
   * Deserializes a FetchRequest from JSON.
   */
  decodeJSON: function (json: string): FetchRequest {
    return FetchRequest._readMessageJSON(
      FetchRequest.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a FetchRequest with all fields set to their default value.
   */
  initialize: function (): FetchRequest {
    return {
      leadId: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FetchRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.leadId) {
      writer.writeInt64String(1, msg.leadId.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<FetchRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.leadId) {
      json.leadId = msg.leadId.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FetchRequest,
    reader: BinaryReader
  ): FetchRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.leadId = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: FetchRequest, json: any): FetchRequest {
    const _leadId = json.leadId ?? json.lead_id;
    if (_leadId) {
      msg.leadId = BigInt(_leadId);
    }
    return msg;
  },
};

export const FetchResponse = {
  /**
   * Serializes a FetchResponse to protobuf.
   */
  encode: function (msg: Partial<FetchResponse>): Uint8Array {
    return FetchResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FetchResponse from protobuf.
   */
  decode: function (bytes: ByteSource): FetchResponse {
    return FetchResponse._readMessage(
      FetchResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a FetchResponse to JSON.
   */
  encodeJSON: function (msg: Partial<FetchResponse>): string {
    return JSON.stringify(FetchResponse._writeMessageJSON(msg));
  },

  /**
   * Deserializes a FetchResponse from JSON.
   */
  decodeJSON: function (json: string): FetchResponse {
    return FetchResponse._readMessageJSON(
      FetchResponse.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a FetchResponse with all fields set to their default value.
   */
  initialize: function (): FetchResponse {
    return {
      progress: Progress.initialize(),
      step: Step.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FetchResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.progress) {
      writer.writeMessage(1, msg.progress, Progress._writeMessage);
    }
    if (msg.step) {
      writer.writeMessage(2, msg.step, Step._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<FetchResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.progress) {
      const progress = Progress._writeMessageJSON(msg.progress);
      if (Object.keys(progress).length > 0) {
        json.progress = progress;
      }
    }
    if (msg.step) {
      const step = Step._writeMessageJSON(msg.step);
      if (Object.keys(step).length > 0) {
        json.step = step;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FetchResponse,
    reader: BinaryReader
  ): FetchResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.progress, Progress._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.step, Step._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: FetchResponse, json: any): FetchResponse {
    const _progress = json.progress;
    if (_progress) {
      const m = Progress.initialize();
      Progress._readMessageJSON(m, _progress);
      msg.progress = m;
    }
    const _step = json.step;
    if (_step) {
      const m = Step.initialize();
      Step._readMessageJSON(m, _step);
      msg.step = m;
    }
    return msg;
  },
};

export const UpdateRequest = {
  /**
   * Serializes a UpdateRequest to protobuf.
   */
  encode: function (msg: Partial<UpdateRequest>): Uint8Array {
    return UpdateRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a UpdateRequest from protobuf.
   */
  decode: function (bytes: ByteSource): UpdateRequest {
    return UpdateRequest._readMessage(
      UpdateRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a UpdateRequest to JSON.
   */
  encodeJSON: function (msg: Partial<UpdateRequest>): string {
    return JSON.stringify(UpdateRequest._writeMessageJSON(msg));
  },

  /**
   * Deserializes a UpdateRequest from JSON.
   */
  decodeJSON: function (json: string): UpdateRequest {
    return UpdateRequest._readMessageJSON(
      UpdateRequest.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a UpdateRequest with all fields set to their default value.
   */
  initialize: function (): UpdateRequest {
    return {
      leadId: 0n,
      stepName: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<UpdateRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.leadId) {
      writer.writeInt64String(1, msg.leadId.toString());
    }
    if (msg.stepName) {
      writer.writeString(2, msg.stepName);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<UpdateRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.leadId) {
      json.leadId = msg.leadId.toString();
    }
    if (msg.stepName) {
      json.stepName = msg.stepName;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UpdateRequest,
    reader: BinaryReader
  ): UpdateRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.leadId = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.stepName = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: UpdateRequest, json: any): UpdateRequest {
    const _leadId = json.leadId ?? json.lead_id;
    if (_leadId) {
      msg.leadId = BigInt(_leadId);
    }
    const _stepName = json.stepName ?? json.step_name;
    if (_stepName) {
      msg.stepName = _stepName;
    }
    return msg;
  },
};

export const UpdateResponse = {
  /**
   * Serializes a UpdateResponse to protobuf.
   */
  encode: function (msg: Partial<UpdateResponse>): Uint8Array {
    return UpdateResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a UpdateResponse from protobuf.
   */
  decode: function (bytes: ByteSource): UpdateResponse {
    return UpdateResponse._readMessage(
      UpdateResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a UpdateResponse to JSON.
   */
  encodeJSON: function (msg: Partial<UpdateResponse>): string {
    return JSON.stringify(UpdateResponse._writeMessageJSON(msg));
  },

  /**
   * Deserializes a UpdateResponse from JSON.
   */
  decodeJSON: function (json: string): UpdateResponse {
    return UpdateResponse._readMessageJSON(
      UpdateResponse.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a UpdateResponse with all fields set to their default value.
   */
  initialize: function (): UpdateResponse {
    return {
      progress: Progress.initialize(),
      step: Step.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<UpdateResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.progress) {
      writer.writeMessage(1, msg.progress, Progress._writeMessage);
    }
    if (msg.step) {
      writer.writeMessage(2, msg.step, Step._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<UpdateResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.progress) {
      const progress = Progress._writeMessageJSON(msg.progress);
      if (Object.keys(progress).length > 0) {
        json.progress = progress;
      }
    }
    if (msg.step) {
      const step = Step._writeMessageJSON(msg.step);
      if (Object.keys(step).length > 0) {
        json.step = step;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UpdateResponse,
    reader: BinaryReader
  ): UpdateResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.progress, Progress._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.step, Step._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: UpdateResponse, json: any): UpdateResponse {
    const _progress = json.progress;
    if (_progress) {
      const m = Progress.initialize();
      Progress._readMessageJSON(m, _progress);
      msg.progress = m;
    }
    const _step = json.step;
    if (_step) {
      const m = Step.initialize();
      Step._readMessageJSON(m, _step);
      msg.step = m;
    }
    return msg;
  },
};

export const PreviousRequest = {
  /**
   * Serializes a PreviousRequest to protobuf.
   */
  encode: function (msg: Partial<PreviousRequest>): Uint8Array {
    return PreviousRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PreviousRequest from protobuf.
   */
  decode: function (bytes: ByteSource): PreviousRequest {
    return PreviousRequest._readMessage(
      PreviousRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a PreviousRequest to JSON.
   */
  encodeJSON: function (msg: Partial<PreviousRequest>): string {
    return JSON.stringify(PreviousRequest._writeMessageJSON(msg));
  },

  /**
   * Deserializes a PreviousRequest from JSON.
   */
  decodeJSON: function (json: string): PreviousRequest {
    return PreviousRequest._readMessageJSON(
      PreviousRequest.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a PreviousRequest with all fields set to their default value.
   */
  initialize: function (): PreviousRequest {
    return {
      leadId: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PreviousRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.leadId) {
      writer.writeInt64String(1, msg.leadId.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<PreviousRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.leadId) {
      json.leadId = msg.leadId.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PreviousRequest,
    reader: BinaryReader
  ): PreviousRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.leadId = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: PreviousRequest,
    json: any
  ): PreviousRequest {
    const _leadId = json.leadId ?? json.lead_id;
    if (_leadId) {
      msg.leadId = BigInt(_leadId);
    }
    return msg;
  },
};

export const PreviousResponse = {
  /**
   * Serializes a PreviousResponse to protobuf.
   */
  encode: function (msg: Partial<PreviousResponse>): Uint8Array {
    return PreviousResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PreviousResponse from protobuf.
   */
  decode: function (bytes: ByteSource): PreviousResponse {
    return PreviousResponse._readMessage(
      PreviousResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a PreviousResponse to JSON.
   */
  encodeJSON: function (msg: Partial<PreviousResponse>): string {
    return JSON.stringify(PreviousResponse._writeMessageJSON(msg));
  },

  /**
   * Deserializes a PreviousResponse from JSON.
   */
  decodeJSON: function (json: string): PreviousResponse {
    return PreviousResponse._readMessageJSON(
      PreviousResponse.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a PreviousResponse with all fields set to their default value.
   */
  initialize: function (): PreviousResponse {
    return {
      progress: Progress.initialize(),
      step: Step.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PreviousResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.progress) {
      writer.writeMessage(1, msg.progress, Progress._writeMessage);
    }
    if (msg.step) {
      writer.writeMessage(2, msg.step, Step._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<PreviousResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.progress) {
      const progress = Progress._writeMessageJSON(msg.progress);
      if (Object.keys(progress).length > 0) {
        json.progress = progress;
      }
    }
    if (msg.step) {
      const step = Step._writeMessageJSON(msg.step);
      if (Object.keys(step).length > 0) {
        json.step = step;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PreviousResponse,
    reader: BinaryReader
  ): PreviousResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.progress, Progress._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.step, Step._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: PreviousResponse,
    json: any
  ): PreviousResponse {
    const _progress = json.progress;
    if (_progress) {
      const m = Progress.initialize();
      Progress._readMessageJSON(m, _progress);
      msg.progress = m;
    }
    const _step = json.step;
    if (_step) {
      const m = Step.initialize();
      Step._readMessageJSON(m, _step);
      msg.step = m;
    }
    return msg;
  },
};

export const Step = {
  /**
   * Serializes a Step to protobuf.
   */
  encode: function (msg: Partial<Step>): Uint8Array {
    return Step._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Step from protobuf.
   */
  decode: function (bytes: ByteSource): Step {
    return Step._readMessage(Step.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Step to JSON.
   */
  encodeJSON: function (msg: Partial<Step>): string {
    return JSON.stringify(Step._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Step from JSON.
   */
  decodeJSON: function (json: string): Step {
    return Step._readMessageJSON(Step.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Step with all fields set to their default value.
   */
  initialize: function (): Step {
    return {
      name: "",
      previousName: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Step>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.previousName) {
      writer.writeString(2, msg.previousName);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Step>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.previousName) {
      json.previousName = msg.previousName;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Step, reader: BinaryReader): Step {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.previousName = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Step, json: any): Step {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _previousName = json.previousName ?? json.previous_name;
    if (_previousName) {
      msg.previousName = _previousName;
    }
    return msg;
  },
};

export const Progress = {
  /**
   * Serializes a Progress to protobuf.
   */
  encode: function (msg: Partial<Progress>): Uint8Array {
    return Progress._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Progress from protobuf.
   */
  decode: function (bytes: ByteSource): Progress {
    return Progress._readMessage(
      Progress.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Progress to JSON.
   */
  encodeJSON: function (msg: Partial<Progress>): string {
    return JSON.stringify(Progress._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Progress from JSON.
   */
  decodeJSON: function (json: string): Progress {
    return Progress._readMessageJSON(Progress.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Progress with all fields set to their default value.
   */
  initialize: function (): Progress {
    return {
      stepCount: 0,
      currentStep: 0,
      subStepCount: 0,
      currentSubStep: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Progress>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.stepCount) {
      writer.writeInt32(1, msg.stepCount);
    }
    if (msg.currentStep) {
      writer.writeInt32(2, msg.currentStep);
    }
    if (msg.subStepCount) {
      writer.writeInt32(3, msg.subStepCount);
    }
    if (msg.currentSubStep) {
      writer.writeInt32(4, msg.currentSubStep);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Progress>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.stepCount) {
      json.stepCount = msg.stepCount;
    }
    if (msg.currentStep) {
      json.currentStep = msg.currentStep;
    }
    if (msg.subStepCount) {
      json.subStepCount = msg.subStepCount;
    }
    if (msg.currentSubStep) {
      json.currentSubStep = msg.currentSubStep;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Progress, reader: BinaryReader): Progress {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.stepCount = reader.readInt32();
          break;
        }
        case 2: {
          msg.currentStep = reader.readInt32();
          break;
        }
        case 3: {
          msg.subStepCount = reader.readInt32();
          break;
        }
        case 4: {
          msg.currentSubStep = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Progress, json: any): Progress {
    const _stepCount = json.stepCount ?? json.step_count;
    if (_stepCount) {
      msg.stepCount = _stepCount;
    }
    const _currentStep = json.currentStep ?? json.current_step;
    if (_currentStep) {
      msg.currentStep = _currentStep;
    }
    const _subStepCount = json.subStepCount ?? json.sub_step_count;
    if (_subStepCount) {
      msg.subStepCount = _subStepCount;
    }
    const _currentSubStep = json.currentSubStep ?? json.current_sub_step;
    if (_currentSubStep) {
      msg.currentSubStep = _currentSubStep;
    }
    return msg;
  },
};
