// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: protos/leads/v1/leads.proto


import type {
    ByteSource,

    ClientConfiguration} from 'twirpscript';
import {
  BinaryReader,
BinaryWriter,

  JSONrequest,
PBrequest} from 'twirpscript';
  // This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `yarn twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_44 } from "twirpscript";

import { InputValue, InputDescriptor } from './input.pb';
import { HealthRequest, HealthResponse } from '../../common/v1/health.pb';

  //========================================//
  //      LeadsService Protobuf Client      //
  //========================================//
  
  export async function Health(healthRequest: HealthRequest, config?: ClientConfiguration): Promise<HealthResponse> {
  const response = await PBrequest('/protos.leads.v1.LeadsService/Health', HealthRequest.encode(healthRequest), config);
  return HealthResponse.decode(response);
}

export async function Create(createRequest: CreateRequest, config?: ClientConfiguration): Promise<CreateResponse> {
  const response = await PBrequest('/protos.leads.v1.LeadsService/Create', CreateRequest.encode(createRequest), config);
  return CreateResponse.decode(response);
}

export async function Update(updateRequest: UpdateRequest, config?: ClientConfiguration): Promise<UpdateResponse> {
  const response = await PBrequest('/protos.leads.v1.LeadsService/Update', UpdateRequest.encode(updateRequest), config);
  return UpdateResponse.decode(response);
}

export async function Fetch(fetchRequest: FetchRequest, config?: ClientConfiguration): Promise<FetchResponse> {
  const response = await PBrequest('/protos.leads.v1.LeadsService/Fetch', FetchRequest.encode(fetchRequest), config);
  return FetchResponse.decode(response);
}

export async function Previous(previousRequest: PreviousRequest, config?: ClientConfiguration): Promise<PreviousResponse> {
  const response = await PBrequest('/protos.leads.v1.LeadsService/Previous', PreviousRequest.encode(previousRequest), config);
  return PreviousResponse.decode(response);
}

  //========================================//
  //        LeadsService JSON Client        //
  //========================================//
  
  export async function HealthJSON(healthRequest: HealthRequest, config?: ClientConfiguration): Promise<HealthResponse> {
  const response = await JSONrequest<HealthResponse>('/protos.leads.v1.LeadsService/Health', healthRequest, config);
  return response;
}

export async function CreateJSON(createRequest: CreateRequest, config?: ClientConfiguration): Promise<CreateResponse> {
  const response = await JSONrequest<CreateResponse>('/protos.leads.v1.LeadsService/Create', createRequest, config);
  return response;
}

export async function UpdateJSON(updateRequest: UpdateRequest, config?: ClientConfiguration): Promise<UpdateResponse> {
  const response = await JSONrequest<UpdateResponse>('/protos.leads.v1.LeadsService/Update', updateRequest, config);
  return response;
}

export async function FetchJSON(fetchRequest: FetchRequest, config?: ClientConfiguration): Promise<FetchResponse> {
  const response = await JSONrequest<FetchResponse>('/protos.leads.v1.LeadsService/Fetch', fetchRequest, config);
  return response;
}

export async function PreviousJSON(previousRequest: PreviousRequest, config?: ClientConfiguration): Promise<PreviousResponse> {
  const response = await JSONrequest<PreviousResponse>('/protos.leads.v1.LeadsService/Previous', previousRequest, config);
  return response;
}



  //========================================//
  //              LeadsService              //
  //========================================//
  
  export interface LeadsService<Context = unknown> {
Health: (healthRequest: HealthRequest, context: Context) => Promise<HealthResponse> | HealthResponse;
Create: (createRequest: CreateRequest, context: Context) => Promise<CreateResponse> | CreateResponse;
Update: (updateRequest: UpdateRequest, context: Context) => Promise<UpdateResponse> | UpdateResponse;
Fetch: (fetchRequest: FetchRequest, context: Context) => Promise<FetchResponse> | FetchResponse;
Previous: (previousRequest: PreviousRequest, context: Context) => Promise<PreviousResponse> | PreviousResponse;
}

export function createLeadsService<Context>(service: LeadsService<Context>) { return {
    name: 'protos.leads.v1.LeadsService',
    methods: {
Health: { name: 'Health', handler: service.Health, input: HealthRequest, output: HealthResponse },Create: { name: 'Create', handler: service.Create, input: CreateRequest, output: CreateResponse },Update: { name: 'Update', handler: service.Update, input: UpdateRequest, output: UpdateResponse },Fetch: { name: 'Fetch', handler: service.Fetch, input: FetchRequest, output: FetchResponse },Previous: { name: 'Previous', handler: service.Previous, input: PreviousRequest, output: PreviousResponse },}
} as const
}



  //========================================//
  //                 Types                  //
  //========================================//
  
  
export interface CreateRequest {
amount: bigint;
}

export interface CreateResponse {
leadId: bigint;
progress: Progress;
step: Step;
}

export interface FetchRequest {
leadId: bigint;
}

export interface FetchResponse {
progress: Progress;
step: Step;
}

export interface UpdateRequest {
leadId: bigint;
stepName: string;
answers: InputValue[];
}

export interface UpdateResponse {
progress: Progress;
step: Step;
}

export interface PreviousRequest {
leadId: bigint;
}

export interface PreviousResponse {
progress: Progress;
step: Step;
}

    /**
     * returns the all needed for each step
 * name is the step name
 * list of inputs names for the front to build
 * when filling inputs answers returns a map of inputs names with their values
     */
      export interface Step {
name: string;
previousName: string;
inputDescriptors: InputDescriptor[];
answers: InputValue[];
}

    /**
     * Represent the progression of a lead, primary usage is for the frontend
 * **-- ---- ---- ---- = {step_count: 4, current_step: 1, sub_step_count: 4, current_sub_step: 2}
     */
      export interface Progress {
stepCount: number;
currentStep: number;
subStepCount: number;
currentSubStep: number;
}


  //========================================//
  //        Protobuf Encode / Decode        //
  //========================================//
  
  
export const CreateRequest = {        /**
         * Serializes a CreateRequest to protobuf.
         */
        encode: function(createRequest: Partial<CreateRequest>): Uint8Array {
          return CreateRequest._writeMessage(createRequest, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a CreateRequest from protobuf.
         */
        decode: function(bytes: ByteSource): CreateRequest {
          return CreateRequest._readMessage(CreateRequest.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a CreateRequest to JSON.
         */
        encodeJSON: function(createRequest: Partial<CreateRequest>): string {
          return JSON.stringify(CreateRequest._writeMessageJSON(createRequest));
        },
        

        /**
         * Deserializes a CreateRequest from JSON.
         */
        decodeJSON: function(json: string): CreateRequest {
          return CreateRequest._readMessageJSON(CreateRequest.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a CreateRequest with all fields set to their default value.
         */
        initialize: function(): CreateRequest {
          return {
            amount: 0n,
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<CreateRequest>, writer: BinaryWriter): BinaryWriter {
          if (msg.amount) {writer.writeInt64String(1, msg.amount.toString());}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<CreateRequest>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.amount) {json.amount = msg.amount.toString();}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: CreateRequest, reader: BinaryReader): CreateRequest {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.amount = BigInt(reader.readInt64String());break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: CreateRequest, json: any): CreateRequest {
          const amount = json.amount ?? json.amount;if (amount) {msg.amount = BigInt(amount);}
          return msg;
        },

      };

export const CreateResponse = {        /**
         * Serializes a CreateResponse to protobuf.
         */
        encode: function(createResponse: Partial<CreateResponse>): Uint8Array {
          return CreateResponse._writeMessage(createResponse, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a CreateResponse from protobuf.
         */
        decode: function(bytes: ByteSource): CreateResponse {
          return CreateResponse._readMessage(CreateResponse.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a CreateResponse to JSON.
         */
        encodeJSON: function(createResponse: Partial<CreateResponse>): string {
          return JSON.stringify(CreateResponse._writeMessageJSON(createResponse));
        },
        

        /**
         * Deserializes a CreateResponse from JSON.
         */
        decodeJSON: function(json: string): CreateResponse {
          return CreateResponse._readMessageJSON(CreateResponse.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a CreateResponse with all fields set to their default value.
         */
        initialize: function(): CreateResponse {
          return {
            leadId: 0n,progress: Progress.initialize(),step: Step.initialize(),
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<CreateResponse>, writer: BinaryWriter): BinaryWriter {
          if (msg.leadId) {writer.writeInt64String(1, msg.leadId.toString());}
if (msg.progress) {writer.writeMessage(2, msg.progress , Progress._writeMessage);}
if (msg.step) {writer.writeMessage(3, msg.step , Step._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<CreateResponse>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.leadId) {json.leadId = msg.leadId.toString();}
if (msg.progress) {const progress = Progress._writeMessageJSON(msg.progress);if (Object.keys(progress).length > 0) {json.progress = progress;}}
if (msg.step) {const step = Step._writeMessageJSON(msg.step);if (Object.keys(step).length > 0) {json.step = step;}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: CreateResponse, reader: BinaryReader): CreateResponse {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.leadId = BigInt(reader.readInt64String());break;
}
case 2: {
                      reader.readMessage(msg.progress, Progress._readMessage);
                    break;
}
case 3: {
                      reader.readMessage(msg.step, Step._readMessage);
                    break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: CreateResponse, json: any): CreateResponse {
          const leadId = json.leadId ?? json.lead_id;if (leadId) {msg.leadId = BigInt(leadId);}
const progress = json.progress ?? json.progress;if (progress) {const m = Progress.initialize();Progress._readMessageJSON(m, progress);msg.progress = m;}
const step = json.step ?? json.step;if (step) {const m = Step.initialize();Step._readMessageJSON(m, step);msg.step = m;}
          return msg;
        },

      };

export const FetchRequest = {        /**
         * Serializes a FetchRequest to protobuf.
         */
        encode: function(fetchRequest: Partial<FetchRequest>): Uint8Array {
          return FetchRequest._writeMessage(fetchRequest, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a FetchRequest from protobuf.
         */
        decode: function(bytes: ByteSource): FetchRequest {
          return FetchRequest._readMessage(FetchRequest.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a FetchRequest to JSON.
         */
        encodeJSON: function(fetchRequest: Partial<FetchRequest>): string {
          return JSON.stringify(FetchRequest._writeMessageJSON(fetchRequest));
        },
        

        /**
         * Deserializes a FetchRequest from JSON.
         */
        decodeJSON: function(json: string): FetchRequest {
          return FetchRequest._readMessageJSON(FetchRequest.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a FetchRequest with all fields set to their default value.
         */
        initialize: function(): FetchRequest {
          return {
            leadId: 0n,
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<FetchRequest>, writer: BinaryWriter): BinaryWriter {
          if (msg.leadId) {writer.writeInt64String(1, msg.leadId.toString());}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<FetchRequest>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.leadId) {json.leadId = msg.leadId.toString();}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: FetchRequest, reader: BinaryReader): FetchRequest {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.leadId = BigInt(reader.readInt64String());break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: FetchRequest, json: any): FetchRequest {
          const leadId = json.leadId ?? json.lead_id;if (leadId) {msg.leadId = BigInt(leadId);}
          return msg;
        },

      };

export const FetchResponse = {        /**
         * Serializes a FetchResponse to protobuf.
         */
        encode: function(fetchResponse: Partial<FetchResponse>): Uint8Array {
          return FetchResponse._writeMessage(fetchResponse, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a FetchResponse from protobuf.
         */
        decode: function(bytes: ByteSource): FetchResponse {
          return FetchResponse._readMessage(FetchResponse.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a FetchResponse to JSON.
         */
        encodeJSON: function(fetchResponse: Partial<FetchResponse>): string {
          return JSON.stringify(FetchResponse._writeMessageJSON(fetchResponse));
        },
        

        /**
         * Deserializes a FetchResponse from JSON.
         */
        decodeJSON: function(json: string): FetchResponse {
          return FetchResponse._readMessageJSON(FetchResponse.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a FetchResponse with all fields set to their default value.
         */
        initialize: function(): FetchResponse {
          return {
            progress: Progress.initialize(),step: Step.initialize(),
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<FetchResponse>, writer: BinaryWriter): BinaryWriter {
          if (msg.progress) {writer.writeMessage(1, msg.progress , Progress._writeMessage);}
if (msg.step) {writer.writeMessage(2, msg.step , Step._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<FetchResponse>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.progress) {const progress = Progress._writeMessageJSON(msg.progress);if (Object.keys(progress).length > 0) {json.progress = progress;}}
if (msg.step) {const step = Step._writeMessageJSON(msg.step);if (Object.keys(step).length > 0) {json.step = step;}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: FetchResponse, reader: BinaryReader): FetchResponse {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {
                      reader.readMessage(msg.progress, Progress._readMessage);
                    break;
}
case 2: {
                      reader.readMessage(msg.step, Step._readMessage);
                    break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: FetchResponse, json: any): FetchResponse {
          const progress = json.progress ?? json.progress;if (progress) {const m = Progress.initialize();Progress._readMessageJSON(m, progress);msg.progress = m;}
const step = json.step ?? json.step;if (step) {const m = Step.initialize();Step._readMessageJSON(m, step);msg.step = m;}
          return msg;
        },

      };

export const UpdateRequest = {        /**
         * Serializes a UpdateRequest to protobuf.
         */
        encode: function(updateRequest: Partial<UpdateRequest>): Uint8Array {
          return UpdateRequest._writeMessage(updateRequest, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a UpdateRequest from protobuf.
         */
        decode: function(bytes: ByteSource): UpdateRequest {
          return UpdateRequest._readMessage(UpdateRequest.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a UpdateRequest to JSON.
         */
        encodeJSON: function(updateRequest: Partial<UpdateRequest>): string {
          return JSON.stringify(UpdateRequest._writeMessageJSON(updateRequest));
        },
        

        /**
         * Deserializes a UpdateRequest from JSON.
         */
        decodeJSON: function(json: string): UpdateRequest {
          return UpdateRequest._readMessageJSON(UpdateRequest.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a UpdateRequest with all fields set to their default value.
         */
        initialize: function(): UpdateRequest {
          return {
            leadId: 0n,stepName: '',answers: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<UpdateRequest>, writer: BinaryWriter): BinaryWriter {
          if (msg.leadId) {writer.writeInt64String(1, msg.leadId.toString());}
if (msg.stepName) {writer.writeString(2, msg.stepName);}
if (msg.answers?.length) {writer.writeRepeatedMessage(3, msg.answers as any, InputValue._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<UpdateRequest>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.leadId) {json.leadId = msg.leadId.toString();}
if (msg.stepName) {json.stepName = msg.stepName;}
if (msg.answers?.length) {json.answers = msg.answers.map(InputValue._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: UpdateRequest, reader: BinaryReader): UpdateRequest {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.leadId = BigInt(reader.readInt64String());break;
}
case 2: {msg.stepName = reader.readString();break;
}
case 3: {const m = InputValue.initialize();reader.readMessage(m, InputValue._readMessage);msg.answers.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: UpdateRequest, json: any): UpdateRequest {
          const leadId = json.leadId ?? json.lead_id;if (leadId) {msg.leadId = BigInt(leadId);}
const stepName = json.stepName ?? json.step_name;if (stepName) {msg.stepName = stepName;}
const answers = json.answers ?? json.answers;if (answers) {for (const item of answers) {const m = InputValue.initialize();InputValue._readMessageJSON(m, item);msg.answers.push(m);}}
          return msg;
        },

      };

export const UpdateResponse = {        /**
         * Serializes a UpdateResponse to protobuf.
         */
        encode: function(updateResponse: Partial<UpdateResponse>): Uint8Array {
          return UpdateResponse._writeMessage(updateResponse, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a UpdateResponse from protobuf.
         */
        decode: function(bytes: ByteSource): UpdateResponse {
          return UpdateResponse._readMessage(UpdateResponse.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a UpdateResponse to JSON.
         */
        encodeJSON: function(updateResponse: Partial<UpdateResponse>): string {
          return JSON.stringify(UpdateResponse._writeMessageJSON(updateResponse));
        },
        

        /**
         * Deserializes a UpdateResponse from JSON.
         */
        decodeJSON: function(json: string): UpdateResponse {
          return UpdateResponse._readMessageJSON(UpdateResponse.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a UpdateResponse with all fields set to their default value.
         */
        initialize: function(): UpdateResponse {
          return {
            progress: Progress.initialize(),step: Step.initialize(),
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<UpdateResponse>, writer: BinaryWriter): BinaryWriter {
          if (msg.progress) {writer.writeMessage(1, msg.progress , Progress._writeMessage);}
if (msg.step) {writer.writeMessage(2, msg.step , Step._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<UpdateResponse>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.progress) {const progress = Progress._writeMessageJSON(msg.progress);if (Object.keys(progress).length > 0) {json.progress = progress;}}
if (msg.step) {const step = Step._writeMessageJSON(msg.step);if (Object.keys(step).length > 0) {json.step = step;}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: UpdateResponse, reader: BinaryReader): UpdateResponse {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {
                      reader.readMessage(msg.progress, Progress._readMessage);
                    break;
}
case 2: {
                      reader.readMessage(msg.step, Step._readMessage);
                    break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: UpdateResponse, json: any): UpdateResponse {
          const progress = json.progress ?? json.progress;if (progress) {const m = Progress.initialize();Progress._readMessageJSON(m, progress);msg.progress = m;}
const step = json.step ?? json.step;if (step) {const m = Step.initialize();Step._readMessageJSON(m, step);msg.step = m;}
          return msg;
        },

      };

export const PreviousRequest = {        /**
         * Serializes a PreviousRequest to protobuf.
         */
        encode: function(previousRequest: Partial<PreviousRequest>): Uint8Array {
          return PreviousRequest._writeMessage(previousRequest, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a PreviousRequest from protobuf.
         */
        decode: function(bytes: ByteSource): PreviousRequest {
          return PreviousRequest._readMessage(PreviousRequest.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a PreviousRequest to JSON.
         */
        encodeJSON: function(previousRequest: Partial<PreviousRequest>): string {
          return JSON.stringify(PreviousRequest._writeMessageJSON(previousRequest));
        },
        

        /**
         * Deserializes a PreviousRequest from JSON.
         */
        decodeJSON: function(json: string): PreviousRequest {
          return PreviousRequest._readMessageJSON(PreviousRequest.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a PreviousRequest with all fields set to their default value.
         */
        initialize: function(): PreviousRequest {
          return {
            leadId: 0n,
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<PreviousRequest>, writer: BinaryWriter): BinaryWriter {
          if (msg.leadId) {writer.writeInt64String(1, msg.leadId.toString());}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<PreviousRequest>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.leadId) {json.leadId = msg.leadId.toString();}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: PreviousRequest, reader: BinaryReader): PreviousRequest {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.leadId = BigInt(reader.readInt64String());break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: PreviousRequest, json: any): PreviousRequest {
          const leadId = json.leadId ?? json.lead_id;if (leadId) {msg.leadId = BigInt(leadId);}
          return msg;
        },

      };

export const PreviousResponse = {        /**
         * Serializes a PreviousResponse to protobuf.
         */
        encode: function(previousResponse: Partial<PreviousResponse>): Uint8Array {
          return PreviousResponse._writeMessage(previousResponse, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a PreviousResponse from protobuf.
         */
        decode: function(bytes: ByteSource): PreviousResponse {
          return PreviousResponse._readMessage(PreviousResponse.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a PreviousResponse to JSON.
         */
        encodeJSON: function(previousResponse: Partial<PreviousResponse>): string {
          return JSON.stringify(PreviousResponse._writeMessageJSON(previousResponse));
        },
        

        /**
         * Deserializes a PreviousResponse from JSON.
         */
        decodeJSON: function(json: string): PreviousResponse {
          return PreviousResponse._readMessageJSON(PreviousResponse.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a PreviousResponse with all fields set to their default value.
         */
        initialize: function(): PreviousResponse {
          return {
            progress: Progress.initialize(),step: Step.initialize(),
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<PreviousResponse>, writer: BinaryWriter): BinaryWriter {
          if (msg.progress) {writer.writeMessage(1, msg.progress , Progress._writeMessage);}
if (msg.step) {writer.writeMessage(2, msg.step , Step._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<PreviousResponse>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.progress) {const progress = Progress._writeMessageJSON(msg.progress);if (Object.keys(progress).length > 0) {json.progress = progress;}}
if (msg.step) {const step = Step._writeMessageJSON(msg.step);if (Object.keys(step).length > 0) {json.step = step;}}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: PreviousResponse, reader: BinaryReader): PreviousResponse {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {
                      reader.readMessage(msg.progress, Progress._readMessage);
                    break;
}
case 2: {
                      reader.readMessage(msg.step, Step._readMessage);
                    break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: PreviousResponse, json: any): PreviousResponse {
          const progress = json.progress ?? json.progress;if (progress) {const m = Progress.initialize();Progress._readMessageJSON(m, progress);msg.progress = m;}
const step = json.step ?? json.step;if (step) {const m = Step.initialize();Step._readMessageJSON(m, step);msg.step = m;}
          return msg;
        },

      };

export const Step = {        /**
         * Serializes a Step to protobuf.
         */
        encode: function(step: Partial<Step>): Uint8Array {
          return Step._writeMessage(step, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Step from protobuf.
         */
        decode: function(bytes: ByteSource): Step {
          return Step._readMessage(Step.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Step to JSON.
         */
        encodeJSON: function(step: Partial<Step>): string {
          return JSON.stringify(Step._writeMessageJSON(step));
        },
        

        /**
         * Deserializes a Step from JSON.
         */
        decodeJSON: function(json: string): Step {
          return Step._readMessageJSON(Step.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Step with all fields set to their default value.
         */
        initialize: function(): Step {
          return {
            name: '',previousName: '',inputDescriptors: [],answers: [],
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Step>, writer: BinaryWriter): BinaryWriter {
          if (msg.name) {writer.writeString(1, msg.name);}
if (msg.previousName) {writer.writeString(2, msg.previousName);}
if (msg.inputDescriptors?.length) {writer.writeRepeatedMessage(3, msg.inputDescriptors as any, InputDescriptor._writeMessage);}
if (msg.answers?.length) {writer.writeRepeatedMessage(5, msg.answers as any, InputValue._writeMessage);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Step>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.name) {json.name = msg.name;}
if (msg.previousName) {json.previousName = msg.previousName;}
if (msg.inputDescriptors?.length) {json.inputDescriptors = msg.inputDescriptors.map(InputDescriptor._writeMessageJSON)}
if (msg.answers?.length) {json.answers = msg.answers.map(InputValue._writeMessageJSON)}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Step, reader: BinaryReader): Step {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.name = reader.readString();break;
}
case 2: {msg.previousName = reader.readString();break;
}
case 3: {const m = InputDescriptor.initialize();reader.readMessage(m, InputDescriptor._readMessage);msg.inputDescriptors.push(m);break;
}
case 5: {const m = InputValue.initialize();reader.readMessage(m, InputValue._readMessage);msg.answers.push(m);break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Step, json: any): Step {
          const name = json.name ?? json.name;if (name) {msg.name = name;}
const previousName = json.previousName ?? json.previous_name;if (previousName) {msg.previousName = previousName;}
const inputDescriptors = json.inputDescriptors ?? json.input_descriptors;if (inputDescriptors) {for (const item of inputDescriptors) {const m = InputDescriptor.initialize();InputDescriptor._readMessageJSON(m, item);msg.inputDescriptors.push(m);}}
const answers = json.answers ?? json.answers;if (answers) {for (const item of answers) {const m = InputValue.initialize();InputValue._readMessageJSON(m, item);msg.answers.push(m);}}
          return msg;
        },

      };

export const Progress = {        /**
         * Serializes a Progress to protobuf.
         */
        encode: function(progress: Partial<Progress>): Uint8Array {
          return Progress._writeMessage(progress, new BinaryWriter()).getResultBuffer();
        },
        

        /**
         * Deserializes a Progress from protobuf.
         */
        decode: function(bytes: ByteSource): Progress {
          return Progress._readMessage(Progress.initialize(), new BinaryReader(bytes));
        },
        

        /**
         * Serializes a Progress to JSON.
         */
        encodeJSON: function(progress: Partial<Progress>): string {
          return JSON.stringify(Progress._writeMessageJSON(progress));
        },
        

        /**
         * Deserializes a Progress from JSON.
         */
        decodeJSON: function(json: string): Progress {
          return Progress._readMessageJSON(Progress.initialize(), JSON.parse(json));
        },
        

        /**
         * Initializes a Progress with all fields set to their default value.
         */
        initialize: function(): Progress {
          return {
            stepCount: 0,currentStep: 0,subStepCount: 0,currentSubStep: 0,
          };
        },

        /**
         * @private
         */
        _writeMessage: function(msg : Partial<Progress>, writer: BinaryWriter): BinaryWriter {
          if (msg.stepCount) {writer.writeInt32(1, msg.stepCount);}
if (msg.currentStep) {writer.writeInt32(2, msg.currentStep);}
if (msg.subStepCount) {writer.writeInt32(3, msg.subStepCount);}
if (msg.currentSubStep) {writer.writeInt32(4, msg.currentSubStep);}
            return writer;
        },

        /**
         * @private
         */
        _writeMessageJSON: function(msg : Partial<Progress>): Record<string, unknown> {
          const json: Record<string, unknown> = {};
          if (msg.stepCount) {json.stepCount = msg.stepCount;}
if (msg.currentStep) {json.currentStep = msg.currentStep;}
if (msg.subStepCount) {json.subStepCount = msg.subStepCount;}
if (msg.currentSubStep) {json.currentSubStep = msg.currentSubStep;}
          return json;
        },
        
        /**
         * @private
         */
        _readMessage: function(msg: Progress, reader: BinaryReader): Progress {
          while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
              case 1: {msg.stepCount = reader.readInt32();break;
}
case 2: {msg.currentStep = reader.readInt32();break;
}
case 3: {msg.subStepCount = reader.readInt32();break;
}
case 4: {msg.currentSubStep = reader.readInt32();break;
}
              default: {
                reader.skipField();
                break;
              }
            }
          }
          return msg;
        },

        /**
         * @private
         */
        _readMessageJSON: function(msg: Progress, json: any): Progress {
          const stepCount = json.stepCount ?? json.step_count;if (stepCount) {msg.stepCount = stepCount;}
const currentStep = json.currentStep ?? json.current_step;if (currentStep) {msg.currentStep = currentStep;}
const subStepCount = json.subStepCount ?? json.sub_step_count;if (subStepCount) {msg.subStepCount = subStepCount;}
const currentSubStep = json.currentSubStep ?? json.current_sub_step;if (currentSubStep) {msg.currentSubStep = currentSubStep;}
          return msg;
        },

      };


